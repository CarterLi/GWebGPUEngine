{"componentChunkName":"component---node-modules-antv-gatsby-theme-antv-site-templates-example-tsx","path":"/zh/examples/gpgpu/graph/fruchterman","result":{"data":{"site":{"siteMetadata":{"title":"GWebGPU","examples":[{"slug":"gpgpu/basic","icon":"gallery","title":{"zh":"基础算法","en":"Basic Algorithms"}},{"slug":"gpgpu/graph","icon":"gallery","title":{"zh":"图算法","en":"Graph"}},{"slug":"rendering","icon":"gallery","title":{"zh":"渲染","en":"Rendering"}}],"playground":{"container":"<div style=\"justify-content: center;position: relative\" id=\"wrapper\"/>","playgroundDidMount":"(function(history){\n        var pushState = history.pushState;\n        history.pushState = function(state) {\n          window.gwebgpuClean && window.gwebgpuClean();\n          return pushState.apply(history, arguments);\n        };\n      })(window.history);","playgroundWillUnmount":"window.gwebgpuClean && window.gwebgpuClean();","dependencies":{"@antv/g-webgpu":"latest"},"htmlCodeTemplate":null}},"pathPrefix":""},"allMarkdownRemark":{"edges":[{"node":{"fields":{"slug":"/zh/examples/gallery"},"frontmatter":{"title":"所有图表","order":-1,"icon":"other"},"parent":{"__typename":"File","relativePath":"gallery/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/gallery"},"frontmatter":{"title":"Gallery","order":-1,"icon":"other"},"parent":{"__typename":"File","relativePath":"gallery/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/interaction"},"frontmatter":{"title":"交互","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/interaction/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/interaction"},"frontmatter":{"title":"Interaction","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/interaction/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/gpgpu/basic/add2vectors"},"frontmatter":{"title":"两个向量相加","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/add2vectors/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/gpgpu/basic/add2vectors"},"frontmatter":{"title":"Add 2 vectors","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/add2vectors/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/camera"},"frontmatter":{"title":"相机","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/camera/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/camera"},"frontmatter":{"title":"Camera","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/camera/index.en.md"}}},{"node":{"fields":{"slug":"/en/examples/gpgpu/graph/fruchterman"},"frontmatter":{"title":"Fruchterman Layout","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/graph/fruchterman/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/gpgpu/graph/fruchterman"},"frontmatter":{"title":"Fruchterman 布局算法","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/graph/fruchterman/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/gpgpu/basic/mergeSort"},"frontmatter":{"title":"Merge Sort","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/mergeSort/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/gpgpu/basic/mergeSort"},"frontmatter":{"title":"归并排序","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/mergeSort/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/gpgpu/basic/bitonicSort"},"frontmatter":{"title":"Bitonic Sort (WebGPU Only)","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/bitonicSort/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/gpgpu/basic/bitonicSort"},"frontmatter":{"title":"奇偶排序 (WebGPU Only)","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/bitonicSort/index.zh.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/renderables"},"frontmatter":{"title":"Renderable","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/renderables/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/lighting"},"frontmatter":{"title":"Lighting","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/lighting/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/lighting"},"frontmatter":{"title":"光照","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/lighting/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/gpgpu/graph/sssp"},"frontmatter":{"title":"SSSP(Single source shortest path) (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/graph/sssp/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/gpgpu/graph/sssp"},"frontmatter":{"title":"单源最短路径算法 (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/graph/sssp/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/gpgpu/basic/reduce"},"frontmatter":{"title":"Reduce (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/reduce/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/gpgpu/basic/reduce"},"frontmatter":{"title":"Reduce (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/reduce/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/scenegraph"},"frontmatter":{"title":"SceneGraph","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/scenegraph/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/scenegraph"},"frontmatter":{"title":"场景图","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/scenegraph/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/renderables"},"frontmatter":{"title":"Post Processing","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/renderables/index.en.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/material"},"frontmatter":{"title":"Material","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/material/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/material"},"frontmatter":{"title":"材质","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/material/index.zh.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/geometry"},"frontmatter":{"title":"几何体","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/geometry/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/geometry"},"frontmatter":{"title":"Geometry","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/geometry/index.en.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/postprocessing"},"frontmatter":{"title":"后处理","order":5,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/postprocessing/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/postprocessing"},"frontmatter":{"title":"后处理","order":5,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/postprocessing/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/experiment/unitchart"},"frontmatter":{"title":"Unitchart","order":6,"icon":null},"parent":{"__typename":"File","relativePath":"experiment/unitchart/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/experiment/unitchart"},"frontmatter":{"title":"Unitchart","order":6,"icon":null},"parent":{"__typename":"File","relativePath":"experiment/unitchart/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/experiment/raytracer"},"frontmatter":{"title":"RayTracer","order":7,"icon":null},"parent":{"__typename":"File","relativePath":"experiment/raytracer/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/experiment/raytracer"},"frontmatter":{"title":"RayTracer","order":7,"icon":null},"parent":{"__typename":"File","relativePath":"experiment/raytracer/index.zh.md"}}}]}},"pageContext":{"allDemos":[{"relativePath":"rendering/scenegraph/demo/cubes.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/scenegraph/demo/cubes.tsx","order":1,"filename":"cubes.tsx","title":"Attach cubes to a rotating group","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*OEcdTJOyRQMAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"en":{"title":"SceneGraph","order":303},"zh":{"title":"场景图","order":303}}},{"relativePath":"rendering/scenegraph/demo/solar-system.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/scenegraph/demo/solar-system.tsx","order":0,"filename":"solar-system.tsx","title":"Solar system","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*0d6WQa-BbUQAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"en":{"title":"SceneGraph","order":303},"zh":{"title":"场景图","order":303}}},{"relativePath":"rendering/renderables/demo/cube.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/renderables/demo/cube.tsx","order":3,"filename":"cube.tsx","title":"A Rotating Cube","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"Renderable","order":302},"en":{"title":"Post Processing","order":303}}},{"relativePath":"rendering/renderables/demo/grid.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/renderables/demo/grid.tsx","order":2,"filename":"grid.tsx","title":"Grid","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*dYVxQoW7gmIAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"Renderable","order":302},"en":{"title":"Post Processing","order":303}}},{"relativePath":"rendering/renderables/demo/line.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/renderables/demo/line.tsx","order":1,"filename":"line.tsx","title":"2D Line","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"Renderable","order":302},"en":{"title":"Post Processing","order":303}}},{"relativePath":"rendering/renderables/demo/point.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/renderables/demo/point.tsx","order":0,"filename":"point.tsx","title":"2D Point","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*UOGoTILse-0AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"Renderable","order":302},"en":{"title":"Post Processing","order":303}}},{"relativePath":"rendering/material/demo/basic.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/material/demo/basic.tsx","order":0,"filename":"basic.tsx","title":"Basic Material","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*dV0gTafuRHsAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"en":{"title":"Material","order":303},"zh":{"title":"材质","order":303}}},{"relativePath":"rendering/interaction/demo/multi-canvas.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/interaction/demo/multi-canvas.tsx","order":2,"filename":"multi-canvas.tsx","hidden":true,"title":"Multi canvas contexts(Not recommended)","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"交互","order":300},"en":{"title":"Interaction","order":300}}},{"relativePath":"rendering/interaction/demo/multi-view.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/interaction/demo/multi-view.tsx","order":1,"filename":"multi-view.tsx","title":"Multi views(Recommended)","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*ytT4SoKan_0AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"交互","order":300},"en":{"title":"Interaction","order":300}}},{"relativePath":"rendering/interaction/demo/pixel-picker.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/interaction/demo/pixel-picker.tsx","order":4,"filename":"pixel-picker.tsx","title":"PixelPicker","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"交互","order":300},"en":{"title":"Interaction","order":300}}},{"relativePath":"rendering/interaction/demo/ray-picker.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/interaction/demo/ray-picker.tsx","order":3,"filename":"ray-picker.tsx","title":"RayPicker","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"交互","order":300},"en":{"title":"Interaction","order":300}}},{"relativePath":"rendering/interaction/demo/responsive.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/interaction/demo/responsive.tsx","order":0,"filename":"responsive.tsx","title":"Use a responsive viewport","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*ByguS56BAO0AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"交互","order":300},"en":{"title":"Interaction","order":300}}},{"relativePath":"rendering/geometry/demo/box.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/geometry/demo/box.tsx","order":0,"filename":"box.tsx","title":"Box","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*dV0gTafuRHsAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"几何体","order":303},"en":{"title":"Geometry","order":303}}},{"relativePath":"rendering/geometry/demo/merged.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/geometry/demo/merged.tsx","order":3,"filename":"merged.tsx","title":"Merged geometry","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*_fOKRJ18IcUAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"几何体","order":303},"en":{"title":"Geometry","order":303}}},{"relativePath":"rendering/geometry/demo/plane.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/geometry/demo/plane.tsx","order":2,"filename":"plane.tsx","title":"Plane","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*6zGmSbSJHgcAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"几何体","order":303},"en":{"title":"Geometry","order":303}}},{"relativePath":"rendering/geometry/demo/world.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/geometry/demo/world.tsx","order":4,"filename":"world.tsx","title":"World","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*jQpbRrS6en0AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"几何体","order":303},"en":{"title":"Geometry","order":303}}},{"relativePath":"rendering/geometry/demo/sphere.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/geometry/demo/sphere.tsx","order":1,"filename":"sphere.tsx","title":"Sphere","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*jQpbRrS6en0AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"几何体","order":303},"en":{"title":"Geometry","order":303}}},{"relativePath":"rendering/camera/demo/landmark.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/camera/demo/landmark.tsx","order":0,"filename":"landmark.tsx","title":"Switch to landmarks of a camera","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*nIKoSa3zNBMAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"相机","order":301},"en":{"title":"Camera","order":301}}},{"relativePath":"rendering/camera/demo/perspective.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/camera/demo/perspective.tsx","order":2,"filename":"perspective.tsx","title":"Camera with perspective projection","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*5aAORoqcdI0AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"相机","order":301},"en":{"title":"Camera","order":301}}},{"relativePath":"rendering/camera/demo/tracking.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/camera/demo/tracking.tsx","order":3,"filename":"tracking.tsx","title":"Tracking","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*RApkT63FesAAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"相机","order":301},"en":{"title":"Camera","order":301}}},{"relativePath":"rendering/camera/demo/ortho.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/camera/demo/ortho.tsx","order":1,"filename":"ortho.tsx","title":"Camera with orthographic projection","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*QQghSadPJnkAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"相机","order":301},"en":{"title":"Camera","order":301}}},{"relativePath":"gpgpu/graph/sssp/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/sssp/demo/index.tsx","order":0,"filename":"index.tsx","title":"Bellman-Ford","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*U_ynS4APYr8AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"en":{"title":"SSSP(Single source shortest path) (WebGPU Only)","order":2},"zh":{"title":"单源最短路径算法 (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/graph/sssp/demo/perf.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/sssp/demo/perf.tsx","order":1,"filename":"perf.tsx","title":"Bellman-Ford in a large directed graph","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"SSSP(Single source shortest path) (WebGPU Only)","order":2},"zh":{"title":"单源最短路径算法 (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/graph/fruchterman/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/fruchterman/demo/index.tsx","order":0,"filename":"index.tsx","title":"Fruchterman 布局算法","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Fruchterman Layout","order":1},"zh":{"title":"Fruchterman 布局算法","order":1}}},{"relativePath":"gpgpu/graph/fruchterman/demo/precompiled.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/fruchterman/demo/precompiled.tsx","order":1,"filename":"precompiled.tsx","title":"Fruchterman 布局算法(预编译)","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Fruchterman Layout","order":1},"zh":{"title":"Fruchterman 布局算法","order":1}}},{"relativePath":"gpgpu/graph/fruchterman/demo/cluster.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/fruchterman/demo/cluster.tsx","order":2,"filename":"cluster.tsx","title":"Cluster","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Fruchterman Layout","order":1},"zh":{"title":"Fruchterman 布局算法","order":1}}},{"relativePath":"gpgpu/basic/reduce/demo/reduce1.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/reduce/demo/reduce1.tsx","order":0,"filename":"reduce1.tsx","title":"Reduce 基础版本","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Reduce (WebGPU Only)","order":2},"zh":{"title":"Reduce (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/basic/reduce/demo/reduce2.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/reduce/demo/reduce2.tsx","order":1,"filename":"reduce2.tsx","title":"Reduce 改进 2.0","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Reduce (WebGPU Only)","order":2},"zh":{"title":"Reduce (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/basic/reduce/demo/reduce3.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/reduce/demo/reduce3.tsx","order":2,"filename":"reduce3.tsx","title":"Reduce 改进 3.0","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Reduce (WebGPU Only)","order":2},"zh":{"title":"Reduce (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/basic/reduce/demo/reduce4.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/reduce/demo/reduce4.tsx","order":3,"filename":"reduce4.tsx","title":"Reduce 改进 4.0","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Reduce (WebGPU Only)","order":2},"zh":{"title":"Reduce (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/basic/reduce/demo/reduce5.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/reduce/demo/reduce5.tsx","order":4,"filename":"reduce5.tsx","title":"Reduce 改进 5.0","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Reduce (WebGPU Only)","order":2},"zh":{"title":"Reduce (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/basic/mergeSort/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/mergeSort/demo/index.tsx","order":0,"filename":"index.tsx","title":"归并排序","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Merge Sort","order":1},"zh":{"title":"归并排序","order":1}}},{"relativePath":"gpgpu/basic/bitonicSort/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/bitonicSort/demo/index.tsx","order":0,"filename":"index.tsx","title":"奇偶排序","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Bitonic Sort (WebGPU Only)","order":1},"zh":{"title":"奇偶排序 (WebGPU Only)","order":1}}},{"relativePath":"gpgpu/basic/add2vectors/demo/add2vectors-precompiled.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/add2vectors/demo/add2vectors-precompiled.tsx","order":-1,"filename":"add2vectors-precompiled.tsx","postFrontmatter":{"zh":{"title":"两个向量相加","order":0},"en":{"title":"Add 2 vectors","order":0}}},{"relativePath":"gpgpu/basic/add2vectors/demo/add2vectors.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/add2vectors/demo/add2vectors.tsx","order":-1,"filename":"add2vectors.tsx","postFrontmatter":{"zh":{"title":"两个向量相加","order":0},"en":{"title":"Add 2 vectors","order":0}}},{"relativePath":"gpgpu/basic/add2vectors/demo/iteration.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/add2vectors/demo/iteration.tsx","order":2,"filename":"iteration.tsx","title":"迭代多次，串联自身","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"两个向量相加","order":0},"en":{"title":"Add 2 vectors","order":0}}},{"relativePath":"gpgpu/basic/add2vectors/demo/pipeline.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/add2vectors/demo/pipeline.tsx","order":3,"filename":"pipeline.tsx","title":"串联多个 Kernel","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"两个向量相加","order":0},"en":{"title":"Add 2 vectors","order":0}}},{"relativePath":"experiment/unitchart/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/experiment/unitchart/demo/index.tsx","order":0,"filename":"index.tsx","title":"Unitchart","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Unitchart","order":6},"zh":{"title":"Unitchart","order":6}}},{"relativePath":"experiment/raytracer/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/experiment/raytracer/demo/index.tsx","order":0,"filename":"index.tsx","title":"RayTracer","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*FARSSo38alcAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"en":{"title":"RayTracer","order":7},"zh":{"title":"RayTracer","order":7}}}],"exampleSections":{"examples":[{"relativePath":"gpgpu/graph/fruchterman/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/fruchterman/demo/index.tsx","order":0,"filename":"index.tsx","title":"Fruchterman 布局算法","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","source":"import { Canvas } from '@antv/g-canvas';\nimport { World } from '@antv/g-webgpu';\nimport { Compiler } from '@antv/g-webgpu-compiler';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst gCode = `\nimport { globalInvocationID } from 'g-webgpu';\n\nconst MAX_EDGE_PER_VERTEX;\nconst VERTEX_COUNT;\n\n@numthreads(1, 1, 1)\nclass Fruchterman {\n  @in @out\n  u_Data: vec4[];\n\n  @in\n  u_K: float;\n\n  @in\n  u_K2: float;\n\n  @in\n  u_Gravity: float;\n\n  @in\n  u_Center: vec2;\n\n  @in\n  u_Speed: float;\n\n  @in\n  u_MaxDisplace: float;\n\n\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      if (i != j) {\n        const nextNode = this.u_Data[j];\n        const xDist = currentNode[0] - nextNode[0];\n        const yDist = currentNode[1] - nextNode[1];\n        const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\n        if (dist > 0.0) {\n          const repulsiveF = this.u_K2 / dist;\n          dx += xDist / dist * repulsiveF;\n          dy += yDist / dist * repulsiveF;\n        }\n      }\n    }\n    return [dx, dy];\n  }\n\n  calcGravity(currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    const vx = currentNode[0] - this.u_Center[0];\n    const vy = currentNode[1] - this.u_Center[1];\n    const gf = 0.01 * this.u_K * this.u_Gravity;\n    dx = gf * vx;\n    dy = gf * vy;\n\n    return [dx, dy];\n  }\n\n  calcAttractive(currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    const arr_offset = int(floor(currentNode[2] + 0.5));\n    const length = int(floor(currentNode[3] + 0.5));\n    const node_buffer: vec4;\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\n      if (p >= length) break;\n      const arr_idx = arr_offset + p;\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\n      if (p == 0 || buf_offset == 0) {\n        node_buffer = this.u_Data[int(arr_idx / 4)];\n      }\n      const float_j = buf_offset == 0 ? node_buffer[0] :\n                      buf_offset == 1 ? node_buffer[1] :\n                      buf_offset == 2 ? node_buffer[2] :\n                                        node_buffer[3];\n      const nextNode = this.u_Data[int(float_j)];\n      const xDist = currentNode[0] - nextNode[0];\n      const yDist = currentNode[1] - nextNode[1];\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\n      const attractiveF = dist * dist / this.u_K;\n      if (dist > 0.0) {\n        dx -= xDist / dist * attractiveF;\n        dy -= yDist / dist * attractiveF;\n      }\n    }\n    return [dx, dy];\n  }\n\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const currentNode = this.u_Data[i];\n\n    let dx = 0, dy = 0;\n\n    if (i >= VERTEX_COUNT) {\n      this.u_Data[i] = currentNode;\n      return;\n    }\n\n    // repulsive\n    const repulsive = this.calcRepulsive(i, currentNode);\n    dx += repulsive[0];\n    dy += repulsive[1];\n\n    // attractive\n    const attractive = this.calcAttractive(currentNode);\n    dx += attractive[0];\n    dy += attractive[1];\n\n    // gravity\n    const gravity = this.calcGravity(currentNode);\n    dx -= gravity[0];\n    dy -= gravity[1];\n\n    // speed\n    dx *= this.u_Speed;\n    dy *= this.u_Speed;\n\n    // move\n    const distLength = sqrt(dx * dx + dy * dy);\n    if (distLength > 0.0) {\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\n\n      this.u_Data[i] = [\n        currentNode[0] + dx / distLength * limitedDist,\n        currentNode[1] + dy / distLength * limitedDist,\n        currentNode[2],\n        currentNode[3]\n      ];\n    }\n  }\n}\n`;\n\nconst MAX_ITERATION = 1000;\n\nconst App = React.memo(function Fruchterman() {\n  const [timeElapsed, setTimeElapsed] = useState(0);\n  useEffect(() => {\n    (async () => {\n      // @see https://g6.antv.vision/en/examples/net/forceDirected/#basicForceDirected\n      const data = await (\n        await fetch(\n          'https://gw.alipayobjects.com/os/basement_prod/7bacd7d1-4119-4ac1-8be3-4c4b9bcbc25f.json',\n        )\n      ).json();\n\n      const center = [CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2];\n      const nodes = data.nodes.map((n) => ({\n        x: Math.random() * CANVAS_WIDTH,\n        y: Math.random() * CANVAS_HEIGHT,\n        id: n.id,\n      }));\n      const edges = data.edges;\n      const numParticles = nodes.length;\n      const nodesEdgesArray = buildTextureData(nodes, edges);\n\n      // compile our kernel code\n      const compiler = new Compiler();\n      const precompiledBundle = compiler.compileBundle(gCode);\n\n      // console.log(precompiledBundle.toString());\n\n      // create world\n      const world = World.create({\n        engineOptions: {\n          supportCompute: true,\n        },\n      });\n\n      const timeStart = window.performance.now();\n      const area = CANVAS_HEIGHT * CANVAS_WIDTH;\n      let maxDisplace = Math.sqrt(area) / 10;\n      const k2 = area / (nodes.length + 1);\n      const k = Math.sqrt(k2);\n      const kernel = world\n        .createKernel(precompiledBundle)\n        .setDispatch([numParticles, 1, 1])\n        .setBinding({\n          u_Data: nodesEdgesArray,\n          u_K: k,\n          u_K2: k2,\n          u_Gravity: 10,\n          u_Speed: 0.1,\n          u_MaxDisplace: maxDisplace,\n          u_Center: center,\n          MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n          VERTEX_COUNT: numParticles,\n        });\n\n      for (let i = 0; i < MAX_ITERATION; i++) {\n        await kernel.execute();\n        kernel.setBinding({\n          u_MaxDisplace: maxDisplace *= 0.99,\n        });\n      }\n      // or use batch:\n      // await kernel.execute(MAX_ITERATION);\n\n      const finalParticleData = await kernel.getOutput();\n\n      setTimeElapsed(window.performance.now() - timeStart);\n      // draw with G\n      renderCircles(finalParticleData, numParticles);\n\n      window.gwebgpuClean = () => {\n        world.destroy();\n      };\n    })();\n  }, []);\n\n  return (\n    <>\n      <div>Elapsed time: {timeElapsed / 1000}s</div>\n      <div>\n        Ported from the same{' '}\n        <a href=\"https://g6.antv.vision/en/examples/net/furchtermanLayout#fruchtermanWebWorker\">\n          example\n        </a>{' '}\n        in G6\n      </div>\n      <div id=\"container\" />\n    </>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n\nconst CANVAS_HEIGHT = 600;\nconst CANVAS_WIDTH = 600;\nfunction renderCircles(finalParticleData, numParticles) {\n  const canvas = new Canvas({\n    container: 'container',\n    width: CANVAS_WIDTH,\n    height: CANVAS_HEIGHT,\n  });\n\n  // draw edges\n  for (let i = 0; i < lineIndexBufferData.length; i += 2) {\n    const x1 = finalParticleData[lineIndexBufferData[i] * 4];\n    const y1 = finalParticleData[lineIndexBufferData[i] * 4 + 1];\n    const x2 = finalParticleData[lineIndexBufferData[i + 1] * 4];\n    const y2 = finalParticleData[lineIndexBufferData[i + 1] * 4 + 1];\n    const group = canvas.addGroup();\n    group.addShape('line', {\n      attrs: {\n        x1,\n        y1,\n        x2,\n        y2,\n        stroke: '#1890FF',\n        lineWidth: 1,\n      },\n    });\n  }\n\n  // draw nodes\n  for (let i = 0; i < numParticles * 4; i += 4) {\n    const x = finalParticleData[i];\n    const y = finalParticleData[i + 1];\n    const group = canvas.addGroup();\n    group.addShape('circle', {\n      attrs: {\n        x,\n        y,\n        r: 5,\n        fill: 'red',\n        stroke: 'blue',\n        lineWidth: 2,\n      },\n    });\n  }\n}\n\nconst lineIndexBufferData = [];\nlet maxEdgePerVetex;\n// @see https://github.com/nblintao/ParaGraphL/blob/master/sigma.layout.paragraphl.js#L192-L229\nfunction buildTextureData(nodes, edges) {\n  const dataArray = [];\n  const nodeDict = [];\n  const mapIdPos = {};\n  let i = 0;\n  for (i = 0; i < nodes.length; i++) {\n    const n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n  for (i = 0; i < edges.length; i++) {\n    const e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    lineIndexBufferData.push(mapIdPos[e.source], mapIdPos[e.target]);\n  }\n\n  maxEdgePerVetex = 0;\n  for (i = 0; i < nodes.length; i++) {\n    const offset = dataArray.length;\n    const dests = nodeDict[i];\n    const len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = dests.length;\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n    for (let j = 0; j < len; ++j) {\n      const dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n  return new Float32Array(dataArray);\n}\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-canvas\", \"@antv/g-webgpu\", \"@antv/g-webgpu-compiler\", \"react\", \"react-dom\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-canvas\"), require(\"@antv/g-webgpu\"), require(\"@antv/g-webgpu-compiler\"), require(\"react\"), require(\"react-dom\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gCanvas, global.gWebgpu, global.gWebgpuCompiler, global.react, global.reactDom);\n    global.index = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gCanvas, _gWebgpu, _gWebgpuCompiler, _react, _reactDom) {\n  \"use strict\";\n\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  var gCode = \"\\nimport { globalInvocationID } from 'g-webgpu';\\n\\nconst MAX_EDGE_PER_VERTEX;\\nconst VERTEX_COUNT;\\n\\n@numthreads(1, 1, 1)\\nclass Fruchterman {\\n  @in @out\\n  u_Data: vec4[];\\n\\n  @in\\n  u_K: float;\\n\\n  @in\\n  u_K2: float;\\n\\n  @in\\n  u_Gravity: float;\\n\\n  @in\\n  u_Center: vec2;\\n\\n  @in\\n  u_Speed: float;\\n\\n  @in\\n  u_MaxDisplace: float;\\n\\n\\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\\n    let dx = 0, dy = 0;\\n    for (let j = 0; j < VERTEX_COUNT; j++) {\\n      if (i != j) {\\n        const nextNode = this.u_Data[j];\\n        const xDist = currentNode[0] - nextNode[0];\\n        const yDist = currentNode[1] - nextNode[1];\\n        const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\\n        if (dist > 0.0) {\\n          const repulsiveF = this.u_K2 / dist;\\n          dx += xDist / dist * repulsiveF;\\n          dy += yDist / dist * repulsiveF;\\n        }\\n      }\\n    }\\n    return [dx, dy];\\n  }\\n\\n  calcGravity(currentNode: vec4): vec2 {\\n    let dx = 0, dy = 0;\\n    const vx = currentNode[0] - this.u_Center[0];\\n    const vy = currentNode[1] - this.u_Center[1];\\n    const gf = 0.01 * this.u_K * this.u_Gravity;\\n    dx = gf * vx;\\n    dy = gf * vy;\\n\\n    return [dx, dy];\\n  }\\n\\n  calcAttractive(currentNode: vec4): vec2 {\\n    let dx = 0, dy = 0;\\n    const arr_offset = int(floor(currentNode[2] + 0.5));\\n    const length = int(floor(currentNode[3] + 0.5));\\n    const node_buffer: vec4;\\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\\n      if (p >= length) break;\\n      const arr_idx = arr_offset + p;\\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\\n      if (p == 0 || buf_offset == 0) {\\n        node_buffer = this.u_Data[int(arr_idx / 4)];\\n      }\\n      const float_j = buf_offset == 0 ? node_buffer[0] :\\n                      buf_offset == 1 ? node_buffer[1] :\\n                      buf_offset == 2 ? node_buffer[2] :\\n                                        node_buffer[3];\\n      const nextNode = this.u_Data[int(float_j)];\\n      const xDist = currentNode[0] - nextNode[0];\\n      const yDist = currentNode[1] - nextNode[1];\\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\\n      const attractiveF = dist * dist / this.u_K;\\n      if (dist > 0.0) {\\n        dx -= xDist / dist * attractiveF;\\n        dy -= yDist / dist * attractiveF;\\n      }\\n    }\\n    return [dx, dy];\\n  }\\n\\n  @main\\n  compute() {\\n    const i = globalInvocationID.x;\\n    const currentNode = this.u_Data[i];\\n\\n    let dx = 0, dy = 0;\\n\\n    if (i >= VERTEX_COUNT) {\\n      this.u_Data[i] = currentNode;\\n      return;\\n    }\\n\\n    // repulsive\\n    const repulsive = this.calcRepulsive(i, currentNode);\\n    dx += repulsive[0];\\n    dy += repulsive[1];\\n\\n    // attractive\\n    const attractive = this.calcAttractive(currentNode);\\n    dx += attractive[0];\\n    dy += attractive[1];\\n\\n    // gravity\\n    const gravity = this.calcGravity(currentNode);\\n    dx -= gravity[0];\\n    dy -= gravity[1];\\n\\n    // speed\\n    dx *= this.u_Speed;\\n    dy *= this.u_Speed;\\n\\n    // move\\n    const distLength = sqrt(dx * dx + dy * dy);\\n    if (distLength > 0.0) {\\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\\n\\n      this.u_Data[i] = [\\n        currentNode[0] + dx / distLength * limitedDist,\\n        currentNode[1] + dy / distLength * limitedDist,\\n        currentNode[2],\\n        currentNode[3]\\n      ];\\n    }\\n  }\\n}\\n\";\n  var MAX_ITERATION = 1000;\n\n  var App = /*#__PURE__*/_react.default.memo(function Fruchterman() {\n    var _useState = (0, _react.useState)(0),\n        _useState2 = _slicedToArray(_useState, 2),\n        timeElapsed = _useState2[0],\n        setTimeElapsed = _useState2[1];\n\n    (0, _react.useEffect)(function () {\n      (async function () {\n        // @see https://g6.antv.vision/en/examples/net/forceDirected/#basicForceDirected\n        var data = await (await fetch('https://gw.alipayobjects.com/os/basement_prod/7bacd7d1-4119-4ac1-8be3-4c4b9bcbc25f.json')).json();\n        var center = [CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2];\n        var nodes = data.nodes.map(function (n) {\n          return {\n            x: Math.random() * CANVAS_WIDTH,\n            y: Math.random() * CANVAS_HEIGHT,\n            id: n.id\n          };\n        });\n        var edges = data.edges;\n        var numParticles = nodes.length;\n        var nodesEdgesArray = buildTextureData(nodes, edges); // compile our kernel code\n\n        var compiler = new _gWebgpuCompiler.Compiler();\n        var precompiledBundle = compiler.compileBundle(gCode); // console.log(precompiledBundle.toString());\n        // create world\n\n        var world = _gWebgpu.World.create({\n          engineOptions: {\n            supportCompute: true\n          }\n        });\n\n        var timeStart = window.performance.now();\n        var area = CANVAS_HEIGHT * CANVAS_WIDTH;\n        var maxDisplace = Math.sqrt(area) / 10;\n        var k2 = area / (nodes.length + 1);\n        var k = Math.sqrt(k2);\n        var kernel = world.createKernel(precompiledBundle).setDispatch([numParticles, 1, 1]).setBinding({\n          u_Data: nodesEdgesArray,\n          u_K: k,\n          u_K2: k2,\n          u_Gravity: 10,\n          u_Speed: 0.1,\n          u_MaxDisplace: maxDisplace,\n          u_Center: center,\n          MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n          VERTEX_COUNT: numParticles\n        });\n\n        for (var i = 0; i < MAX_ITERATION; i++) {\n          await kernel.execute();\n          kernel.setBinding({\n            u_MaxDisplace: maxDisplace *= 0.99\n          });\n        } // or use batch:\n        // await kernel.execute(MAX_ITERATION);\n\n\n        var finalParticleData = await kernel.getOutput();\n        setTimeElapsed(window.performance.now() - timeStart); // draw with G\n\n        renderCircles(finalParticleData, numParticles);\n\n        window.gwebgpuClean = function () {\n          world.destroy();\n        };\n      })();\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"div\", null, \"Elapsed time: \", timeElapsed / 1000, \"s\"), /*#__PURE__*/_react.default.createElement(\"div\", null, \"Ported from the same\", ' ', /*#__PURE__*/_react.default.createElement(\"a\", {\n      href: \"https://g6.antv.vision/en/examples/net/furchtermanLayout#fruchtermanWebWorker\"\n    }, \"example\"), ' ', \"in G6\"), /*#__PURE__*/_react.default.createElement(\"div\", {\n      id: \"container\"\n    }));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n\n  var CANVAS_HEIGHT = 600;\n  var CANVAS_WIDTH = 600;\n\n  function renderCircles(finalParticleData, numParticles) {\n    var canvas = new _gCanvas.Canvas({\n      container: 'container',\n      width: CANVAS_WIDTH,\n      height: CANVAS_HEIGHT\n    }); // draw edges\n\n    for (var i = 0; i < lineIndexBufferData.length; i += 2) {\n      var x1 = finalParticleData[lineIndexBufferData[i] * 4];\n      var y1 = finalParticleData[lineIndexBufferData[i] * 4 + 1];\n      var x2 = finalParticleData[lineIndexBufferData[i + 1] * 4];\n      var y2 = finalParticleData[lineIndexBufferData[i + 1] * 4 + 1];\n      var group = canvas.addGroup();\n      group.addShape('line', {\n        attrs: {\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2,\n          stroke: '#1890FF',\n          lineWidth: 1\n        }\n      });\n    } // draw nodes\n\n\n    for (var _i2 = 0; _i2 < numParticles * 4; _i2 += 4) {\n      var x = finalParticleData[_i2];\n      var y = finalParticleData[_i2 + 1];\n\n      var _group = canvas.addGroup();\n\n      _group.addShape('circle', {\n        attrs: {\n          x: x,\n          y: y,\n          r: 5,\n          fill: 'red',\n          stroke: 'blue',\n          lineWidth: 2\n        }\n      });\n    }\n  }\n\n  var lineIndexBufferData = [];\n  var maxEdgePerVetex; // @see https://github.com/nblintao/ParaGraphL/blob/master/sigma.layout.paragraphl.js#L192-L229\n\n  function buildTextureData(nodes, edges) {\n    var dataArray = [];\n    var nodeDict = [];\n    var mapIdPos = {};\n    var i = 0;\n\n    for (i = 0; i < nodes.length; i++) {\n      var n = nodes[i];\n      mapIdPos[n.id] = i;\n      dataArray.push(n.x);\n      dataArray.push(n.y);\n      dataArray.push(0);\n      dataArray.push(0);\n      nodeDict.push([]);\n    }\n\n    for (i = 0; i < edges.length; i++) {\n      var e = edges[i];\n      nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n      nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n      lineIndexBufferData.push(mapIdPos[e.source], mapIdPos[e.target]);\n    }\n\n    maxEdgePerVetex = 0;\n\n    for (i = 0; i < nodes.length; i++) {\n      var offset = dataArray.length;\n      var dests = nodeDict[i];\n      var len = dests.length;\n      dataArray[i * 4 + 2] = offset;\n      dataArray[i * 4 + 3] = dests.length;\n      maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n\n      for (var j = 0; j < len; ++j) {\n        var dest = dests[j];\n        dataArray.push(+dest);\n      }\n    }\n\n    while (dataArray.length % 4 !== 0) {\n      dataArray.push(0);\n    }\n\n    return new Float32Array(dataArray);\n  }\n});"},{"relativePath":"gpgpu/graph/fruchterman/demo/precompiled.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/fruchterman/demo/precompiled.tsx","order":1,"filename":"precompiled.tsx","title":"Fruchterman 布局算法(预编译)","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","source":"import { Canvas } from '@antv/g-canvas';\nimport { World } from '@antv/g-webgpu';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst MAX_ITERATION = 1000;\nconst CANVAS_HEIGHT = 600;\nconst CANVAS_WIDTH = 600;\nconst App = React.memo(function Fruchterman() {\n  const [timeElapsed, setTimeElapsed] = useState(0);\n  useEffect(() => {\n    (async () => {\n      // @see https://g6.antv.vision/en/examples/net/forceDirected/#basicForceDirected\n      const data = await (\n        await fetch(\n          'https://gw.alipayobjects.com/os/basement_prod/7bacd7d1-4119-4ac1-8be3-4c4b9bcbc25f.json',\n        )\n      ).json();\n\n      const center = [CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2];\n      const nodes = data.nodes.map((n) => ({\n        x: Math.random() * CANVAS_WIDTH,\n        y: Math.random() * CANVAS_HEIGHT,\n        id: n.id,\n      }));\n      const edges = data.edges;\n      const numParticles = nodes.length;\n      const nodesEdgesArray = buildTextureData(nodes, edges);\n\n      const precompiledBundle = `{\"shaders\":{\"WGSL\":\"import \\\\\"GLSL.std.450\\\\\" as std;\\\\n\\\\n\\\\n# var gWebGPUDebug : bool = false;\\\\n# var gWebGPUDebugOutput : vec4<f32> = vec4<f32>(0.0);\\\\n\\\\n[[builtin global_invocation_id]] var<in> globalInvocationID : vec3<u32>;\\\\n# [[builtin work_group_size]] var<in> workGroupSize : vec3<u32>;\\\\n# [[builtin work_group_id]] var<in> workGroupID : vec3<u32>;\\\\n[[builtin local_invocation_id]] var<in> localInvocationID : vec3<u32>;\\\\n# [[builtin num_work_groups]] var<in> numWorkGroups : vec3<u32>;\\\\n[[builtin local_invocation_idx]] var<in> localInvocationIndex : u32;\\\\n\\\\ntype GWebGPUParams = [[block]] struct {\\\\n  [[offset 0]] u_K : f32;\\\\n  [[offset 4]] u_K2 : f32;\\\\n  [[offset 8]] u_Gravity : f32;\\\\n  [[offset 12]] u_Center : vec2<f32>;\\\\n  [[offset 20]] u_Speed : f32;\\\\n  [[offset 24]] u_MaxDisplace : f32;\\\\n};\\\\n[[binding 0, set 0]] var<uniform> gWebGPUUniformParams : GWebGPUParams;\\\\ntype GWebGPUBuffer0 = [[block]] struct {\\\\n  [[offset 0]] u_Data : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 1, set 0]] var<storage_buffer> gWebGPUBuffer0 : GWebGPUBuffer0;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nfn calcRepulsive(i : i32, currentNode : vec4<f32>) -> vec2<f32> {var dx : f32 = 0.0;\\\\nvar dy : f32 = 0.0;\\\\nfor (var j : i32 = 0; j < __DefineValuePlaceholder__VERTEX_COUNT; j = j + 1) {if (i != j) {var nextNode : vec4<f32> = gWebGPUBuffer0.u_Data[j];\\\\nvar xDist : f32 = currentNode.x - nextNode.x;\\\\nvar yDist : f32 = currentNode.y - nextNode.y;\\\\nvar dist : f32 = std::sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nif (dist > 0.0) {var repulsiveF : f32 = gWebGPUUniformParams.u_K2 / dist;\\\\ndx = dx + (xDist / dist) * repulsiveF;\\\\ndy = dy + (yDist / dist) * repulsiveF;}}}\\\\nreturn vec2<f32>(dx, dy);}\\\\nfn calcGravity(currentNode : vec4<f32>) -> vec2<f32> {var dx : f32 = 0.0;\\\\nvar dy : f32 = 0.0;\\\\nvar vx : f32 = currentNode.x - gWebGPUUniformParams.u_Center.x;\\\\nvar vy : f32 = currentNode.y - gWebGPUUniformParams.u_Center.y;\\\\nvar gf : f32 = (0.01 * gWebGPUUniformParams.u_K) * gWebGPUUniformParams.u_Gravity;\\\\ndx = gf * vx;\\\\ndy = gf * vy;\\\\nreturn vec2<f32>(dx, dy);}\\\\nfn calcAttractive(currentNode : vec4<f32>) -> vec2<f32> {var dx : f32 = 0.0;\\\\nvar dy : f32 = 0.0;\\\\nvar arr_offset : i32 = i32(std::floor(currentNode.z + 0.5));\\\\nvar length : i32 = i32(std::floor(currentNode.w + 0.5));\\\\nvar node_buffer : vec4<f32>;\\\\nfor (var p : i32 = 0; p < __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX; p = p + 1) {if (p >= length) {break;}\\\\nvar arr_idx : i32 = arr_offset + i32(p);\\\\nvar buf_offset : i32 = arr_idx - ((arr_idx / 4) * 4);\\\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = gWebGPUBuffer0.u_Data[i32(arr_idx / 4)];}\\\\nvar float_j : f32 = select(node_buffer.x, select(node_buffer.y, select(node_buffer.z, node_buffer.w, buf_offset == 2), buf_offset == 1), buf_offset == 0);\\\\nvar nextNode : vec4<f32> = gWebGPUBuffer0.u_Data[i32(float_j)];\\\\nvar xDist : f32 = currentNode.x - nextNode.x;\\\\nvar yDist : f32 = currentNode.y - nextNode.y;\\\\nvar dist : f32 = std::sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nvar attractiveF : f32 = (dist * dist) / gWebGPUUniformParams.u_K;\\\\nif (dist > 0.0) {dx = dx - (xDist / dist) * attractiveF;\\\\ndy = dy - (yDist / dist) * attractiveF;}}\\\\nreturn vec2<f32>(dx, dy);}\\\\nfn main() -> void {var i : i32 = globalInvocationID.x;\\\\nvar currentNode : vec4<f32> = gWebGPUBuffer0.u_Data[i];\\\\nvar dx : f32 = 0.0;\\\\nvar dy : f32 = 0.0;\\\\nif (i >= __DefineValuePlaceholder__VERTEX_COUNT) {gWebGPUBuffer0.u_Data[i] = currentNode;\\\\nreturn ;}\\\\nvar repulsive : vec2<f32> = calcRepulsive(i, currentNode);\\\\ndx = dx + repulsive.x;\\\\ndy = dy + repulsive.y;\\\\nvar attractive : vec2<f32> = calcAttractive(currentNode);\\\\ndx = dx + attractive.x;\\\\ndy = dy + attractive.y;\\\\nvar gravity : vec2<f32> = calcGravity(currentNode);\\\\ndx = dx - gravity.x;\\\\ndy = dy - gravity.y;\\\\ndx = dx * gWebGPUUniformParams.u_Speed;\\\\ndy = dy * gWebGPUUniformParams.u_Speed;\\\\nvar distLength : f32 = std::sqrt((dx * dx) + (dy * dy));\\\\nif (distLength > 0.0) {var limitedDist : f32 = std::min(gWebGPUUniformParams.u_MaxDisplace * gWebGPUUniformParams.u_Speed, distLength);\\\\ngWebGPUBuffer0.u_Data[i] = vec4<f32>(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w);}\\\\nreturn;}\\\\n\\\\nentry_point compute as \\\\\"main\\\\\" = main;\\\\n\",\"GLSL450\":\"\\\\n\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\\\nivec3 workGroupSize = ivec3(1,1,1);\\\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\\\n\\\\nlayout(std140, set = 0, binding = 0) uniform GWebGPUParams {\\\\n  float u_K;\\\\n  float u_K2;\\\\n  float u_Gravity;\\\\n  vec2 u_Center;\\\\n  float u_Speed;\\\\n  float u_MaxDisplace;\\\\n} gWebGPUUniformParams;\\\\nlayout(std430, set = 0, binding = 1) buffer   GWebGPUBuffer0 {\\\\n  vec4 u_Data[];\\\\n} gWebGPUBuffer0;\\\\n\\\\n\\\\n\\\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\\\nlayout (\\\\n  local_size_x = 1,\\\\n  local_size_y = 1,\\\\n  local_size_z = 1\\\\n) in;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nvec2 calcRepulsive(int i, vec4 currentNode) {float dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = gWebGPUBuffer0.u_Data[j];\\\\nfloat xDist = currentNode.x - nextNode.x;\\\\nfloat yDist = currentNode.y - nextNode.y;\\\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nif (dist > 0.0) {float repulsiveF = gWebGPUUniformParams.u_K2 / dist;\\\\ndx += (xDist / dist) * repulsiveF;\\\\ndy += (yDist / dist) * repulsiveF;}}}\\\\nreturn vec2(dx, dy);}\\\\nvec2 calcGravity(vec4 currentNode) {float dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfloat vx = currentNode.x - gWebGPUUniformParams.u_Center.x;\\\\nfloat vy = currentNode.y - gWebGPUUniformParams.u_Center.y;\\\\nfloat gf = (0.01 * gWebGPUUniformParams.u_K) * gWebGPUUniformParams.u_Gravity;\\\\ndx = gf * vx;\\\\ndy = gf * vy;\\\\nreturn vec2(dx, dy);}\\\\nvec2 calcAttractive(vec4 currentNode) {float dx = 0.0;\\\\nfloat dy = 0.0;\\\\nint arr_offset = int(floor(currentNode.z + 0.5));\\\\nint length = int(floor(currentNode.w + 0.5));\\\\nvec4 node_buffer;\\\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\\\nint arr_idx = arr_offset + int(p);\\\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = gWebGPUBuffer0.u_Data[int(arr_idx / 4)];}\\\\nfloat float_j = (buf_offset == 0) ? (node_buffer.x) : ((buf_offset == 1) ? (node_buffer.y) : ((buf_offset == 2) ? (node_buffer.z) : (node_buffer.w)));\\\\nvec4 nextNode = gWebGPUBuffer0.u_Data[int(float_j)];\\\\nfloat xDist = currentNode.x - nextNode.x;\\\\nfloat yDist = currentNode.y - nextNode.y;\\\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nfloat attractiveF = (dist * dist) / gWebGPUUniformParams.u_K;\\\\nif (dist > 0.0) {dx -= (xDist / dist) * attractiveF;\\\\ndy -= (yDist / dist) * attractiveF;}}\\\\nreturn vec2(dx, dy);}\\\\nvoid main() {int i = globalInvocationID.x;\\\\nvec4 currentNode = gWebGPUBuffer0.u_Data[i];\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nif (i >= VERTEX_COUNT) {gWebGPUBuffer0.u_Data[i] = currentNode;\\\\nreturn ;}\\\\nvec2 repulsive = calcRepulsive(i, currentNode);\\\\ndx += repulsive.x;\\\\ndy += repulsive.y;\\\\nvec2 attractive = calcAttractive(currentNode);\\\\ndx += attractive.x;\\\\ndy += attractive.y;\\\\nvec2 gravity = calcGravity(currentNode);\\\\ndx -= gravity.x;\\\\ndy -= gravity.y;\\\\ndx *= gWebGPUUniformParams.u_Speed;\\\\ndy *= gWebGPUUniformParams.u_Speed;\\\\nfloat distLength = sqrt((dx * dx) + (dy * dy));\\\\nif (distLength > 0.0) {float limitedDist = min(gWebGPUUniformParams.u_MaxDisplace * gWebGPUUniformParams.u_Speed, distLength);\\\\ngWebGPUBuffer0.u_Data[i] = vec4(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w);}}\\\\n\",\"GLSL100\":\"\\\\n\\\\nfloat epsilon = 0.00001;\\\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\\\n  vec2 normAddr2D = float(address1D) * conv_const;\\\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\\\n}\\\\n\\\\nvoid barrier() {}\\\\n  \\\\n\\\\nuniform vec2 u_OutputTextureSize;\\\\nuniform int u_OutputTexelCount;\\\\nvarying vec2 v_TexCoord;\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\\\n\\\\nuniform sampler2D u_Data;\\\\nuniform vec2 u_DataSize;\\\\nvec4 getDatau_Data(vec2 address2D) {\\\\n  return vec4(texture2D(u_Data, address2D).rgba);\\\\n}\\\\nvec4 getDatau_Data(float address1D) {\\\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\\\n}\\\\nvec4 getDatau_Data(int address1D) {\\\\n  return getDatau_Data(float(address1D));\\\\n}\\\\nuniform float u_K;\\\\nuniform float u_K2;\\\\nuniform float u_Gravity;\\\\nuniform vec2 u_Center;\\\\nuniform float u_Speed;\\\\nuniform float u_MaxDisplace;\\\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\\\nfloat xDist = currentNode.x - nextNode.x;\\\\nfloat yDist = currentNode.y - nextNode.y;\\\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nif (dist > 0.0) {float repulsiveF = u_K2 / dist;\\\\ndx += (xDist / dist) * repulsiveF;\\\\ndy += (yDist / dist) * repulsiveF;}}}\\\\nreturn vec2(dx, dy);}\\\\nvec2 calcGravity(vec4 currentNode) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfloat vx = currentNode.x - u_Center.x;\\\\nfloat vy = currentNode.y - u_Center.y;\\\\nfloat gf = (0.01 * u_K) * u_Gravity;\\\\ndx = gf * vx;\\\\ndy = gf * vy;\\\\nreturn vec2(dx, dy);}\\\\nvec2 calcAttractive(vec4 currentNode) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nint arr_offset = int(floor(currentNode.z + 0.5));\\\\nint length = int(floor(currentNode.w + 0.5));\\\\nvec4 node_buffer;\\\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\\\nint arr_idx = arr_offset + int(p);\\\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\\\nfloat float_j = (buf_offset == 0) ? (node_buffer.x) : ((buf_offset == 1) ? (node_buffer.y) : ((buf_offset == 2) ? (node_buffer.z) : (node_buffer.w)));\\\\nvec4 nextNode = getDatau_Data(int(float_j));\\\\nfloat xDist = currentNode.x - nextNode.x;\\\\nfloat yDist = currentNode.y - nextNode.y;\\\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nfloat attractiveF = (dist * dist) / u_K;\\\\nif (dist > 0.0) {dx -= (xDist / dist) * attractiveF;\\\\ndy -= (yDist / dist) * attractiveF;}}\\\\nreturn vec2(dx, dy);}\\\\nvoid main() {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nint i = globalInvocationID.x;\\\\nvec4 currentNode = getDatau_Data(i);\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nif (i >= VERTEX_COUNT) {gl_FragColor = vec4(currentNode);\\\\nreturn ;}\\\\nvec2 repulsive = calcRepulsive(i, currentNode);\\\\ndx += repulsive.x;\\\\ndy += repulsive.y;\\\\nvec2 attractive = calcAttractive(currentNode);\\\\ndx += attractive.x;\\\\ndy += attractive.y;\\\\nvec2 gravity = calcGravity(currentNode);\\\\ndx -= gravity.x;\\\\ndy -= gravity.y;\\\\ndx *= u_Speed;\\\\ndy *= u_Speed;\\\\nfloat distLength = sqrt((dx * dx) + (dy * dy));\\\\nif (distLength > 0.0) {float limitedDist = min(u_MaxDisplace * u_Speed, distLength);\\\\ngl_FragColor = vec4(vec4(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w));}if (gWebGPUDebug) {\\\\n  gl_FragColor = gWebGPUDebugOutput;\\\\n}}\\\\n\"},\"context\":{\"name\":\"\",\"dispatch\":[1,1,1],\"threadGroupSize\":[1,1,1],\"maxIteration\":1,\"defines\":[{\"name\":\"MAX_EDGE_PER_VERTEX\",\"type\":\"Float\",\"runtime\":true},{\"name\":\"VERTEX_COUNT\",\"type\":\"Float\",\"runtime\":true}],\"uniforms\":[{\"name\":\"u_Data\",\"type\":\"vec4<f32>[]\",\"storageClass\":\"StorageBuffer\",\"readonly\":false,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_K\",\"type\":\"Float\",\"storageClass\":\"Uniform\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_K2\",\"type\":\"Float\",\"storageClass\":\"Uniform\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_Gravity\",\"type\":\"Float\",\"storageClass\":\"Uniform\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_Center\",\"type\":\"vec2<f32>\",\"storageClass\":\"Uniform\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_Speed\",\"type\":\"Float\",\"storageClass\":\"Uniform\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_MaxDisplace\",\"type\":\"Float\",\"storageClass\":\"Uniform\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]}],\"globalDeclarations\":[],\"output\":{\"name\":\"u_Data\",\"size\":[1,1],\"length\":1},\"needPingpong\":true}}`\n\n      // create world\n      const world = World.create({\n        engineOptions: {\n          supportCompute: true,\n        },\n      });\n\n      const timeStart = window.performance.now();\n\n      const area = CANVAS_HEIGHT * CANVAS_WIDTH;\n      let maxDisplace = Math.sqrt(area) / 10;\n      const k2 = area / (nodes.length + 1);\n      const k = Math.sqrt(k2);\n      const kernel = world\n        .createKernel(precompiledBundle)\n        .setDispatch([numParticles, 1, 1])\n        .setBinding({\n          u_Data: nodesEdgesArray,\n          u_K: k,\n          u_K2: k2,\n          u_Gravity: 10,\n          u_Speed: 0.1,\n          u_MaxDisplace: maxDisplace,\n          u_Center: center,\n          MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n          VERTEX_COUNT: numParticles,\n        });\n\n      for (let i = 0; i < MAX_ITERATION; i++) {\n        await kernel.execute();\n        kernel.setBinding({\n          u_MaxDisplace: maxDisplace *= 0.99,\n        });\n      }\n      // or use batch:\n      // await kernel.execute(MAX_ITERATION);\n\n      const finalParticleData = await kernel.getOutput();\n\n      setTimeElapsed(window.performance.now() - timeStart);\n      // draw with G\n      renderCircles(finalParticleData, numParticles);\n\n      window.gwebgpuClean = () => {\n        world.destroy();\n      };\n    })();\n  }, []);\n\n  return (\n    <>\n      <div>Elapsed time: {timeElapsed / 1000}s</div>\n      <div>\n        Ported from the same{' '}\n        <a href=\"https://g6.antv.vision/en/examples/net/furchtermanLayout#fruchtermanWebWorker\">\n          example\n        </a>{' '}\n        in G6\n      </div>\n      <div id=\"container\" />\n    </>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n\nfunction renderCircles(finalParticleData, numParticles) {\n  const canvas = new Canvas({\n    container: 'container',\n    center: [],\n    width: CANVAS_WIDTH,\n    height: CANVAS_HEIGHT,\n  });\n\n  // draw edges\n  for (let i = 0; i < lineIndexBufferData.length; i += 2) {\n    const x1 = finalParticleData[lineIndexBufferData[i] * 4];\n    const y1 = finalParticleData[lineIndexBufferData[i] * 4 + 1];\n    const x2 = finalParticleData[lineIndexBufferData[i + 1] * 4];\n    const y2 = finalParticleData[lineIndexBufferData[i + 1] * 4 + 1];\n    const group = canvas.addGroup();\n    group.addShape('line', {\n      attrs: {\n        x1,\n        y1,\n        x2,\n        y2,\n        stroke: '#1890FF',\n        lineWidth: 1,\n      },\n    });\n  }\n\n  // draw nodes\n  for (let i = 0; i < numParticles * 4; i += 4) {\n    const x = finalParticleData[i];\n    const y = finalParticleData[i + 1];\n    const group = canvas.addGroup();\n    group.addShape('circle', {\n      attrs: {\n        x,\n        y,\n        r: 5,\n        fill: 'red',\n        stroke: 'blue',\n        lineWidth: 2,\n      },\n    });\n  }\n}\n\nconst lineIndexBufferData = [];\nlet maxEdgePerVetex;\n// @see https://github.com/nblintao/ParaGraphL/blob/master/sigma.layout.paragraphl.js#L192-L229\nfunction buildTextureData(nodes, edges) {\n  const dataArray = [];\n  const nodeDict = [];\n  const mapIdPos = {};\n  let i = 0;\n  for (i = 0; i < nodes.length; i++) {\n    const n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n  for (i = 0; i < edges.length; i++) {\n    const e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    lineIndexBufferData.push(mapIdPos[e.source], mapIdPos[e.target]);\n  }\n\n  maxEdgePerVetex = 0;\n  for (i = 0; i < nodes.length; i++) {\n    const offset = dataArray.length;\n    const dests = nodeDict[i];\n    const len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = dests.length;\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n    for (let j = 0; j < len; ++j) {\n      const dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n  return new Float32Array(dataArray);\n}\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-canvas\", \"@antv/g-webgpu\", \"react\", \"react-dom\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-canvas\"), require(\"@antv/g-webgpu\"), require(\"react\"), require(\"react-dom\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gCanvas, global.gWebgpu, global.react, global.reactDom);\n    global.precompiled = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gCanvas, _gWebgpu, _react, _reactDom) {\n  \"use strict\";\n\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  var MAX_ITERATION = 1000;\n  var CANVAS_HEIGHT = 600;\n  var CANVAS_WIDTH = 600;\n\n  var App = /*#__PURE__*/_react.default.memo(function Fruchterman() {\n    var _useState = (0, _react.useState)(0),\n        _useState2 = _slicedToArray(_useState, 2),\n        timeElapsed = _useState2[0],\n        setTimeElapsed = _useState2[1];\n\n    (0, _react.useEffect)(function () {\n      (async function () {\n        // @see https://g6.antv.vision/en/examples/net/forceDirected/#basicForceDirected\n        var data = await (await fetch('https://gw.alipayobjects.com/os/basement_prod/7bacd7d1-4119-4ac1-8be3-4c4b9bcbc25f.json')).json();\n        var center = [CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2];\n        var nodes = data.nodes.map(function (n) {\n          return {\n            x: Math.random() * CANVAS_WIDTH,\n            y: Math.random() * CANVAS_HEIGHT,\n            id: n.id\n          };\n        });\n        var edges = data.edges;\n        var numParticles = nodes.length;\n        var nodesEdgesArray = buildTextureData(nodes, edges);\n        var precompiledBundle = \"{\\\"shaders\\\":{\\\"WGSL\\\":\\\"import \\\\\\\"GLSL.std.450\\\\\\\" as std;\\\\n\\\\n\\\\n# var gWebGPUDebug : bool = false;\\\\n# var gWebGPUDebugOutput : vec4<f32> = vec4<f32>(0.0);\\\\n\\\\n[[builtin global_invocation_id]] var<in> globalInvocationID : vec3<u32>;\\\\n# [[builtin work_group_size]] var<in> workGroupSize : vec3<u32>;\\\\n# [[builtin work_group_id]] var<in> workGroupID : vec3<u32>;\\\\n[[builtin local_invocation_id]] var<in> localInvocationID : vec3<u32>;\\\\n# [[builtin num_work_groups]] var<in> numWorkGroups : vec3<u32>;\\\\n[[builtin local_invocation_idx]] var<in> localInvocationIndex : u32;\\\\n\\\\ntype GWebGPUParams = [[block]] struct {\\\\n  [[offset 0]] u_K : f32;\\\\n  [[offset 4]] u_K2 : f32;\\\\n  [[offset 8]] u_Gravity : f32;\\\\n  [[offset 12]] u_Center : vec2<f32>;\\\\n  [[offset 20]] u_Speed : f32;\\\\n  [[offset 24]] u_MaxDisplace : f32;\\\\n};\\\\n[[binding 0, set 0]] var<uniform> gWebGPUUniformParams : GWebGPUParams;\\\\ntype GWebGPUBuffer0 = [[block]] struct {\\\\n  [[offset 0]] u_Data : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 1, set 0]] var<storage_buffer> gWebGPUBuffer0 : GWebGPUBuffer0;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nfn calcRepulsive(i : i32, currentNode : vec4<f32>) -> vec2<f32> {var dx : f32 = 0.0;\\\\nvar dy : f32 = 0.0;\\\\nfor (var j : i32 = 0; j < __DefineValuePlaceholder__VERTEX_COUNT; j = j + 1) {if (i != j) {var nextNode : vec4<f32> = gWebGPUBuffer0.u_Data[j];\\\\nvar xDist : f32 = currentNode.x - nextNode.x;\\\\nvar yDist : f32 = currentNode.y - nextNode.y;\\\\nvar dist : f32 = std::sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nif (dist > 0.0) {var repulsiveF : f32 = gWebGPUUniformParams.u_K2 / dist;\\\\ndx = dx + (xDist / dist) * repulsiveF;\\\\ndy = dy + (yDist / dist) * repulsiveF;}}}\\\\nreturn vec2<f32>(dx, dy);}\\\\nfn calcGravity(currentNode : vec4<f32>) -> vec2<f32> {var dx : f32 = 0.0;\\\\nvar dy : f32 = 0.0;\\\\nvar vx : f32 = currentNode.x - gWebGPUUniformParams.u_Center.x;\\\\nvar vy : f32 = currentNode.y - gWebGPUUniformParams.u_Center.y;\\\\nvar gf : f32 = (0.01 * gWebGPUUniformParams.u_K) * gWebGPUUniformParams.u_Gravity;\\\\ndx = gf * vx;\\\\ndy = gf * vy;\\\\nreturn vec2<f32>(dx, dy);}\\\\nfn calcAttractive(currentNode : vec4<f32>) -> vec2<f32> {var dx : f32 = 0.0;\\\\nvar dy : f32 = 0.0;\\\\nvar arr_offset : i32 = i32(std::floor(currentNode.z + 0.5));\\\\nvar length : i32 = i32(std::floor(currentNode.w + 0.5));\\\\nvar node_buffer : vec4<f32>;\\\\nfor (var p : i32 = 0; p < __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX; p = p + 1) {if (p >= length) {break;}\\\\nvar arr_idx : i32 = arr_offset + i32(p);\\\\nvar buf_offset : i32 = arr_idx - ((arr_idx / 4) * 4);\\\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = gWebGPUBuffer0.u_Data[i32(arr_idx / 4)];}\\\\nvar float_j : f32 = select(node_buffer.x, select(node_buffer.y, select(node_buffer.z, node_buffer.w, buf_offset == 2), buf_offset == 1), buf_offset == 0);\\\\nvar nextNode : vec4<f32> = gWebGPUBuffer0.u_Data[i32(float_j)];\\\\nvar xDist : f32 = currentNode.x - nextNode.x;\\\\nvar yDist : f32 = currentNode.y - nextNode.y;\\\\nvar dist : f32 = std::sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nvar attractiveF : f32 = (dist * dist) / gWebGPUUniformParams.u_K;\\\\nif (dist > 0.0) {dx = dx - (xDist / dist) * attractiveF;\\\\ndy = dy - (yDist / dist) * attractiveF;}}\\\\nreturn vec2<f32>(dx, dy);}\\\\nfn main() -> void {var i : i32 = globalInvocationID.x;\\\\nvar currentNode : vec4<f32> = gWebGPUBuffer0.u_Data[i];\\\\nvar dx : f32 = 0.0;\\\\nvar dy : f32 = 0.0;\\\\nif (i >= __DefineValuePlaceholder__VERTEX_COUNT) {gWebGPUBuffer0.u_Data[i] = currentNode;\\\\nreturn ;}\\\\nvar repulsive : vec2<f32> = calcRepulsive(i, currentNode);\\\\ndx = dx + repulsive.x;\\\\ndy = dy + repulsive.y;\\\\nvar attractive : vec2<f32> = calcAttractive(currentNode);\\\\ndx = dx + attractive.x;\\\\ndy = dy + attractive.y;\\\\nvar gravity : vec2<f32> = calcGravity(currentNode);\\\\ndx = dx - gravity.x;\\\\ndy = dy - gravity.y;\\\\ndx = dx * gWebGPUUniformParams.u_Speed;\\\\ndy = dy * gWebGPUUniformParams.u_Speed;\\\\nvar distLength : f32 = std::sqrt((dx * dx) + (dy * dy));\\\\nif (distLength > 0.0) {var limitedDist : f32 = std::min(gWebGPUUniformParams.u_MaxDisplace * gWebGPUUniformParams.u_Speed, distLength);\\\\ngWebGPUBuffer0.u_Data[i] = vec4<f32>(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w);}\\\\nreturn;}\\\\n\\\\nentry_point compute as \\\\\\\"main\\\\\\\" = main;\\\\n\\\",\\\"GLSL450\\\":\\\"\\\\n\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\\\nivec3 workGroupSize = ivec3(1,1,1);\\\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\\\n\\\\nlayout(std140, set = 0, binding = 0) uniform GWebGPUParams {\\\\n  float u_K;\\\\n  float u_K2;\\\\n  float u_Gravity;\\\\n  vec2 u_Center;\\\\n  float u_Speed;\\\\n  float u_MaxDisplace;\\\\n} gWebGPUUniformParams;\\\\nlayout(std430, set = 0, binding = 1) buffer   GWebGPUBuffer0 {\\\\n  vec4 u_Data[];\\\\n} gWebGPUBuffer0;\\\\n\\\\n\\\\n\\\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\\\nlayout (\\\\n  local_size_x = 1,\\\\n  local_size_y = 1,\\\\n  local_size_z = 1\\\\n) in;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nvec2 calcRepulsive(int i, vec4 currentNode) {float dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = gWebGPUBuffer0.u_Data[j];\\\\nfloat xDist = currentNode.x - nextNode.x;\\\\nfloat yDist = currentNode.y - nextNode.y;\\\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nif (dist > 0.0) {float repulsiveF = gWebGPUUniformParams.u_K2 / dist;\\\\ndx += (xDist / dist) * repulsiveF;\\\\ndy += (yDist / dist) * repulsiveF;}}}\\\\nreturn vec2(dx, dy);}\\\\nvec2 calcGravity(vec4 currentNode) {float dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfloat vx = currentNode.x - gWebGPUUniformParams.u_Center.x;\\\\nfloat vy = currentNode.y - gWebGPUUniformParams.u_Center.y;\\\\nfloat gf = (0.01 * gWebGPUUniformParams.u_K) * gWebGPUUniformParams.u_Gravity;\\\\ndx = gf * vx;\\\\ndy = gf * vy;\\\\nreturn vec2(dx, dy);}\\\\nvec2 calcAttractive(vec4 currentNode) {float dx = 0.0;\\\\nfloat dy = 0.0;\\\\nint arr_offset = int(floor(currentNode.z + 0.5));\\\\nint length = int(floor(currentNode.w + 0.5));\\\\nvec4 node_buffer;\\\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\\\nint arr_idx = arr_offset + int(p);\\\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = gWebGPUBuffer0.u_Data[int(arr_idx / 4)];}\\\\nfloat float_j = (buf_offset == 0) ? (node_buffer.x) : ((buf_offset == 1) ? (node_buffer.y) : ((buf_offset == 2) ? (node_buffer.z) : (node_buffer.w)));\\\\nvec4 nextNode = gWebGPUBuffer0.u_Data[int(float_j)];\\\\nfloat xDist = currentNode.x - nextNode.x;\\\\nfloat yDist = currentNode.y - nextNode.y;\\\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nfloat attractiveF = (dist * dist) / gWebGPUUniformParams.u_K;\\\\nif (dist > 0.0) {dx -= (xDist / dist) * attractiveF;\\\\ndy -= (yDist / dist) * attractiveF;}}\\\\nreturn vec2(dx, dy);}\\\\nvoid main() {int i = globalInvocationID.x;\\\\nvec4 currentNode = gWebGPUBuffer0.u_Data[i];\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nif (i >= VERTEX_COUNT) {gWebGPUBuffer0.u_Data[i] = currentNode;\\\\nreturn ;}\\\\nvec2 repulsive = calcRepulsive(i, currentNode);\\\\ndx += repulsive.x;\\\\ndy += repulsive.y;\\\\nvec2 attractive = calcAttractive(currentNode);\\\\ndx += attractive.x;\\\\ndy += attractive.y;\\\\nvec2 gravity = calcGravity(currentNode);\\\\ndx -= gravity.x;\\\\ndy -= gravity.y;\\\\ndx *= gWebGPUUniformParams.u_Speed;\\\\ndy *= gWebGPUUniformParams.u_Speed;\\\\nfloat distLength = sqrt((dx * dx) + (dy * dy));\\\\nif (distLength > 0.0) {float limitedDist = min(gWebGPUUniformParams.u_MaxDisplace * gWebGPUUniformParams.u_Speed, distLength);\\\\ngWebGPUBuffer0.u_Data[i] = vec4(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w);}}\\\\n\\\",\\\"GLSL100\\\":\\\"\\\\n\\\\nfloat epsilon = 0.00001;\\\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\\\n  vec2 normAddr2D = float(address1D) * conv_const;\\\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\\\n}\\\\n\\\\nvoid barrier() {}\\\\n  \\\\n\\\\nuniform vec2 u_OutputTextureSize;\\\\nuniform int u_OutputTexelCount;\\\\nvarying vec2 v_TexCoord;\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\\\n\\\\nuniform sampler2D u_Data;\\\\nuniform vec2 u_DataSize;\\\\nvec4 getDatau_Data(vec2 address2D) {\\\\n  return vec4(texture2D(u_Data, address2D).rgba);\\\\n}\\\\nvec4 getDatau_Data(float address1D) {\\\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\\\n}\\\\nvec4 getDatau_Data(int address1D) {\\\\n  return getDatau_Data(float(address1D));\\\\n}\\\\nuniform float u_K;\\\\nuniform float u_K2;\\\\nuniform float u_Gravity;\\\\nuniform vec2 u_Center;\\\\nuniform float u_Speed;\\\\nuniform float u_MaxDisplace;\\\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\\\nfloat xDist = currentNode.x - nextNode.x;\\\\nfloat yDist = currentNode.y - nextNode.y;\\\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nif (dist > 0.0) {float repulsiveF = u_K2 / dist;\\\\ndx += (xDist / dist) * repulsiveF;\\\\ndy += (yDist / dist) * repulsiveF;}}}\\\\nreturn vec2(dx, dy);}\\\\nvec2 calcGravity(vec4 currentNode) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfloat vx = currentNode.x - u_Center.x;\\\\nfloat vy = currentNode.y - u_Center.y;\\\\nfloat gf = (0.01 * u_K) * u_Gravity;\\\\ndx = gf * vx;\\\\ndy = gf * vy;\\\\nreturn vec2(dx, dy);}\\\\nvec2 calcAttractive(vec4 currentNode) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nint arr_offset = int(floor(currentNode.z + 0.5));\\\\nint length = int(floor(currentNode.w + 0.5));\\\\nvec4 node_buffer;\\\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\\\nint arr_idx = arr_offset + int(p);\\\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\\\nfloat float_j = (buf_offset == 0) ? (node_buffer.x) : ((buf_offset == 1) ? (node_buffer.y) : ((buf_offset == 2) ? (node_buffer.z) : (node_buffer.w)));\\\\nvec4 nextNode = getDatau_Data(int(float_j));\\\\nfloat xDist = currentNode.x - nextNode.x;\\\\nfloat yDist = currentNode.y - nextNode.y;\\\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nfloat attractiveF = (dist * dist) / u_K;\\\\nif (dist > 0.0) {dx -= (xDist / dist) * attractiveF;\\\\ndy -= (yDist / dist) * attractiveF;}}\\\\nreturn vec2(dx, dy);}\\\\nvoid main() {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nint i = globalInvocationID.x;\\\\nvec4 currentNode = getDatau_Data(i);\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nif (i >= VERTEX_COUNT) {gl_FragColor = vec4(currentNode);\\\\nreturn ;}\\\\nvec2 repulsive = calcRepulsive(i, currentNode);\\\\ndx += repulsive.x;\\\\ndy += repulsive.y;\\\\nvec2 attractive = calcAttractive(currentNode);\\\\ndx += attractive.x;\\\\ndy += attractive.y;\\\\nvec2 gravity = calcGravity(currentNode);\\\\ndx -= gravity.x;\\\\ndy -= gravity.y;\\\\ndx *= u_Speed;\\\\ndy *= u_Speed;\\\\nfloat distLength = sqrt((dx * dx) + (dy * dy));\\\\nif (distLength > 0.0) {float limitedDist = min(u_MaxDisplace * u_Speed, distLength);\\\\ngl_FragColor = vec4(vec4(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w));}if (gWebGPUDebug) {\\\\n  gl_FragColor = gWebGPUDebugOutput;\\\\n}}\\\\n\\\"},\\\"context\\\":{\\\"name\\\":\\\"\\\",\\\"dispatch\\\":[1,1,1],\\\"threadGroupSize\\\":[1,1,1],\\\"maxIteration\\\":1,\\\"defines\\\":[{\\\"name\\\":\\\"MAX_EDGE_PER_VERTEX\\\",\\\"type\\\":\\\"Float\\\",\\\"runtime\\\":true},{\\\"name\\\":\\\"VERTEX_COUNT\\\",\\\"type\\\":\\\"Float\\\",\\\"runtime\\\":true}],\\\"uniforms\\\":[{\\\"name\\\":\\\"u_Data\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":false,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_K\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_K2\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_Gravity\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_Center\\\",\\\"type\\\":\\\"vec2<f32>\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_Speed\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_MaxDisplace\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]}],\\\"globalDeclarations\\\":[],\\\"output\\\":{\\\"name\\\":\\\"u_Data\\\",\\\"size\\\":[1,1],\\\"length\\\":1},\\\"needPingpong\\\":true}}\"; // create world\n\n        var world = _gWebgpu.World.create({\n          engineOptions: {\n            supportCompute: true\n          }\n        });\n\n        var timeStart = window.performance.now();\n        var area = CANVAS_HEIGHT * CANVAS_WIDTH;\n        var maxDisplace = Math.sqrt(area) / 10;\n        var k2 = area / (nodes.length + 1);\n        var k = Math.sqrt(k2);\n        var kernel = world.createKernel(precompiledBundle).setDispatch([numParticles, 1, 1]).setBinding({\n          u_Data: nodesEdgesArray,\n          u_K: k,\n          u_K2: k2,\n          u_Gravity: 10,\n          u_Speed: 0.1,\n          u_MaxDisplace: maxDisplace,\n          u_Center: center,\n          MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n          VERTEX_COUNT: numParticles\n        });\n\n        for (var i = 0; i < MAX_ITERATION; i++) {\n          await kernel.execute();\n          kernel.setBinding({\n            u_MaxDisplace: maxDisplace *= 0.99\n          });\n        } // or use batch:\n        // await kernel.execute(MAX_ITERATION);\n\n\n        var finalParticleData = await kernel.getOutput();\n        setTimeElapsed(window.performance.now() - timeStart); // draw with G\n\n        renderCircles(finalParticleData, numParticles);\n\n        window.gwebgpuClean = function () {\n          world.destroy();\n        };\n      })();\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"div\", null, \"Elapsed time: \", timeElapsed / 1000, \"s\"), /*#__PURE__*/_react.default.createElement(\"div\", null, \"Ported from the same\", ' ', /*#__PURE__*/_react.default.createElement(\"a\", {\n      href: \"https://g6.antv.vision/en/examples/net/furchtermanLayout#fruchtermanWebWorker\"\n    }, \"example\"), ' ', \"in G6\"), /*#__PURE__*/_react.default.createElement(\"div\", {\n      id: \"container\"\n    }));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n\n  function renderCircles(finalParticleData, numParticles) {\n    var canvas = new _gCanvas.Canvas({\n      container: 'container',\n      center: [],\n      width: CANVAS_WIDTH,\n      height: CANVAS_HEIGHT\n    }); // draw edges\n\n    for (var i = 0; i < lineIndexBufferData.length; i += 2) {\n      var x1 = finalParticleData[lineIndexBufferData[i] * 4];\n      var y1 = finalParticleData[lineIndexBufferData[i] * 4 + 1];\n      var x2 = finalParticleData[lineIndexBufferData[i + 1] * 4];\n      var y2 = finalParticleData[lineIndexBufferData[i + 1] * 4 + 1];\n      var group = canvas.addGroup();\n      group.addShape('line', {\n        attrs: {\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2,\n          stroke: '#1890FF',\n          lineWidth: 1\n        }\n      });\n    } // draw nodes\n\n\n    for (var _i2 = 0; _i2 < numParticles * 4; _i2 += 4) {\n      var x = finalParticleData[_i2];\n      var y = finalParticleData[_i2 + 1];\n\n      var _group = canvas.addGroup();\n\n      _group.addShape('circle', {\n        attrs: {\n          x: x,\n          y: y,\n          r: 5,\n          fill: 'red',\n          stroke: 'blue',\n          lineWidth: 2\n        }\n      });\n    }\n  }\n\n  var lineIndexBufferData = [];\n  var maxEdgePerVetex; // @see https://github.com/nblintao/ParaGraphL/blob/master/sigma.layout.paragraphl.js#L192-L229\n\n  function buildTextureData(nodes, edges) {\n    var dataArray = [];\n    var nodeDict = [];\n    var mapIdPos = {};\n    var i = 0;\n\n    for (i = 0; i < nodes.length; i++) {\n      var n = nodes[i];\n      mapIdPos[n.id] = i;\n      dataArray.push(n.x);\n      dataArray.push(n.y);\n      dataArray.push(0);\n      dataArray.push(0);\n      nodeDict.push([]);\n    }\n\n    for (i = 0; i < edges.length; i++) {\n      var e = edges[i];\n      nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n      nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n      lineIndexBufferData.push(mapIdPos[e.source], mapIdPos[e.target]);\n    }\n\n    maxEdgePerVetex = 0;\n\n    for (i = 0; i < nodes.length; i++) {\n      var offset = dataArray.length;\n      var dests = nodeDict[i];\n      var len = dests.length;\n      dataArray[i * 4 + 2] = offset;\n      dataArray[i * 4 + 3] = dests.length;\n      maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n\n      for (var j = 0; j < len; ++j) {\n        var dest = dests[j];\n        dataArray.push(+dest);\n      }\n    }\n\n    while (dataArray.length % 4 !== 0) {\n      dataArray.push(0);\n    }\n\n    return new Float32Array(dataArray);\n  }\n});"},{"relativePath":"gpgpu/graph/fruchterman/demo/cluster.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/fruchterman/demo/cluster.tsx","order":2,"filename":"cluster.tsx","title":"Cluster","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","source":"import { Canvas } from '@antv/g-canvas';\nimport { World } from '@antv/g-webgpu';\nimport { Compiler } from '@antv/g-webgpu-compiler';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst gCode = `\nimport { globalInvocationID } from 'g-webgpu';\n\nconst MAX_EDGE_PER_VERTEX;\nconst VERTEX_COUNT;\n\n@numthreads(1, 1, 1)\nclass Fruchterman {\n  @in @out\n  u_Data: vec4[];\n\n  @in\n  u_K: float;\n\n  @in\n  u_K2: float;\n  \n  @in\n  u_Center: vec2;\n\n  @in\n  u_Gravity: float;\n\n  @in\n  u_ClusterGravity: float;\n\n  @in\n  u_Speed: float;\n\n  @in\n  u_MaxDisplace: float;\n\n  @in\n  u_Clustering: float;\n\n  @in\n  u_AttributeArray: vec4[];\n\n  @in\n  u_ClusterCenters: vec4[];\n\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      if (i != j) {\n        const nextNode = this.u_Data[j];\n        const xDist = currentNode[0] - nextNode[0];\n        const yDist = currentNode[1] - nextNode[1];\n        const dist = (xDist * xDist + yDist * yDist) + 0.01;\n\n        let param = this.u_K2 / dist;\n        \n        if (dist > 0.0) {\n          dx += param * xDist ;\n          dy += param * yDist ;\n        }\n      }\n    }\n    return [dx, dy];\n  }\n\n  calcGravity(currentNode: vec4, nodeAttributes: vec4): vec2 { // \n    let dx = 0, dy = 0;\n    const vx = currentNode[0] - this.u_Center[0];\n    const vy = currentNode[1] - this.u_Center[1];\n    const gf = 0.01 * this.u_K * this.u_Gravity;\n    dx = gf * vx;\n    dy = gf * vy;\n\n    if (this.u_Clustering == 1) {\n      const clusterIdx = int(nodeAttributes[0]);\n      const center = this.u_ClusterCenters[clusterIdx];\n      const cvx = currentNode[0] - center[0];\n      const cvy = currentNode[1] - center[1];\n      const dist = sqrt(cvx * cvx + cvy * cvy) + 0.001;\n      const parma = this.u_K * this.u_ClusterGravity / dist;\n      dx += parma * cvx;\n      dy += parma * cvy;\n    }\n\n    return [dx, dy];\n  }\n\n  calcAttractive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    const arr_offset = int(floor(currentNode[2] + 0.5));\n    const length = int(floor(currentNode[3] + 0.5));\n    const node_buffer: vec4;\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\n      if (p >= length) break;\n      const arr_idx = arr_offset + p;\n      // when arr_idx % 4 == 0 update currentNodedx_buffer\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\n      if (p == 0 || buf_offset == 0) {\n        node_buffer = this.u_Data[int(arr_idx / 4)];\n      }\n      const float_j = buf_offset == 0 ? node_buffer[0] :\n                      buf_offset == 1 ? node_buffer[1] :\n                      buf_offset == 2 ? node_buffer[2] :\n                                        node_buffer[3];\n      const nextNode = this.u_Data[int(float_j)];\n      const xDist = currentNode[0] - nextNode[0];\n      const yDist = currentNode[1] - nextNode[1];\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\n      let attractiveF = dist / this.u_K;\n    \n      if (dist > 0.0) {\n        dx -= xDist * attractiveF;\n        dy -= yDist * attractiveF;\n      }\n    }\n    return [dx, dy];\n  }\n\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const currentNode = this.u_Data[i];\n\n    let dx = 0, dy = 0;\n\n    if (i >= VERTEX_COUNT) {\n      this.u_Data[i] = currentNode;\n      return;\n    }\n\n    // repulsive\n    const repulsive = this.calcRepulsive(i, currentNode);\n    dx += repulsive[0];\n    dy += repulsive[1];\n\n    // attractive\n    const attractive = this.calcAttractive(i, currentNode);\n    dx += attractive[0];\n    dy += attractive[1];\n\n    // gravity\n    const nodeAttributes = this.u_AttributeArray[i];\n    const gravity = this.calcGravity(currentNode, nodeAttributes);\n    dx -= gravity[0];\n    dy -= gravity[1];\n\n    // speed\n    dx *= this.u_Speed;\n    dy *= this.u_Speed;\n\n    // move\n    const distLength = sqrt(dx * dx + dy * dy);\n    if (distLength > 0.0) {\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\n\n      this.u_Data[i] = [\n        currentNode[0] + dx / distLength * limitedDist,\n        currentNode[1] + dy / distLength * limitedDist,\n        currentNode[2],\n        currentNode[3]\n      ];\n    }\n  }\n}\n`;\n\nconst gCode2 = `\nimport { globalInvocationID } from 'g-webgpu';\n\nconst VERTEX_COUNT;\nconst CLUSTER_COUNT;\n\n@numthreads(1, 1, 1)\nclass CalcCenter {\n  @in\n  u_Data: vec4[];\n\n  @in\n  u_NodeAttributes: vec4[]; // [[clusterIdx, 0, 0, 0], ...]\n\n  @in @out\n  u_ClusterCenters: vec4[]; // [[cx, cy, nodeCount, clusterIdx], ...]\n\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const center = this.u_ClusterCenters[i];\n\n    let sumx = 0;\n    let sumy = 0;\n    let count = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      const attributes = this.u_NodeAttributes[j];\n      const clusterIdx = int(attributes[0]);\n      const vertex = this.u_Data[j];\n\n      if (clusterIdx == i) {\n        sumx += vertex.x;\n        sumy += vertex.y;\n        count += 1;\n      }\n    }\n\n    this.u_ClusterCenters[i] = [\n      sumx / count,\n      sumy / count,\n      count,\n      i\n    ];\n  }\n}\n`;\n\nconst MAX_ITERATION = 1000;\nconst CANVAS_HEIGHT = 600;\nconst CANVAS_WIDTH = 600;\nconst App = React.memo(function Fruchterman() {\n  const [timeElapsed, setTimeElapsed] = useState(0);\n  useEffect(() => {\n    (async () => {\n      // @see https://g6.antv.vision/en/examples/net/forceDirected/#basicForceDirected\n      const data = {\n        nodes: [\n          {\n            id: '0',\n            label: '0',\n            cluster: 'a',\n          },\n          {\n            id: '1',\n            label: '1',\n            cluster: 'a',\n          },\n          {\n            id: '2',\n            label: '2',\n            cluster: 'a',\n          },\n          {\n            id: '3',\n            label: '3',\n            cluster: 'a',\n          },\n          {\n            id: '4',\n            label: '4',\n            cluster: 'a',\n          },\n          {\n            id: '5',\n            label: '5',\n            cluster: 'a',\n          },\n          {\n            id: '6',\n            label: '6',\n            cluster: 'a',\n          },\n          {\n            id: '7',\n            label: '7',\n            cluster: 'a',\n          },\n          {\n            id: '8',\n            label: '8',\n            cluster: 'a',\n          },\n          {\n            id: '9',\n            label: '9',\n            cluster: 'a',\n          },\n          {\n            id: '10',\n            label: '10',\n            cluster: 'a',\n          },\n          {\n            id: '11',\n            label: '11',\n            cluster: 'a',\n          },\n          {\n            id: '12',\n            label: '12',\n            cluster: 'a',\n          },\n          {\n            id: '13',\n            label: '13',\n            cluster: 'b',\n          },\n          {\n            id: '14',\n            label: '14',\n            cluster: 'b',\n          },\n          {\n            id: '15',\n            label: '15',\n            cluster: 'b',\n          },\n          {\n            id: '16',\n            label: '16',\n            cluster: 'b',\n          },\n          {\n            id: '17',\n            label: '17',\n            cluster: 'b',\n          },\n          {\n            id: '18',\n            label: '18',\n            cluster: 'c',\n          },\n          {\n            id: '19',\n            label: '19',\n            cluster: 'c',\n          },\n          {\n            id: '20',\n            label: '20',\n            cluster: 'c',\n          },\n          {\n            id: '21',\n            label: '21',\n            cluster: 'c',\n          },\n          {\n            id: '22',\n            label: '22',\n            cluster: 'c',\n          },\n          {\n            id: '23',\n            label: '23',\n            cluster: 'c',\n          },\n          {\n            id: '24',\n            label: '24',\n            cluster: 'c',\n          },\n          {\n            id: '25',\n            label: '25',\n            cluster: 'c',\n          },\n          {\n            id: '26',\n            label: '26',\n            cluster: 'c',\n          },\n          {\n            id: '27',\n            label: '27',\n            cluster: 'c',\n          },\n          {\n            id: '28',\n            label: '28',\n            cluster: 'c',\n          },\n          {\n            id: '29',\n            label: '29',\n            cluster: 'c',\n          },\n          {\n            id: '30',\n            label: '30',\n            cluster: 'c',\n          },\n          {\n            id: '31',\n            label: '31',\n            cluster: 'd',\n          },\n          {\n            id: '32',\n            label: '32',\n            cluster: 'd',\n          },\n          {\n            id: '33',\n            label: '33',\n            cluster: 'd',\n          },\n        ],\n        edges: [\n          {\n            source: '0',\n            target: '1',\n          },\n          {\n            source: '0',\n            target: '2',\n          },\n          {\n            source: '0',\n            target: '3',\n          },\n          {\n            source: '0',\n            target: '4',\n          },\n          {\n            source: '0',\n            target: '5',\n          },\n          {\n            source: '0',\n            target: '7',\n          },\n          {\n            source: '0',\n            target: '8',\n          },\n          {\n            source: '0',\n            target: '9',\n          },\n          {\n            source: '0',\n            target: '10',\n          },\n          {\n            source: '0',\n            target: '11',\n          },\n          {\n            source: '0',\n            target: '13',\n          },\n          {\n            source: '0',\n            target: '14',\n          },\n          {\n            source: '0',\n            target: '15',\n          },\n          {\n            source: '0',\n            target: '16',\n          },\n          {\n            source: '2',\n            target: '3',\n          },\n          {\n            source: '4',\n            target: '5',\n          },\n          {\n            source: '4',\n            target: '6',\n          },\n          {\n            source: '5',\n            target: '6',\n          },\n          {\n            source: '7',\n            target: '13',\n          },\n          {\n            source: '8',\n            target: '14',\n          },\n          {\n            source: '9',\n            target: '10',\n          },\n          {\n            source: '10',\n            target: '22',\n          },\n          {\n            source: '10',\n            target: '14',\n          },\n          {\n            source: '10',\n            target: '12',\n          },\n          {\n            source: '10',\n            target: '24',\n          },\n          {\n            source: '10',\n            target: '21',\n          },\n          {\n            source: '10',\n            target: '20',\n          },\n          {\n            source: '11',\n            target: '24',\n          },\n          {\n            source: '11',\n            target: '22',\n          },\n          {\n            source: '11',\n            target: '14',\n          },\n          {\n            source: '12',\n            target: '13',\n          },\n          {\n            source: '16',\n            target: '17',\n          },\n          {\n            source: '16',\n            target: '18',\n          },\n          {\n            source: '16',\n            target: '21',\n          },\n          {\n            source: '16',\n            target: '22',\n          },\n          {\n            source: '17',\n            target: '18',\n          },\n          {\n            source: '17',\n            target: '20',\n          },\n          {\n            source: '18',\n            target: '19',\n          },\n          {\n            source: '19',\n            target: '20',\n          },\n          {\n            source: '19',\n            target: '33',\n          },\n          {\n            source: '19',\n            target: '22',\n          },\n          {\n            source: '19',\n            target: '23',\n          },\n          {\n            source: '20',\n            target: '21',\n          },\n          {\n            source: '21',\n            target: '22',\n          },\n          {\n            source: '22',\n            target: '24',\n          },\n          {\n            source: '22',\n            target: '25',\n          },\n          {\n            source: '22',\n            target: '26',\n          },\n          {\n            source: '22',\n            target: '23',\n          },\n          {\n            source: '22',\n            target: '28',\n          },\n          {\n            source: '22',\n            target: '30',\n          },\n          {\n            source: '22',\n            target: '31',\n          },\n          {\n            source: '22',\n            target: '32',\n          },\n          {\n            source: '22',\n            target: '33',\n          },\n          {\n            source: '23',\n            target: '28',\n          },\n          {\n            source: '23',\n            target: '27',\n          },\n          {\n            source: '23',\n            target: '29',\n          },\n          {\n            source: '23',\n            target: '30',\n          },\n          {\n            source: '23',\n            target: '31',\n          },\n          {\n            source: '23',\n            target: '33',\n          },\n          {\n            source: '32',\n            target: '33',\n          },\n        ],\n      };\n\n      const center = [CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2];\n      const nodes = data.nodes.map((n) => ({\n        x: Math.random() * CANVAS_WIDTH,\n        y: Math.random() * CANVAS_HEIGHT,\n        id: n.id,\n      }));\n      const edges = data.edges;\n      const numParticles = nodes.length;\n      const nodesEdgesArray = buildTextureData(nodes, edges);\n      const {\n        array: attributeArray,\n        count: clusterCount,\n      } = attributesToTextureData('cluster', data.nodes);\n\n      // compile our kernel code\n      const compiler = new Compiler();\n      const precompiledBundle = compiler.compileBundle(gCode);\n      const precompiledBundle2 = compiler.compileBundle(gCode2);\n\n      // create world\n      const world = World.create({\n        engineOptions: {\n          supportCompute: true,\n        },\n      });\n\n      const timeStart = window.performance.now();\n\n      const area = CANVAS_HEIGHT * CANVAS_WIDTH;\n      let maxDisplace = Math.sqrt(area) / 10;\n      const k2 = area / (nodes.length + 1);\n      const k = Math.sqrt(k2);\n\n      const clusterCenters = [];\n      for (let i = 0; i < clusterCount; i++) {\n        clusterCenters.push(0, 0, 0, 0);\n      }\n\n      const kernel = world\n        .createKernel(precompiledBundle)\n        .setDispatch([numParticles, 1, 1])\n        .setBinding({\n          u_Data: nodesEdgesArray,\n          u_K: k,\n          u_K2: k2,\n          u_Gravity: 10,\n          u_ClusterGravity: 10,\n          u_Speed: 0.1,\n          u_MaxDisplace: maxDisplace,\n          u_Clustering: 1,\n          u_Center: center,\n          u_AttributeArray: attributeArray,\n          u_ClusterCenters: clusterCenters,\n          MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n          VERTEX_COUNT: numParticles,\n        });\n\n      const kernel2 = world\n        .createKernel(precompiledBundle2)\n        .setDispatch([clusterCount, 1, 1])\n        .setBinding({\n          u_Data: nodesEdgesArray,\n          u_NodeAttributes: attributeArray,\n          u_ClusterCenters: clusterCenters,\n          VERTEX_COUNT: numParticles,\n          CLUSTER_COUNT: clusterCount,\n        });\n\n      for (let i = 0; i < MAX_ITERATION; i++) {\n        await kernel.execute();\n        kernel2.setBinding({\n          u_Data: kernel,\n        });\n        await kernel2.execute();\n        kernel.setBinding({\n          u_MaxDisplace: maxDisplace *= 0.99,\n          u_ClusterCenters: kernel2,\n        });\n      }\n\n      const finalParticleData = await kernel.getOutput();\n\n      setTimeElapsed(window.performance.now() - timeStart);\n      // draw with G\n      renderCircles(finalParticleData, numParticles);\n\n      window.gwebgpuClean = () => {\n        world.destroy();\n      };\n    })();\n  }, []);\n\n  return (\n    <>\n      <div>Elapsed time: {timeElapsed / 1000}s</div>\n      <div>4 clusters</div>\n      <div id=\"container\" />\n    </>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n\nfunction renderCircles(finalParticleData, numParticles) {\n  const canvas = new Canvas({\n    container: 'container',\n    center: [],\n    width: CANVAS_WIDTH,\n    height: CANVAS_HEIGHT,\n  });\n\n  // draw edges\n  for (let i = 0; i < lineIndexBufferData.length; i += 2) {\n    const x1 = finalParticleData[lineIndexBufferData[i] * 4];\n    const y1 = finalParticleData[lineIndexBufferData[i] * 4 + 1];\n    const x2 = finalParticleData[lineIndexBufferData[i + 1] * 4];\n    const y2 = finalParticleData[lineIndexBufferData[i + 1] * 4 + 1];\n    const group = canvas.addGroup();\n    group.addShape('line', {\n      attrs: {\n        x1,\n        y1,\n        x2,\n        y2,\n        stroke: '#1890FF',\n        lineWidth: 1,\n      },\n    });\n  }\n\n  // draw nodes\n  for (let i = 0; i < numParticles * 4; i += 4) {\n    const x = finalParticleData[i];\n    const y = finalParticleData[i + 1];\n    const group = canvas.addGroup();\n    group.addShape('circle', {\n      attrs: {\n        x,\n        y,\n        r: 5,\n        fill: 'red',\n        stroke: 'blue',\n        lineWidth: 2,\n      },\n    });\n  }\n}\n\nconst lineIndexBufferData = [];\nlet maxEdgePerVetex;\n// @see https://github.com/nblintao/ParaGraphL/blob/master/sigma.layout.paragraphl.js#L192-L229\nfunction buildTextureData(nodes, edges) {\n  const dataArray = [];\n  const nodeDict = [];\n  const mapIdPos = {};\n  let i = 0;\n  for (i = 0; i < nodes.length; i++) {\n    const n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n  for (i = 0; i < edges.length; i++) {\n    const e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    lineIndexBufferData.push(mapIdPos[e.source], mapIdPos[e.target]);\n  }\n\n  maxEdgePerVetex = 0;\n  for (i = 0; i < nodes.length; i++) {\n    const offset = dataArray.length;\n    const dests = nodeDict[i];\n    const len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = dests.length;\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n    for (let j = 0; j < len; ++j) {\n      const dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n  return new Float32Array(dataArray);\n}\n\nfunction attributesToTextureData(clusterKey: string, nodes) {\n  const dataArray = [];\n  const clusterNames = [];\n  nodes.forEach((node) => {\n    const clusterName = node[clusterKey];\n    let index = clusterNames.indexOf(clusterName);\n    if (index === -1) {\n      clusterNames.push(clusterName);\n      index = clusterNames.length - 1;\n    }\n    dataArray.push(index, 0, 0, 0);\n  });\n\n  return {\n    array: new Float32Array(dataArray),\n    count: clusterNames.length,\n  };\n}\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-canvas\", \"@antv/g-webgpu\", \"@antv/g-webgpu-compiler\", \"react\", \"react-dom\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-canvas\"), require(\"@antv/g-webgpu\"), require(\"@antv/g-webgpu-compiler\"), require(\"react\"), require(\"react-dom\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gCanvas, global.gWebgpu, global.gWebgpuCompiler, global.react, global.reactDom);\n    global.cluster = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gCanvas, _gWebgpu, _gWebgpuCompiler, _react, _reactDom) {\n  \"use strict\";\n\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  var gCode = \"\\nimport { globalInvocationID } from 'g-webgpu';\\n\\nconst MAX_EDGE_PER_VERTEX;\\nconst VERTEX_COUNT;\\n\\n@numthreads(1, 1, 1)\\nclass Fruchterman {\\n  @in @out\\n  u_Data: vec4[];\\n\\n  @in\\n  u_K: float;\\n\\n  @in\\n  u_K2: float;\\n  \\n  @in\\n  u_Center: vec2;\\n\\n  @in\\n  u_Gravity: float;\\n\\n  @in\\n  u_ClusterGravity: float;\\n\\n  @in\\n  u_Speed: float;\\n\\n  @in\\n  u_MaxDisplace: float;\\n\\n  @in\\n  u_Clustering: float;\\n\\n  @in\\n  u_AttributeArray: vec4[];\\n\\n  @in\\n  u_ClusterCenters: vec4[];\\n\\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\\n    let dx = 0, dy = 0;\\n    for (let j = 0; j < VERTEX_COUNT; j++) {\\n      if (i != j) {\\n        const nextNode = this.u_Data[j];\\n        const xDist = currentNode[0] - nextNode[0];\\n        const yDist = currentNode[1] - nextNode[1];\\n        const dist = (xDist * xDist + yDist * yDist) + 0.01;\\n\\n        let param = this.u_K2 / dist;\\n        \\n        if (dist > 0.0) {\\n          dx += param * xDist ;\\n          dy += param * yDist ;\\n        }\\n      }\\n    }\\n    return [dx, dy];\\n  }\\n\\n  calcGravity(currentNode: vec4, nodeAttributes: vec4): vec2 { // \\n    let dx = 0, dy = 0;\\n    const vx = currentNode[0] - this.u_Center[0];\\n    const vy = currentNode[1] - this.u_Center[1];\\n    const gf = 0.01 * this.u_K * this.u_Gravity;\\n    dx = gf * vx;\\n    dy = gf * vy;\\n\\n    if (this.u_Clustering == 1) {\\n      const clusterIdx = int(nodeAttributes[0]);\\n      const center = this.u_ClusterCenters[clusterIdx];\\n      const cvx = currentNode[0] - center[0];\\n      const cvy = currentNode[1] - center[1];\\n      const dist = sqrt(cvx * cvx + cvy * cvy) + 0.001;\\n      const parma = this.u_K * this.u_ClusterGravity / dist;\\n      dx += parma * cvx;\\n      dy += parma * cvy;\\n    }\\n\\n    return [dx, dy];\\n  }\\n\\n  calcAttractive(i: int, currentNode: vec4): vec2 {\\n    let dx = 0, dy = 0;\\n    const arr_offset = int(floor(currentNode[2] + 0.5));\\n    const length = int(floor(currentNode[3] + 0.5));\\n    const node_buffer: vec4;\\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\\n      if (p >= length) break;\\n      const arr_idx = arr_offset + p;\\n      // when arr_idx % 4 == 0 update currentNodedx_buffer\\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\\n      if (p == 0 || buf_offset == 0) {\\n        node_buffer = this.u_Data[int(arr_idx / 4)];\\n      }\\n      const float_j = buf_offset == 0 ? node_buffer[0] :\\n                      buf_offset == 1 ? node_buffer[1] :\\n                      buf_offset == 2 ? node_buffer[2] :\\n                                        node_buffer[3];\\n      const nextNode = this.u_Data[int(float_j)];\\n      const xDist = currentNode[0] - nextNode[0];\\n      const yDist = currentNode[1] - nextNode[1];\\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\\n      let attractiveF = dist / this.u_K;\\n    \\n      if (dist > 0.0) {\\n        dx -= xDist * attractiveF;\\n        dy -= yDist * attractiveF;\\n      }\\n    }\\n    return [dx, dy];\\n  }\\n\\n  @main\\n  compute() {\\n    const i = globalInvocationID.x;\\n    const currentNode = this.u_Data[i];\\n\\n    let dx = 0, dy = 0;\\n\\n    if (i >= VERTEX_COUNT) {\\n      this.u_Data[i] = currentNode;\\n      return;\\n    }\\n\\n    // repulsive\\n    const repulsive = this.calcRepulsive(i, currentNode);\\n    dx += repulsive[0];\\n    dy += repulsive[1];\\n\\n    // attractive\\n    const attractive = this.calcAttractive(i, currentNode);\\n    dx += attractive[0];\\n    dy += attractive[1];\\n\\n    // gravity\\n    const nodeAttributes = this.u_AttributeArray[i];\\n    const gravity = this.calcGravity(currentNode, nodeAttributes);\\n    dx -= gravity[0];\\n    dy -= gravity[1];\\n\\n    // speed\\n    dx *= this.u_Speed;\\n    dy *= this.u_Speed;\\n\\n    // move\\n    const distLength = sqrt(dx * dx + dy * dy);\\n    if (distLength > 0.0) {\\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\\n\\n      this.u_Data[i] = [\\n        currentNode[0] + dx / distLength * limitedDist,\\n        currentNode[1] + dy / distLength * limitedDist,\\n        currentNode[2],\\n        currentNode[3]\\n      ];\\n    }\\n  }\\n}\\n\";\n  var gCode2 = \"\\nimport { globalInvocationID } from 'g-webgpu';\\n\\nconst VERTEX_COUNT;\\nconst CLUSTER_COUNT;\\n\\n@numthreads(1, 1, 1)\\nclass CalcCenter {\\n  @in\\n  u_Data: vec4[];\\n\\n  @in\\n  u_NodeAttributes: vec4[]; // [[clusterIdx, 0, 0, 0], ...]\\n\\n  @in @out\\n  u_ClusterCenters: vec4[]; // [[cx, cy, nodeCount, clusterIdx], ...]\\n\\n  @main\\n  compute() {\\n    const i = globalInvocationID.x;\\n    const center = this.u_ClusterCenters[i];\\n\\n    let sumx = 0;\\n    let sumy = 0;\\n    let count = 0;\\n    for (let j = 0; j < VERTEX_COUNT; j++) {\\n      const attributes = this.u_NodeAttributes[j];\\n      const clusterIdx = int(attributes[0]);\\n      const vertex = this.u_Data[j];\\n\\n      if (clusterIdx == i) {\\n        sumx += vertex.x;\\n        sumy += vertex.y;\\n        count += 1;\\n      }\\n    }\\n\\n    this.u_ClusterCenters[i] = [\\n      sumx / count,\\n      sumy / count,\\n      count,\\n      i\\n    ];\\n  }\\n}\\n\";\n  var MAX_ITERATION = 1000;\n  var CANVAS_HEIGHT = 600;\n  var CANVAS_WIDTH = 600;\n\n  var App = /*#__PURE__*/_react.default.memo(function Fruchterman() {\n    var _useState = (0, _react.useState)(0),\n        _useState2 = _slicedToArray(_useState, 2),\n        timeElapsed = _useState2[0],\n        setTimeElapsed = _useState2[1];\n\n    (0, _react.useEffect)(function () {\n      (async function () {\n        // @see https://g6.antv.vision/en/examples/net/forceDirected/#basicForceDirected\n        var data = {\n          nodes: [{\n            id: '0',\n            label: '0',\n            cluster: 'a'\n          }, {\n            id: '1',\n            label: '1',\n            cluster: 'a'\n          }, {\n            id: '2',\n            label: '2',\n            cluster: 'a'\n          }, {\n            id: '3',\n            label: '3',\n            cluster: 'a'\n          }, {\n            id: '4',\n            label: '4',\n            cluster: 'a'\n          }, {\n            id: '5',\n            label: '5',\n            cluster: 'a'\n          }, {\n            id: '6',\n            label: '6',\n            cluster: 'a'\n          }, {\n            id: '7',\n            label: '7',\n            cluster: 'a'\n          }, {\n            id: '8',\n            label: '8',\n            cluster: 'a'\n          }, {\n            id: '9',\n            label: '9',\n            cluster: 'a'\n          }, {\n            id: '10',\n            label: '10',\n            cluster: 'a'\n          }, {\n            id: '11',\n            label: '11',\n            cluster: 'a'\n          }, {\n            id: '12',\n            label: '12',\n            cluster: 'a'\n          }, {\n            id: '13',\n            label: '13',\n            cluster: 'b'\n          }, {\n            id: '14',\n            label: '14',\n            cluster: 'b'\n          }, {\n            id: '15',\n            label: '15',\n            cluster: 'b'\n          }, {\n            id: '16',\n            label: '16',\n            cluster: 'b'\n          }, {\n            id: '17',\n            label: '17',\n            cluster: 'b'\n          }, {\n            id: '18',\n            label: '18',\n            cluster: 'c'\n          }, {\n            id: '19',\n            label: '19',\n            cluster: 'c'\n          }, {\n            id: '20',\n            label: '20',\n            cluster: 'c'\n          }, {\n            id: '21',\n            label: '21',\n            cluster: 'c'\n          }, {\n            id: '22',\n            label: '22',\n            cluster: 'c'\n          }, {\n            id: '23',\n            label: '23',\n            cluster: 'c'\n          }, {\n            id: '24',\n            label: '24',\n            cluster: 'c'\n          }, {\n            id: '25',\n            label: '25',\n            cluster: 'c'\n          }, {\n            id: '26',\n            label: '26',\n            cluster: 'c'\n          }, {\n            id: '27',\n            label: '27',\n            cluster: 'c'\n          }, {\n            id: '28',\n            label: '28',\n            cluster: 'c'\n          }, {\n            id: '29',\n            label: '29',\n            cluster: 'c'\n          }, {\n            id: '30',\n            label: '30',\n            cluster: 'c'\n          }, {\n            id: '31',\n            label: '31',\n            cluster: 'd'\n          }, {\n            id: '32',\n            label: '32',\n            cluster: 'd'\n          }, {\n            id: '33',\n            label: '33',\n            cluster: 'd'\n          }],\n          edges: [{\n            source: '0',\n            target: '1'\n          }, {\n            source: '0',\n            target: '2'\n          }, {\n            source: '0',\n            target: '3'\n          }, {\n            source: '0',\n            target: '4'\n          }, {\n            source: '0',\n            target: '5'\n          }, {\n            source: '0',\n            target: '7'\n          }, {\n            source: '0',\n            target: '8'\n          }, {\n            source: '0',\n            target: '9'\n          }, {\n            source: '0',\n            target: '10'\n          }, {\n            source: '0',\n            target: '11'\n          }, {\n            source: '0',\n            target: '13'\n          }, {\n            source: '0',\n            target: '14'\n          }, {\n            source: '0',\n            target: '15'\n          }, {\n            source: '0',\n            target: '16'\n          }, {\n            source: '2',\n            target: '3'\n          }, {\n            source: '4',\n            target: '5'\n          }, {\n            source: '4',\n            target: '6'\n          }, {\n            source: '5',\n            target: '6'\n          }, {\n            source: '7',\n            target: '13'\n          }, {\n            source: '8',\n            target: '14'\n          }, {\n            source: '9',\n            target: '10'\n          }, {\n            source: '10',\n            target: '22'\n          }, {\n            source: '10',\n            target: '14'\n          }, {\n            source: '10',\n            target: '12'\n          }, {\n            source: '10',\n            target: '24'\n          }, {\n            source: '10',\n            target: '21'\n          }, {\n            source: '10',\n            target: '20'\n          }, {\n            source: '11',\n            target: '24'\n          }, {\n            source: '11',\n            target: '22'\n          }, {\n            source: '11',\n            target: '14'\n          }, {\n            source: '12',\n            target: '13'\n          }, {\n            source: '16',\n            target: '17'\n          }, {\n            source: '16',\n            target: '18'\n          }, {\n            source: '16',\n            target: '21'\n          }, {\n            source: '16',\n            target: '22'\n          }, {\n            source: '17',\n            target: '18'\n          }, {\n            source: '17',\n            target: '20'\n          }, {\n            source: '18',\n            target: '19'\n          }, {\n            source: '19',\n            target: '20'\n          }, {\n            source: '19',\n            target: '33'\n          }, {\n            source: '19',\n            target: '22'\n          }, {\n            source: '19',\n            target: '23'\n          }, {\n            source: '20',\n            target: '21'\n          }, {\n            source: '21',\n            target: '22'\n          }, {\n            source: '22',\n            target: '24'\n          }, {\n            source: '22',\n            target: '25'\n          }, {\n            source: '22',\n            target: '26'\n          }, {\n            source: '22',\n            target: '23'\n          }, {\n            source: '22',\n            target: '28'\n          }, {\n            source: '22',\n            target: '30'\n          }, {\n            source: '22',\n            target: '31'\n          }, {\n            source: '22',\n            target: '32'\n          }, {\n            source: '22',\n            target: '33'\n          }, {\n            source: '23',\n            target: '28'\n          }, {\n            source: '23',\n            target: '27'\n          }, {\n            source: '23',\n            target: '29'\n          }, {\n            source: '23',\n            target: '30'\n          }, {\n            source: '23',\n            target: '31'\n          }, {\n            source: '23',\n            target: '33'\n          }, {\n            source: '32',\n            target: '33'\n          }]\n        };\n        var center = [CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2];\n        var nodes = data.nodes.map(function (n) {\n          return {\n            x: Math.random() * CANVAS_WIDTH,\n            y: Math.random() * CANVAS_HEIGHT,\n            id: n.id\n          };\n        });\n        var edges = data.edges;\n        var numParticles = nodes.length;\n        var nodesEdgesArray = buildTextureData(nodes, edges);\n\n        var _attributesToTextureD = attributesToTextureData('cluster', data.nodes),\n            attributeArray = _attributesToTextureD.array,\n            clusterCount = _attributesToTextureD.count; // compile our kernel code\n\n\n        var compiler = new _gWebgpuCompiler.Compiler();\n        var precompiledBundle = compiler.compileBundle(gCode);\n        var precompiledBundle2 = compiler.compileBundle(gCode2); // create world\n\n        var world = _gWebgpu.World.create({\n          engineOptions: {\n            supportCompute: true\n          }\n        });\n\n        var timeStart = window.performance.now();\n        var area = CANVAS_HEIGHT * CANVAS_WIDTH;\n        var maxDisplace = Math.sqrt(area) / 10;\n        var k2 = area / (nodes.length + 1);\n        var k = Math.sqrt(k2);\n        var clusterCenters = [];\n\n        for (var i = 0; i < clusterCount; i++) {\n          clusterCenters.push(0, 0, 0, 0);\n        }\n\n        var kernel = world.createKernel(precompiledBundle).setDispatch([numParticles, 1, 1]).setBinding({\n          u_Data: nodesEdgesArray,\n          u_K: k,\n          u_K2: k2,\n          u_Gravity: 10,\n          u_ClusterGravity: 10,\n          u_Speed: 0.1,\n          u_MaxDisplace: maxDisplace,\n          u_Clustering: 1,\n          u_Center: center,\n          u_AttributeArray: attributeArray,\n          u_ClusterCenters: clusterCenters,\n          MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n          VERTEX_COUNT: numParticles\n        });\n        var kernel2 = world.createKernel(precompiledBundle2).setDispatch([clusterCount, 1, 1]).setBinding({\n          u_Data: nodesEdgesArray,\n          u_NodeAttributes: attributeArray,\n          u_ClusterCenters: clusterCenters,\n          VERTEX_COUNT: numParticles,\n          CLUSTER_COUNT: clusterCount\n        });\n\n        for (var _i2 = 0; _i2 < MAX_ITERATION; _i2++) {\n          await kernel.execute();\n          kernel2.setBinding({\n            u_Data: kernel\n          });\n          await kernel2.execute();\n          kernel.setBinding({\n            u_MaxDisplace: maxDisplace *= 0.99,\n            u_ClusterCenters: kernel2\n          });\n        }\n\n        var finalParticleData = await kernel.getOutput();\n        setTimeElapsed(window.performance.now() - timeStart); // draw with G\n\n        renderCircles(finalParticleData, numParticles);\n\n        window.gwebgpuClean = function () {\n          world.destroy();\n        };\n      })();\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"div\", null, \"Elapsed time: \", timeElapsed / 1000, \"s\"), /*#__PURE__*/_react.default.createElement(\"div\", null, \"4 clusters\"), /*#__PURE__*/_react.default.createElement(\"div\", {\n      id: \"container\"\n    }));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n\n  function renderCircles(finalParticleData, numParticles) {\n    var canvas = new _gCanvas.Canvas({\n      container: 'container',\n      center: [],\n      width: CANVAS_WIDTH,\n      height: CANVAS_HEIGHT\n    }); // draw edges\n\n    for (var i = 0; i < lineIndexBufferData.length; i += 2) {\n      var x1 = finalParticleData[lineIndexBufferData[i] * 4];\n      var y1 = finalParticleData[lineIndexBufferData[i] * 4 + 1];\n      var x2 = finalParticleData[lineIndexBufferData[i + 1] * 4];\n      var y2 = finalParticleData[lineIndexBufferData[i + 1] * 4 + 1];\n      var group = canvas.addGroup();\n      group.addShape('line', {\n        attrs: {\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2,\n          stroke: '#1890FF',\n          lineWidth: 1\n        }\n      });\n    } // draw nodes\n\n\n    for (var _i3 = 0; _i3 < numParticles * 4; _i3 += 4) {\n      var x = finalParticleData[_i3];\n      var y = finalParticleData[_i3 + 1];\n\n      var _group = canvas.addGroup();\n\n      _group.addShape('circle', {\n        attrs: {\n          x: x,\n          y: y,\n          r: 5,\n          fill: 'red',\n          stroke: 'blue',\n          lineWidth: 2\n        }\n      });\n    }\n  }\n\n  var lineIndexBufferData = [];\n  var maxEdgePerVetex; // @see https://github.com/nblintao/ParaGraphL/blob/master/sigma.layout.paragraphl.js#L192-L229\n\n  function buildTextureData(nodes, edges) {\n    var dataArray = [];\n    var nodeDict = [];\n    var mapIdPos = {};\n    var i = 0;\n\n    for (i = 0; i < nodes.length; i++) {\n      var n = nodes[i];\n      mapIdPos[n.id] = i;\n      dataArray.push(n.x);\n      dataArray.push(n.y);\n      dataArray.push(0);\n      dataArray.push(0);\n      nodeDict.push([]);\n    }\n\n    for (i = 0; i < edges.length; i++) {\n      var e = edges[i];\n      nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n      nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n      lineIndexBufferData.push(mapIdPos[e.source], mapIdPos[e.target]);\n    }\n\n    maxEdgePerVetex = 0;\n\n    for (i = 0; i < nodes.length; i++) {\n      var offset = dataArray.length;\n      var dests = nodeDict[i];\n      var len = dests.length;\n      dataArray[i * 4 + 2] = offset;\n      dataArray[i * 4 + 3] = dests.length;\n      maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n\n      for (var j = 0; j < len; ++j) {\n        var dest = dests[j];\n        dataArray.push(+dest);\n      }\n    }\n\n    while (dataArray.length % 4 !== 0) {\n      dataArray.push(0);\n    }\n\n    return new Float32Array(dataArray);\n  }\n\n  function attributesToTextureData(clusterKey, nodes) {\n    var dataArray = [];\n    var clusterNames = [];\n    nodes.forEach(function (node) {\n      var clusterName = node[clusterKey];\n      var index = clusterNames.indexOf(clusterName);\n\n      if (index === -1) {\n        clusterNames.push(clusterName);\n        index = clusterNames.length - 1;\n      }\n\n      dataArray.push(index, 0, 0, 0);\n    });\n    return {\n      array: new Float32Array(dataArray),\n      count: clusterNames.length\n    };\n  }\n});"}]},"description":""}},"staticQueryHashes":["1015175297","3000541721","3000541721","3378097331","638047554"]}