{"componentChunkName":"component---node-modules-antv-gatsby-theme-antv-site-templates-example-tsx","path":"/zh/examples/gpgpu/basic/add2vectors","result":{"data":{"site":{"siteMetadata":{"title":"GWebGPU","examples":[{"slug":"gpgpu/basic","icon":"gallery","title":{"zh":"基础算法","en":"Basic Algorithms"}},{"slug":"gpgpu/graph","icon":"gallery","title":{"zh":"图算法","en":"Graph"}},{"slug":"rendering","icon":"gallery","title":{"zh":"渲染","en":"Rendering"}}],"playground":{"container":"<div style=\"justify-content: center;position: relative\" id=\"wrapper\"/>","playgroundDidMount":"(function(history){\n        var pushState = history.pushState;\n        history.pushState = function(state) {\n          window.gwebgpuClean && window.gwebgpuClean();\n          return pushState.apply(history, arguments);\n        };\n      })(window.history);","playgroundWillUnmount":"window.gwebgpuClean && window.gwebgpuClean();","dependencies":{"@antv/g-webgpu":"latest"},"htmlCodeTemplate":null}},"pathPrefix":""},"allMarkdownRemark":{"edges":[{"node":{"fields":{"slug":"/zh/examples/gallery"},"frontmatter":{"title":"所有图表","order":-1,"icon":"other"},"parent":{"__typename":"File","relativePath":"gallery/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/gallery"},"frontmatter":{"title":"Gallery","order":-1,"icon":"other"},"parent":{"__typename":"File","relativePath":"gallery/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/interaction"},"frontmatter":{"title":"交互","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/interaction/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/interaction"},"frontmatter":{"title":"Interaction","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/interaction/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/gpgpu/basic/add2vectors"},"frontmatter":{"title":"两个向量相加","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/add2vectors/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/gpgpu/basic/add2vectors"},"frontmatter":{"title":"Add 2 vectors","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/add2vectors/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/camera"},"frontmatter":{"title":"相机","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/camera/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/camera"},"frontmatter":{"title":"Camera","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/camera/index.en.md"}}},{"node":{"fields":{"slug":"/en/examples/gpgpu/graph/fruchterman"},"frontmatter":{"title":"Fruchterman Layout","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/graph/fruchterman/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/gpgpu/graph/fruchterman"},"frontmatter":{"title":"Fruchterman 布局算法","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/graph/fruchterman/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/gpgpu/basic/mergeSort"},"frontmatter":{"title":"Merge Sort","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/mergeSort/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/gpgpu/basic/mergeSort"},"frontmatter":{"title":"归并排序","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/mergeSort/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/gpgpu/basic/bitonicSort"},"frontmatter":{"title":"Bitonic Sort (WebGPU Only)","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/bitonicSort/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/gpgpu/basic/bitonicSort"},"frontmatter":{"title":"奇偶排序 (WebGPU Only)","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/bitonicSort/index.zh.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/renderables"},"frontmatter":{"title":"Renderable","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/renderables/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/lighting"},"frontmatter":{"title":"Lighting","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/lighting/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/lighting"},"frontmatter":{"title":"光照","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/lighting/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/gpgpu/graph/sssp"},"frontmatter":{"title":"SSSP(Single source shortest path) (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/graph/sssp/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/gpgpu/graph/sssp"},"frontmatter":{"title":"单源最短路径算法 (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/graph/sssp/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/gpgpu/basic/reduce"},"frontmatter":{"title":"Reduce (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/reduce/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/gpgpu/basic/reduce"},"frontmatter":{"title":"Reduce (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/reduce/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/scenegraph"},"frontmatter":{"title":"SceneGraph","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/scenegraph/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/scenegraph"},"frontmatter":{"title":"场景图","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/scenegraph/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/renderables"},"frontmatter":{"title":"Post Processing","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/renderables/index.en.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/material"},"frontmatter":{"title":"Material","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/material/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/material"},"frontmatter":{"title":"材质","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/material/index.zh.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/geometry"},"frontmatter":{"title":"几何体","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/geometry/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/geometry"},"frontmatter":{"title":"Geometry","order":3,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/geometry/index.en.md"}}},{"node":{"fields":{"slug":"/en/examples/rendering/postprocessing"},"frontmatter":{"title":"后处理","order":5,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/postprocessing/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/rendering/postprocessing"},"frontmatter":{"title":"后处理","order":5,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/postprocessing/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/experiment/unitchart"},"frontmatter":{"title":"Unitchart","order":6,"icon":null},"parent":{"__typename":"File","relativePath":"experiment/unitchart/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/experiment/unitchart"},"frontmatter":{"title":"Unitchart","order":6,"icon":null},"parent":{"__typename":"File","relativePath":"experiment/unitchart/index.zh.md"}}},{"node":{"fields":{"slug":"/en/examples/experiment/raytracer"},"frontmatter":{"title":"RayTracer","order":7,"icon":null},"parent":{"__typename":"File","relativePath":"experiment/raytracer/index.en.md"}}},{"node":{"fields":{"slug":"/zh/examples/experiment/raytracer"},"frontmatter":{"title":"RayTracer","order":7,"icon":null},"parent":{"__typename":"File","relativePath":"experiment/raytracer/index.zh.md"}}}]}},"pageContext":{"allDemos":[{"relativePath":"rendering/scenegraph/demo/cubes.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/scenegraph/demo/cubes.tsx","order":1,"filename":"cubes.tsx","title":"Attach cubes to a rotating group","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*OEcdTJOyRQMAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"en":{"title":"SceneGraph","order":303},"zh":{"title":"场景图","order":303}}},{"relativePath":"rendering/scenegraph/demo/solar-system.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/scenegraph/demo/solar-system.tsx","order":0,"filename":"solar-system.tsx","title":"Solar system","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*0d6WQa-BbUQAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"en":{"title":"SceneGraph","order":303},"zh":{"title":"场景图","order":303}}},{"relativePath":"rendering/renderables/demo/cube.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/renderables/demo/cube.tsx","order":3,"filename":"cube.tsx","title":"A Rotating Cube","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"Renderable","order":302},"en":{"title":"Post Processing","order":303}}},{"relativePath":"rendering/renderables/demo/grid.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/renderables/demo/grid.tsx","order":2,"filename":"grid.tsx","title":"Grid","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*dYVxQoW7gmIAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"Renderable","order":302},"en":{"title":"Post Processing","order":303}}},{"relativePath":"rendering/renderables/demo/line.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/renderables/demo/line.tsx","order":1,"filename":"line.tsx","title":"2D Line","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"Renderable","order":302},"en":{"title":"Post Processing","order":303}}},{"relativePath":"rendering/renderables/demo/point.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/renderables/demo/point.tsx","order":0,"filename":"point.tsx","title":"2D Point","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*UOGoTILse-0AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"Renderable","order":302},"en":{"title":"Post Processing","order":303}}},{"relativePath":"rendering/material/demo/basic.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/material/demo/basic.tsx","order":0,"filename":"basic.tsx","title":"Basic Material","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*dV0gTafuRHsAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"en":{"title":"Material","order":303},"zh":{"title":"材质","order":303}}},{"relativePath":"rendering/interaction/demo/multi-canvas.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/interaction/demo/multi-canvas.tsx","order":2,"filename":"multi-canvas.tsx","hidden":true,"title":"Multi canvas contexts(Not recommended)","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"交互","order":300},"en":{"title":"Interaction","order":300}}},{"relativePath":"rendering/interaction/demo/multi-view.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/interaction/demo/multi-view.tsx","order":1,"filename":"multi-view.tsx","title":"Multi views(Recommended)","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*ytT4SoKan_0AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"交互","order":300},"en":{"title":"Interaction","order":300}}},{"relativePath":"rendering/interaction/demo/pixel-picker.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/interaction/demo/pixel-picker.tsx","order":4,"filename":"pixel-picker.tsx","title":"PixelPicker","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"交互","order":300},"en":{"title":"Interaction","order":300}}},{"relativePath":"rendering/interaction/demo/ray-picker.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/interaction/demo/ray-picker.tsx","order":3,"filename":"ray-picker.tsx","title":"RayPicker","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"交互","order":300},"en":{"title":"Interaction","order":300}}},{"relativePath":"rendering/interaction/demo/responsive.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/interaction/demo/responsive.tsx","order":0,"filename":"responsive.tsx","title":"Use a responsive viewport","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*ByguS56BAO0AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"交互","order":300},"en":{"title":"Interaction","order":300}}},{"relativePath":"rendering/geometry/demo/box.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/geometry/demo/box.tsx","order":0,"filename":"box.tsx","title":"Box","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*dV0gTafuRHsAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"几何体","order":303},"en":{"title":"Geometry","order":303}}},{"relativePath":"rendering/geometry/demo/merged.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/geometry/demo/merged.tsx","order":3,"filename":"merged.tsx","title":"Merged geometry","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*_fOKRJ18IcUAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"几何体","order":303},"en":{"title":"Geometry","order":303}}},{"relativePath":"rendering/geometry/demo/plane.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/geometry/demo/plane.tsx","order":2,"filename":"plane.tsx","title":"Plane","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*6zGmSbSJHgcAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"几何体","order":303},"en":{"title":"Geometry","order":303}}},{"relativePath":"rendering/geometry/demo/world.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/geometry/demo/world.tsx","order":4,"filename":"world.tsx","title":"World","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*jQpbRrS6en0AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"几何体","order":303},"en":{"title":"Geometry","order":303}}},{"relativePath":"rendering/geometry/demo/sphere.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/geometry/demo/sphere.tsx","order":1,"filename":"sphere.tsx","title":"Sphere","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*jQpbRrS6en0AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"几何体","order":303},"en":{"title":"Geometry","order":303}}},{"relativePath":"rendering/camera/demo/landmark.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/camera/demo/landmark.tsx","order":0,"filename":"landmark.tsx","title":"Switch to landmarks of a camera","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*nIKoSa3zNBMAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"相机","order":301},"en":{"title":"Camera","order":301}}},{"relativePath":"rendering/camera/demo/perspective.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/camera/demo/perspective.tsx","order":2,"filename":"perspective.tsx","title":"Camera with perspective projection","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*5aAORoqcdI0AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"相机","order":301},"en":{"title":"Camera","order":301}}},{"relativePath":"rendering/camera/demo/tracking.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/camera/demo/tracking.tsx","order":3,"filename":"tracking.tsx","title":"Tracking","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*RApkT63FesAAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"相机","order":301},"en":{"title":"Camera","order":301}}},{"relativePath":"rendering/camera/demo/ortho.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/rendering/camera/demo/ortho.tsx","order":1,"filename":"ortho.tsx","title":"Camera with orthographic projection","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*QQghSadPJnkAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"zh":{"title":"相机","order":301},"en":{"title":"Camera","order":301}}},{"relativePath":"gpgpu/graph/sssp/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/sssp/demo/index.tsx","order":0,"filename":"index.tsx","title":"Bellman-Ford","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*U_ynS4APYr8AAAAAAAAAAAAAARQnAQ","postFrontmatter":{"en":{"title":"SSSP(Single source shortest path) (WebGPU Only)","order":2},"zh":{"title":"单源最短路径算法 (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/graph/sssp/demo/perf.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/sssp/demo/perf.tsx","order":1,"filename":"perf.tsx","title":"Bellman-Ford in a large directed graph","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"SSSP(Single source shortest path) (WebGPU Only)","order":2},"zh":{"title":"单源最短路径算法 (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/graph/fruchterman/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/fruchterman/demo/index.tsx","order":0,"filename":"index.tsx","title":"Fruchterman 布局算法","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Fruchterman Layout","order":1},"zh":{"title":"Fruchterman 布局算法","order":1}}},{"relativePath":"gpgpu/graph/fruchterman/demo/precompiled.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/fruchterman/demo/precompiled.tsx","order":1,"filename":"precompiled.tsx","title":"Fruchterman 布局算法(预编译)","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Fruchterman Layout","order":1},"zh":{"title":"Fruchterman 布局算法","order":1}}},{"relativePath":"gpgpu/graph/fruchterman/demo/cluster.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/graph/fruchterman/demo/cluster.tsx","order":2,"filename":"cluster.tsx","title":"Cluster","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Fruchterman Layout","order":1},"zh":{"title":"Fruchterman 布局算法","order":1}}},{"relativePath":"gpgpu/basic/reduce/demo/reduce1.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/reduce/demo/reduce1.tsx","order":0,"filename":"reduce1.tsx","title":"Reduce 基础版本","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Reduce (WebGPU Only)","order":2},"zh":{"title":"Reduce (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/basic/reduce/demo/reduce2.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/reduce/demo/reduce2.tsx","order":1,"filename":"reduce2.tsx","title":"Reduce 改进 2.0","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Reduce (WebGPU Only)","order":2},"zh":{"title":"Reduce (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/basic/reduce/demo/reduce3.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/reduce/demo/reduce3.tsx","order":2,"filename":"reduce3.tsx","title":"Reduce 改进 3.0","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Reduce (WebGPU Only)","order":2},"zh":{"title":"Reduce (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/basic/reduce/demo/reduce4.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/reduce/demo/reduce4.tsx","order":3,"filename":"reduce4.tsx","title":"Reduce 改进 4.0","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Reduce (WebGPU Only)","order":2},"zh":{"title":"Reduce (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/basic/reduce/demo/reduce5.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/reduce/demo/reduce5.tsx","order":4,"filename":"reduce5.tsx","title":"Reduce 改进 5.0","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Reduce (WebGPU Only)","order":2},"zh":{"title":"Reduce (WebGPU Only)","order":2}}},{"relativePath":"gpgpu/basic/mergeSort/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/mergeSort/demo/index.tsx","order":0,"filename":"index.tsx","title":"归并排序","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Merge Sort","order":1},"zh":{"title":"归并排序","order":1}}},{"relativePath":"gpgpu/basic/bitonicSort/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/bitonicSort/demo/index.tsx","order":0,"filename":"index.tsx","title":"奇偶排序","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Bitonic Sort (WebGPU Only)","order":1},"zh":{"title":"奇偶排序 (WebGPU Only)","order":1}}},{"relativePath":"gpgpu/basic/add2vectors/demo/add2vectors-precompiled.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/add2vectors/demo/add2vectors-precompiled.tsx","order":-1,"filename":"add2vectors-precompiled.tsx","postFrontmatter":{"zh":{"title":"两个向量相加","order":0},"en":{"title":"Add 2 vectors","order":0}}},{"relativePath":"gpgpu/basic/add2vectors/demo/add2vectors.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/add2vectors/demo/add2vectors.tsx","order":-1,"filename":"add2vectors.tsx","postFrontmatter":{"zh":{"title":"两个向量相加","order":0},"en":{"title":"Add 2 vectors","order":0}}},{"relativePath":"gpgpu/basic/add2vectors/demo/iteration.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/add2vectors/demo/iteration.tsx","order":2,"filename":"iteration.tsx","title":"迭代多次，串联自身","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"两个向量相加","order":0},"en":{"title":"Add 2 vectors","order":0}}},{"relativePath":"gpgpu/basic/add2vectors/demo/pipeline.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/add2vectors/demo/pipeline.tsx","order":3,"filename":"pipeline.tsx","title":"串联多个 Kernel","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"zh":{"title":"两个向量相加","order":0},"en":{"title":"Add 2 vectors","order":0}}},{"relativePath":"experiment/unitchart/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/experiment/unitchart/demo/index.tsx","order":0,"filename":"index.tsx","title":"Unitchart","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","postFrontmatter":{"en":{"title":"Unitchart","order":6},"zh":{"title":"Unitchart","order":6}}},{"relativePath":"experiment/raytracer/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/experiment/raytracer/demo/index.tsx","order":0,"filename":"index.tsx","title":"RayTracer","screenshot":"https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*FARSSo38alcAAAAAAAAAAAAAARQnAQ","postFrontmatter":{"en":{"title":"RayTracer","order":7},"zh":{"title":"RayTracer","order":7}}}],"exampleSections":{"examples":[{"relativePath":"gpgpu/basic/add2vectors/demo/add2vectors-precompiled.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/add2vectors/demo/add2vectors-precompiled.tsx","order":-1,"filename":"add2vectors-precompiled.tsx","source":"import { World } from '@antv/g-webgpu';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst App = React.memo(function Add2Vectors() {\n  const [result, setResult] = useState([]);\n  useEffect(() => {\n    const world = World.create({\n      engineOptions: {\n        supportCompute: true,\n      },\n    });\n    const precompiledBundle =\n      '{\"shaders\":{\"WGSL\":\"import \\\\\"GLSL.std.450\\\\\" as std;\\\\n\\\\n\\\\n\\\\n\\\\n# var gWebGPUDebug : bool = false;\\\\n# var gWebGPUDebugOutput : vec4<f32> = vec4<f32>(0.0);\\\\n\\\\n[[builtin global_invocation_id]] var<in> globalInvocationID : vec3<u32>;\\\\n# [[builtin work_group_size]] var<in> workGroupSize : vec3<u32>;\\\\n# [[builtin work_group_id]] var<in> workGroupID : vec3<u32>;\\\\n# [[builtin local_invocation_id]] var<in> localInvocationID : vec3<u32>;\\\\n# [[builtin num_work_groups]] var<in> numWorkGroups : vec3<u32>;\\\\n# [[builtin local_invocation_index]] var<in> localInvocationIndex : u32;\\\\n\\\\n\\\\ntype GWebGPUBuffer0 = [[block]] struct {\\\\n  [[offset 0]] vectorA : [[stride 4]] array<f32>;\\\\n};\\\\n[[binding 0, set 0]] var<storage_buffer> gWebGPUBuffer0 : GWebGPUBuffer0;\\\\ntype GWebGPUBuffer1 = [[block]] struct {\\\\n  [[offset 0]] vectorB : [[stride 4]] array<f32>;\\\\n};\\\\n[[binding 1, set 0]] var<storage_buffer> gWebGPUBuffer1 : GWebGPUBuffer1;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nfn sum(a : f32, b : f32) -> f32 {return a + b;}\\\\nfn main() -> void {var a : f32 = gWebGPUBuffer0.vectorA[globalInvocationID.x];\\\\nvar b : f32 = gWebGPUBuffer1.vectorB[globalInvocationID.x];\\\\ngWebGPUBuffer0.vectorA[globalInvocationID.x] = sum(a, b);\\\\nreturn;}\\\\n\\\\nentry_point compute as \\\\\"main\\\\\" = main;\\\\n\",\"GLSL450\":\"\\\\n\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\\\nivec3 workGroupSize = ivec3(gl_WorkGroupSize);\\\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\\\n\\\\n\\\\nlayout(std430, set = 0, binding = 0) buffer   GWebGPUBuffer0 {\\\\n  float vectorA[];\\\\n} gWebGPUBuffer0;\\\\n\\\\nlayout(std430, set = 0, binding = 1) buffer readonly  GWebGPUBuffer1 {\\\\n  float vectorB[];\\\\n} gWebGPUBuffer1;\\\\n\\\\n\\\\n\\\\nlayout (\\\\n  local_size_x = 8,\\\\n  local_size_y = 1,\\\\n  local_size_z = 1\\\\n) in;\\\\n\\\\n\\\\nfloat sum(float a, float b) {return a + b;}\\\\nvoid main() {float a = gWebGPUBuffer0.vectorA[globalInvocationID.x];\\\\nfloat b = gWebGPUBuffer1.vectorB[globalInvocationID.x];\\\\ngWebGPUBuffer0.vectorA[globalInvocationID.x] = sum(a, b);}\\\\n\",\"GLSL100\":\"#ifdef GL_FRAGMENT_PRECISION_HIGH\\\\n  precision highp float;\\\\n#else\\\\n  precision mediump float;\\\\n#endif\\\\n\\\\n\\\\nfloat epsilon = 0.00001;\\\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\\\n  vec2 normAddr2D = float(address1D) * conv_const;\\\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\\\n}\\\\n\\\\nvoid barrier() {}\\\\n  \\\\n\\\\nuniform vec2 u_OutputTextureSize;\\\\nuniform int u_OutputTexelCount;\\\\nvarying vec2 v_TexCoord;\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\n\\\\nuniform sampler2D vectorA;\\\\nuniform vec2 vectorASize;\\\\nfloat getDatavectorA(vec2 address2D) {\\\\n  return float(texture2D(vectorA, address2D).r);\\\\n}\\\\nfloat getDatavectorA(float address1D) {\\\\n  return getDatavectorA(addrTranslation_1Dto2D(address1D, vectorASize));\\\\n}\\\\nfloat getDatavectorA(int address1D) {\\\\n  return getDatavectorA(float(address1D));\\\\n}\\\\nuniform sampler2D vectorB;\\\\nuniform vec2 vectorBSize;\\\\nfloat getDatavectorB(vec2 address2D) {\\\\n  return float(texture2D(vectorB, address2D).r);\\\\n}\\\\nfloat getDatavectorB(float address1D) {\\\\n  return getDatavectorB(addrTranslation_1Dto2D(address1D, vectorBSize));\\\\n}\\\\nfloat getDatavectorB(int address1D) {\\\\n  return getDatavectorB(float(address1D));\\\\n}\\\\nfloat sum(float a, float b) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nreturn a + b;}\\\\nvoid main() {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat a = getDatavectorA(globalInvocationID.x);\\\\nfloat b = getDatavectorB(globalInvocationID.x);\\\\ngl_FragColor = vec4(sum(a, b));if (gWebGPUDebug) {\\\\n  gl_FragColor = gWebGPUDebugOutput;\\\\n}}\\\\n\"},\"context\":{\"name\":\"\",\"dispatch\":[1,1,1],\"threadGroupSize\":[1,1,1],\"maxIteration\":1,\"defines\":[],\"uniforms\":[{\"name\":\"vectorA\",\"type\":\"Float[]\",\"storageClass\":\"StorageBuffer\",\"readonly\":false,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"vectorB\",\"type\":\"Float[]\",\"storageClass\":\"StorageBuffer\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]}],\"globalDeclarations\":[],\"output\":{\"name\":\"vectorA\",\"size\":[1,1],\"length\":1},\"needPingpong\":true}}';\n    const executeKernel = async () => {\n      const kernel = world.createKernel(precompiledBundle);\n      await kernel\n        .setDispatch([1, 1, 1])\n        .setBinding('vectorA', [1, 2, 3, 4, 5, 6, 7, 8])\n        .setBinding('vectorB', [1, 2, 3, 4, 5, 6, 7, 8])\n        .execute();\n\n      setResult(await kernel.getOutput());\n    };\n    executeKernel();\n\n    window.gwebgpuClean = () => {\n      world.destroy();\n    };\n  }, []);\n\n  return (\n    <>\n      <h2> Add 2 Vectors (with precompiled bundle)</h2>\n      <ul>\n        <li>WorkGroup: 1</li>\n        <li>Threads per WorkGroup: 8</li>\n        <li>VectorA: 1, 2, 3, 4, 5, 6, 7, 8</li>\n        <li>VectorB: 1, 2, 3, 4, 5, 6, 7, 8</li>\n        <li>Result: {result.toString()}</li>\n      </ul>\n    </>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-webgpu\", \"react\", \"react-dom\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-webgpu\"), require(\"react\"), require(\"react-dom\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gWebgpu, global.react, global.reactDom);\n    global.add2vectorsPrecompiled = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gWebgpu, _react, _reactDom) {\n  \"use strict\";\n\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  var App = /*#__PURE__*/_react.default.memo(function Add2Vectors() {\n    var _useState = (0, _react.useState)([]),\n        _useState2 = _slicedToArray(_useState, 2),\n        result = _useState2[0],\n        setResult = _useState2[1];\n\n    (0, _react.useEffect)(function () {\n      var world = _gWebgpu.World.create({\n        engineOptions: {\n          supportCompute: true\n        }\n      });\n\n      var precompiledBundle = '{\"shaders\":{\"WGSL\":\"import \\\\\"GLSL.std.450\\\\\" as std;\\\\n\\\\n\\\\n\\\\n\\\\n# var gWebGPUDebug : bool = false;\\\\n# var gWebGPUDebugOutput : vec4<f32> = vec4<f32>(0.0);\\\\n\\\\n[[builtin global_invocation_id]] var<in> globalInvocationID : vec3<u32>;\\\\n# [[builtin work_group_size]] var<in> workGroupSize : vec3<u32>;\\\\n# [[builtin work_group_id]] var<in> workGroupID : vec3<u32>;\\\\n# [[builtin local_invocation_id]] var<in> localInvocationID : vec3<u32>;\\\\n# [[builtin num_work_groups]] var<in> numWorkGroups : vec3<u32>;\\\\n# [[builtin local_invocation_index]] var<in> localInvocationIndex : u32;\\\\n\\\\n\\\\ntype GWebGPUBuffer0 = [[block]] struct {\\\\n  [[offset 0]] vectorA : [[stride 4]] array<f32>;\\\\n};\\\\n[[binding 0, set 0]] var<storage_buffer> gWebGPUBuffer0 : GWebGPUBuffer0;\\\\ntype GWebGPUBuffer1 = [[block]] struct {\\\\n  [[offset 0]] vectorB : [[stride 4]] array<f32>;\\\\n};\\\\n[[binding 1, set 0]] var<storage_buffer> gWebGPUBuffer1 : GWebGPUBuffer1;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nfn sum(a : f32, b : f32) -> f32 {return a + b;}\\\\nfn main() -> void {var a : f32 = gWebGPUBuffer0.vectorA[globalInvocationID.x];\\\\nvar b : f32 = gWebGPUBuffer1.vectorB[globalInvocationID.x];\\\\ngWebGPUBuffer0.vectorA[globalInvocationID.x] = sum(a, b);\\\\nreturn;}\\\\n\\\\nentry_point compute as \\\\\"main\\\\\" = main;\\\\n\",\"GLSL450\":\"\\\\n\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\\\nivec3 workGroupSize = ivec3(gl_WorkGroupSize);\\\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\\\n\\\\n\\\\nlayout(std430, set = 0, binding = 0) buffer   GWebGPUBuffer0 {\\\\n  float vectorA[];\\\\n} gWebGPUBuffer0;\\\\n\\\\nlayout(std430, set = 0, binding = 1) buffer readonly  GWebGPUBuffer1 {\\\\n  float vectorB[];\\\\n} gWebGPUBuffer1;\\\\n\\\\n\\\\n\\\\nlayout (\\\\n  local_size_x = 8,\\\\n  local_size_y = 1,\\\\n  local_size_z = 1\\\\n) in;\\\\n\\\\n\\\\nfloat sum(float a, float b) {return a + b;}\\\\nvoid main() {float a = gWebGPUBuffer0.vectorA[globalInvocationID.x];\\\\nfloat b = gWebGPUBuffer1.vectorB[globalInvocationID.x];\\\\ngWebGPUBuffer0.vectorA[globalInvocationID.x] = sum(a, b);}\\\\n\",\"GLSL100\":\"#ifdef GL_FRAGMENT_PRECISION_HIGH\\\\n  precision highp float;\\\\n#else\\\\n  precision mediump float;\\\\n#endif\\\\n\\\\n\\\\nfloat epsilon = 0.00001;\\\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\\\n  vec2 normAddr2D = float(address1D) * conv_const;\\\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\\\n}\\\\n\\\\nvoid barrier() {}\\\\n  \\\\n\\\\nuniform vec2 u_OutputTextureSize;\\\\nuniform int u_OutputTexelCount;\\\\nvarying vec2 v_TexCoord;\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\n\\\\nuniform sampler2D vectorA;\\\\nuniform vec2 vectorASize;\\\\nfloat getDatavectorA(vec2 address2D) {\\\\n  return float(texture2D(vectorA, address2D).r);\\\\n}\\\\nfloat getDatavectorA(float address1D) {\\\\n  return getDatavectorA(addrTranslation_1Dto2D(address1D, vectorASize));\\\\n}\\\\nfloat getDatavectorA(int address1D) {\\\\n  return getDatavectorA(float(address1D));\\\\n}\\\\nuniform sampler2D vectorB;\\\\nuniform vec2 vectorBSize;\\\\nfloat getDatavectorB(vec2 address2D) {\\\\n  return float(texture2D(vectorB, address2D).r);\\\\n}\\\\nfloat getDatavectorB(float address1D) {\\\\n  return getDatavectorB(addrTranslation_1Dto2D(address1D, vectorBSize));\\\\n}\\\\nfloat getDatavectorB(int address1D) {\\\\n  return getDatavectorB(float(address1D));\\\\n}\\\\nfloat sum(float a, float b) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nreturn a + b;}\\\\nvoid main() {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat a = getDatavectorA(globalInvocationID.x);\\\\nfloat b = getDatavectorB(globalInvocationID.x);\\\\ngl_FragColor = vec4(sum(a, b));if (gWebGPUDebug) {\\\\n  gl_FragColor = gWebGPUDebugOutput;\\\\n}}\\\\n\"},\"context\":{\"name\":\"\",\"dispatch\":[1,1,1],\"threadGroupSize\":[1,1,1],\"maxIteration\":1,\"defines\":[],\"uniforms\":[{\"name\":\"vectorA\",\"type\":\"Float[]\",\"storageClass\":\"StorageBuffer\",\"readonly\":false,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"vectorB\",\"type\":\"Float[]\",\"storageClass\":\"StorageBuffer\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]}],\"globalDeclarations\":[],\"output\":{\"name\":\"vectorA\",\"size\":[1,1],\"length\":1},\"needPingpong\":true}}';\n\n      var executeKernel = async function executeKernel() {\n        var kernel = world.createKernel(precompiledBundle);\n        await kernel.setDispatch([1, 1, 1]).setBinding('vectorA', [1, 2, 3, 4, 5, 6, 7, 8]).setBinding('vectorB', [1, 2, 3, 4, 5, 6, 7, 8]).execute();\n        setResult(await kernel.getOutput());\n      };\n\n      executeKernel();\n\n      window.gwebgpuClean = function () {\n        world.destroy();\n      };\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"h2\", null, \" Add 2 Vectors (with precompiled bundle)\"), /*#__PURE__*/_react.default.createElement(\"ul\", null, /*#__PURE__*/_react.default.createElement(\"li\", null, \"WorkGroup: 1\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"Threads per WorkGroup: 8\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"VectorA: 1, 2, 3, 4, 5, 6, 7, 8\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"VectorB: 1, 2, 3, 4, 5, 6, 7, 8\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"Result: \", result.toString())));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n});"},{"relativePath":"gpgpu/basic/add2vectors/demo/add2vectors.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/add2vectors/demo/add2vectors.tsx","order":-1,"filename":"add2vectors.tsx","source":"import { World } from '@antv/g-webgpu';\nimport { Compiler } from '@antv/g-webgpu-compiler';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst gCode = `\nimport { globalInvocationID } from 'g-webgpu';\n\n@numthreads(8, 1, 1)\nclass Add2Vectors {\n  @in @out\n  vectorA: float[];\n\n  @in\n  vectorB: float[];\n\n  sum(a: float, b: float): float {\n    return a + b;\n  }\n\n  @main\n  compute() {\n    // 获取当前线程处理的数据\n    const a = this.vectorA[globalInvocationID.x];\n    const b = this.vectorB[globalInvocationID.x];\n  \n    // 输出当前线程处理完毕的数据，即两个向量相加后的结果\n    this.vectorA[globalInvocationID.x] = this.sum(a, b);\n  }\n}\n`;\n\nconst App = React.memo(function Add2Vectors() {\n  const [result, setResult] = useState([]);\n  useEffect(() => {\n    // compile our kernel code\n    const compiler = new Compiler();\n    const precompiledBundle = compiler.compileBundle(gCode);\n\n    // console.log(precompiledBundle.toString());\n\n    // create world\n    const world = World.create({\n      engineOptions: {\n        supportCompute: true,\n      },\n    });\n\n    const executeKernel = async () => {\n      const kernel = world\n        .createKernel(precompiledBundle)\n        .setDispatch([1, 1, 1])\n        .setBinding('vectorA', [1, 2, 3, 4, 5, 6, 7, 8])\n        .setBinding('vectorB', [1, 2, 3, 4, 5, 6, 7, 8]);\n      await kernel.execute();\n\n      setResult(await kernel.getOutput());\n    };\n    executeKernel();\n\n    window.gwebgpuClean = () => {\n      world.destroy();\n    };\n  }, []);\n\n  return (\n    <>\n      <h2> Add 2 Vectors</h2>\n      <ul>\n        <li>WorkGroup: 1</li>\n        <li>Threads per WorkGroup: 8</li>\n        <li>VectorA: 1, 2, 3, 4, 5, 6, 7, 8</li>\n        <li>VectorB: 1, 2, 3, 4, 5, 6, 7, 8</li>\n        <li>Result: {result.toString()}</li>\n      </ul>\n    </>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-webgpu\", \"@antv/g-webgpu-compiler\", \"react\", \"react-dom\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-webgpu\"), require(\"@antv/g-webgpu-compiler\"), require(\"react\"), require(\"react-dom\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gWebgpu, global.gWebgpuCompiler, global.react, global.reactDom);\n    global.add2vectors = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gWebgpu, _gWebgpuCompiler, _react, _reactDom) {\n  \"use strict\";\n\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  var gCode = \"\\nimport { globalInvocationID } from 'g-webgpu';\\n\\n@numthreads(8, 1, 1)\\nclass Add2Vectors {\\n  @in @out\\n  vectorA: float[];\\n\\n  @in\\n  vectorB: float[];\\n\\n  sum(a: float, b: float): float {\\n    return a + b;\\n  }\\n\\n  @main\\n  compute() {\\n    // \\u83B7\\u53D6\\u5F53\\u524D\\u7EBF\\u7A0B\\u5904\\u7406\\u7684\\u6570\\u636E\\n    const a = this.vectorA[globalInvocationID.x];\\n    const b = this.vectorB[globalInvocationID.x];\\n  \\n    // \\u8F93\\u51FA\\u5F53\\u524D\\u7EBF\\u7A0B\\u5904\\u7406\\u5B8C\\u6BD5\\u7684\\u6570\\u636E\\uFF0C\\u5373\\u4E24\\u4E2A\\u5411\\u91CF\\u76F8\\u52A0\\u540E\\u7684\\u7ED3\\u679C\\n    this.vectorA[globalInvocationID.x] = this.sum(a, b);\\n  }\\n}\\n\";\n\n  var App = /*#__PURE__*/_react.default.memo(function Add2Vectors() {\n    var _useState = (0, _react.useState)([]),\n        _useState2 = _slicedToArray(_useState, 2),\n        result = _useState2[0],\n        setResult = _useState2[1];\n\n    (0, _react.useEffect)(function () {\n      // compile our kernel code\n      var compiler = new _gWebgpuCompiler.Compiler();\n      var precompiledBundle = compiler.compileBundle(gCode); // console.log(precompiledBundle.toString());\n      // create world\n\n      var world = _gWebgpu.World.create({\n        engineOptions: {\n          supportCompute: true\n        }\n      });\n\n      var executeKernel = async function executeKernel() {\n        var kernel = world.createKernel(precompiledBundle).setDispatch([1, 1, 1]).setBinding('vectorA', [1, 2, 3, 4, 5, 6, 7, 8]).setBinding('vectorB', [1, 2, 3, 4, 5, 6, 7, 8]);\n        await kernel.execute();\n        setResult(await kernel.getOutput());\n      };\n\n      executeKernel();\n\n      window.gwebgpuClean = function () {\n        world.destroy();\n      };\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"h2\", null, \" Add 2 Vectors\"), /*#__PURE__*/_react.default.createElement(\"ul\", null, /*#__PURE__*/_react.default.createElement(\"li\", null, \"WorkGroup: 1\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"Threads per WorkGroup: 8\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"VectorA: 1, 2, 3, 4, 5, 6, 7, 8\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"VectorB: 1, 2, 3, 4, 5, 6, 7, 8\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"Result: \", result.toString())));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n});"},{"relativePath":"gpgpu/basic/add2vectors/demo/iteration.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/add2vectors/demo/iteration.tsx","order":2,"filename":"iteration.tsx","title":"迭代多次，串联自身","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","source":"import { World } from '@antv/g-webgpu';\nimport { Compiler } from '@antv/g-webgpu-compiler';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst gCode = `\nimport { globalInvocationID } from 'g-webgpu';\n\n@numthreads(8, 1, 1)\nclass Add2Vectors {\n  @in\n  vectorA: float[];\n\n  @in\n  vectorB: float[];\n\n  @out(8)\n  result: float[];\n\n  sum(a: float, b: float): float {\n    return a + b;\n  }\n\n  @main\n  compute() {\n    // 获取当前线程处理的数据\n    const a = this.vectorA[globalInvocationID.x];\n    const b = this.vectorB[globalInvocationID.x];\n  \n    // 输出当前线程处理完毕的数据，即两个向量相加后的结果\n    this.result[globalInvocationID.x] = this.sum(a, b);\n  }\n}\n`;\n\nconst App = React.memo(function Add2Vectors() {\n  const [result, setResult] = useState([]);\n  useEffect(() => {\n    // compile our kernel code\n    const compiler = new Compiler();\n    const precompiledBundle = compiler.compileBundle(gCode);\n\n    // create world\n    const world = World.create({\n      engineOptions: {\n        supportCompute: true,\n      },\n    });\n    const executeKernel = async () => {\n      const kernel = world\n        .createKernel(precompiledBundle)\n        .setDispatch([1, 1, 1])\n        .setBinding({\n          vectorA: [0, 0, 0, 0, 0, 0, 0, 0],\n          vectorB: [1, 1, 1, 1, 1, 1, 1, 1],\n        });\n\n      for (let i = 2; i < 11; i++) {\n        await kernel.execute();\n        kernel.setBinding({\n          vectorA: kernel,\n          vectorB: [i, i, i, i, i, i, i, i],\n        });\n      }\n      setResult(await kernel.getOutput());\n    };\n    executeKernel();\n\n    window.gwebgpuClean = () => {\n      world.destroy();\n    };\n  }, []);\n\n  return (\n    <>\n      <h2> Run the same kernel 9 times, sum 0-9 </h2>\n      <ul>\n        <li>WorkGroup: 1</li>\n        <li>Threads per WorkGroup: 8</li>\n        <li>Result: {result.toString()}</li>\n      </ul>\n    </>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-webgpu\", \"@antv/g-webgpu-compiler\", \"react\", \"react-dom\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-webgpu\"), require(\"@antv/g-webgpu-compiler\"), require(\"react\"), require(\"react-dom\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gWebgpu, global.gWebgpuCompiler, global.react, global.reactDom);\n    global.iteration = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gWebgpu, _gWebgpuCompiler, _react, _reactDom) {\n  \"use strict\";\n\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  var gCode = \"\\nimport { globalInvocationID } from 'g-webgpu';\\n\\n@numthreads(8, 1, 1)\\nclass Add2Vectors {\\n  @in\\n  vectorA: float[];\\n\\n  @in\\n  vectorB: float[];\\n\\n  @out(8)\\n  result: float[];\\n\\n  sum(a: float, b: float): float {\\n    return a + b;\\n  }\\n\\n  @main\\n  compute() {\\n    // \\u83B7\\u53D6\\u5F53\\u524D\\u7EBF\\u7A0B\\u5904\\u7406\\u7684\\u6570\\u636E\\n    const a = this.vectorA[globalInvocationID.x];\\n    const b = this.vectorB[globalInvocationID.x];\\n  \\n    // \\u8F93\\u51FA\\u5F53\\u524D\\u7EBF\\u7A0B\\u5904\\u7406\\u5B8C\\u6BD5\\u7684\\u6570\\u636E\\uFF0C\\u5373\\u4E24\\u4E2A\\u5411\\u91CF\\u76F8\\u52A0\\u540E\\u7684\\u7ED3\\u679C\\n    this.result[globalInvocationID.x] = this.sum(a, b);\\n  }\\n}\\n\";\n\n  var App = /*#__PURE__*/_react.default.memo(function Add2Vectors() {\n    var _useState = (0, _react.useState)([]),\n        _useState2 = _slicedToArray(_useState, 2),\n        result = _useState2[0],\n        setResult = _useState2[1];\n\n    (0, _react.useEffect)(function () {\n      // compile our kernel code\n      var compiler = new _gWebgpuCompiler.Compiler();\n      var precompiledBundle = compiler.compileBundle(gCode); // create world\n\n      var world = _gWebgpu.World.create({\n        engineOptions: {\n          supportCompute: true\n        }\n      });\n\n      var executeKernel = async function executeKernel() {\n        var kernel = world.createKernel(precompiledBundle).setDispatch([1, 1, 1]).setBinding({\n          vectorA: [0, 0, 0, 0, 0, 0, 0, 0],\n          vectorB: [1, 1, 1, 1, 1, 1, 1, 1]\n        });\n\n        for (var i = 2; i < 11; i++) {\n          await kernel.execute();\n          kernel.setBinding({\n            vectorA: kernel,\n            vectorB: [i, i, i, i, i, i, i, i]\n          });\n        }\n\n        setResult(await kernel.getOutput());\n      };\n\n      executeKernel();\n\n      window.gwebgpuClean = function () {\n        world.destroy();\n      };\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"h2\", null, \" Run the same kernel 9 times, sum 0-9 \"), /*#__PURE__*/_react.default.createElement(\"ul\", null, /*#__PURE__*/_react.default.createElement(\"li\", null, \"WorkGroup: 1\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"Threads per WorkGroup: 8\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"Result: \", result.toString())));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n});"},{"relativePath":"gpgpu/basic/add2vectors/demo/pipeline.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/add2vectors/demo/pipeline.tsx","order":3,"filename":"pipeline.tsx","title":"串联多个 Kernel","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","source":"import { World } from '@antv/g-webgpu';\nimport { Compiler } from '@antv/g-webgpu-compiler';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst gCode = `\nimport { globalInvocationID } from 'g-webgpu';\n\n@numthreads(8, 1, 1)\nclass Add2Vectors {\n  @in\n  vectorA: float[];\n\n  @in\n  vectorB: float[];\n\n  @out(8)\n  result: float[];\n\n  sum(a: float, b: float): float {\n    return a + b;\n  }\n\n  @main\n  compute() {\n    // 获取当前线程处理的数据\n    const a = this.vectorA[globalInvocationID.x];\n    const b = this.vectorB[globalInvocationID.x];\n  \n    // 输出当前线程处理完毕的数据，即两个向量相加后的结果\n    this.result[globalInvocationID.x] = this.sum(a, b);\n  }\n}\n`;\n\nconst App = React.memo(function Add2Vectors() {\n  const [result, setResult] = useState([]);\n  useEffect(() => {\n    // compile our kernel code\n    const compiler = new Compiler();\n    const precompiledBundle = compiler.compileBundle(gCode);\n\n    // create world\n    const world = World.create({\n      engineOptions: {\n        supportCompute: true,\n      },\n    });\n    const executeKernel = async () => {\n      const kernel1 = world\n        .createKernel(precompiledBundle)\n        .setDispatch([1, 1, 1])\n        .setBinding({\n          vectorA: [1, 2, 3, 4, 5, 6, 7, 8],\n          vectorB: [1, 2, 3, 4, 5, 6, 7, 8],\n        });\n\n      const kernel2 = world\n        .createKernel(precompiledBundle)\n        .setDispatch([1, 1, 1])\n        .setBinding({\n          vectorA: kernel1,\n          vectorB: [1, 2, 3, 4, 5, 6, 7, 8],\n        });\n\n      const kernel3 = world\n        .createKernel(precompiledBundle)\n        .setDispatch([1, 1, 1])\n        .setBinding({\n          vectorA: kernel2,\n          vectorB: [1, 2, 3, 4, 5, 6, 7, 8],\n        });\n\n      await kernel1.execute();\n      await kernel2.execute();\n      await kernel3.execute();\n      setResult(await kernel3.getOutput());\n\n      window.gwebgpuClean = () => {\n        world.destroy();\n      };\n    };\n    executeKernel();\n  }, []);\n\n  return (\n    <>\n      <h2> Create a pipeline with 3 kernels </h2>\n      <ul>\n        <li>WorkGroup: 1</li>\n        <li>Threads per WorkGroup: 8</li>\n        <li>Kernel1 VectorA: 1, 2, 3, 4, 5, 6, 7, 8</li>\n        <li>Kernel1 VectorB: 1, 2, 3, 4, 5, 6, 7, 8</li>\n        <li>Kernel2 VectorC: 1, 2, 3, 4, 5, 6, 7, 8</li>\n        <li>Kernel3 VectorD: 1, 2, 3, 4, 5, 6, 7, 8</li>\n        <li>Result: {result.toString()}</li>\n      </ul>\n    </>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-webgpu\", \"@antv/g-webgpu-compiler\", \"react\", \"react-dom\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-webgpu\"), require(\"@antv/g-webgpu-compiler\"), require(\"react\"), require(\"react-dom\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gWebgpu, global.gWebgpuCompiler, global.react, global.reactDom);\n    global.pipeline = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gWebgpu, _gWebgpuCompiler, _react, _reactDom) {\n  \"use strict\";\n\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  var gCode = \"\\nimport { globalInvocationID } from 'g-webgpu';\\n\\n@numthreads(8, 1, 1)\\nclass Add2Vectors {\\n  @in\\n  vectorA: float[];\\n\\n  @in\\n  vectorB: float[];\\n\\n  @out(8)\\n  result: float[];\\n\\n  sum(a: float, b: float): float {\\n    return a + b;\\n  }\\n\\n  @main\\n  compute() {\\n    // \\u83B7\\u53D6\\u5F53\\u524D\\u7EBF\\u7A0B\\u5904\\u7406\\u7684\\u6570\\u636E\\n    const a = this.vectorA[globalInvocationID.x];\\n    const b = this.vectorB[globalInvocationID.x];\\n  \\n    // \\u8F93\\u51FA\\u5F53\\u524D\\u7EBF\\u7A0B\\u5904\\u7406\\u5B8C\\u6BD5\\u7684\\u6570\\u636E\\uFF0C\\u5373\\u4E24\\u4E2A\\u5411\\u91CF\\u76F8\\u52A0\\u540E\\u7684\\u7ED3\\u679C\\n    this.result[globalInvocationID.x] = this.sum(a, b);\\n  }\\n}\\n\";\n\n  var App = /*#__PURE__*/_react.default.memo(function Add2Vectors() {\n    var _useState = (0, _react.useState)([]),\n        _useState2 = _slicedToArray(_useState, 2),\n        result = _useState2[0],\n        setResult = _useState2[1];\n\n    (0, _react.useEffect)(function () {\n      // compile our kernel code\n      var compiler = new _gWebgpuCompiler.Compiler();\n      var precompiledBundle = compiler.compileBundle(gCode); // create world\n\n      var world = _gWebgpu.World.create({\n        engineOptions: {\n          supportCompute: true\n        }\n      });\n\n      var executeKernel = async function executeKernel() {\n        var kernel1 = world.createKernel(precompiledBundle).setDispatch([1, 1, 1]).setBinding({\n          vectorA: [1, 2, 3, 4, 5, 6, 7, 8],\n          vectorB: [1, 2, 3, 4, 5, 6, 7, 8]\n        });\n        var kernel2 = world.createKernel(precompiledBundle).setDispatch([1, 1, 1]).setBinding({\n          vectorA: kernel1,\n          vectorB: [1, 2, 3, 4, 5, 6, 7, 8]\n        });\n        var kernel3 = world.createKernel(precompiledBundle).setDispatch([1, 1, 1]).setBinding({\n          vectorA: kernel2,\n          vectorB: [1, 2, 3, 4, 5, 6, 7, 8]\n        });\n        await kernel1.execute();\n        await kernel2.execute();\n        await kernel3.execute();\n        setResult(await kernel3.getOutput());\n\n        window.gwebgpuClean = function () {\n          world.destroy();\n        };\n      };\n\n      executeKernel();\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"h2\", null, \" Create a pipeline with 3 kernels \"), /*#__PURE__*/_react.default.createElement(\"ul\", null, /*#__PURE__*/_react.default.createElement(\"li\", null, \"WorkGroup: 1\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"Threads per WorkGroup: 8\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"Kernel1 VectorA: 1, 2, 3, 4, 5, 6, 7, 8\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"Kernel1 VectorB: 1, 2, 3, 4, 5, 6, 7, 8\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"Kernel2 VectorC: 1, 2, 3, 4, 5, 6, 7, 8\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"Kernel3 VectorD: 1, 2, 3, 4, 5, 6, 7, 8\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"Result: \", result.toString())));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n});"}]},"description":"<p>我们的计算任务很简单，实现两个向量相加。详见<a href=\"/zh/docs/tutorial/gpgpu/add2vectors\">教程</a>。</p>"}},"staticQueryHashes":["1015175297","3000541721","3000541721","3378097331","638047554"]}