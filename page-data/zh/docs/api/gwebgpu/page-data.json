{"componentChunkName":"component---node-modules-antv-gatsby-theme-antv-site-templates-document-tsx","path":"/zh/docs/api/gwebgpu","result":{"data":{"site":{"siteMetadata":{"title":"GWebGPU","githubUrl":"https://github.com/antvis/GWebGPUEngine","docs":[{"slug":"api/gwebgpu","title":{"zh":"GWebGPU 简介","en":"Introduction"},"order":0},{"slug":"api/syntax","title":{"zh":"语法介绍","en":"Shader Syntax"},"order":1},{"slug":"api/compute-pipeline","title":{"zh":"计算管线 API","en":"API of compute pipeline"},"order":2},{"slug":"api/workgroup","title":{"zh":"线程组","en":"Workgroup"},"order":3}]},"pathPrefix":""},"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{"id":"什么是-gpgpu-？","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%E4%BB%80%E4%B9%88%E6%98%AF-gpgpu-%EF%BC%9F","ariaLabel":"什么是 gpgpu ？ permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"什么是 GPGPU ？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由于硬件结构不同，GPU 与 CPU 擅长执行不同类型的计算任务。特别的，在单指令流多数据流（SIMD）场景下，GPU 的运算速度远超 CPU。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下图来自："},{"type":"element","tagName":"a","properties":{"href":"https://www.techpowerup.com/199624/nvidia-to-launch-geforce-337-50-beta-later-today","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.techpowerup.com/199624/nvidia-to-launch-geforce-337-50-beta-later-today"}]},{"type":"text","value":"，清晰的展示了 GPU 在每秒浮点数运算次数与数据吞吐量两项指标下的巨大优势。\n"},{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/3608471/83615466-2a928680-a5b9-11ea-80cf-fac28e0d91cc.png","alt":"image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"GPU 强大的计算能力早已不局限于渲染，"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"G"}]},{"type":"text","value":"eneral-"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"p"}]},{"type":"text","value":"urpose computing on "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"g"}]},{"type":"text","value":"raphics "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"p"}]},{"type":"text","value":"rocessing "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"u"}]},{"type":"text","value":"nits 即 GPU 通用计算概念的提出将这种能力推向了更广阔的计算场景。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"早期的经典系列书籍 GPU Gems "},{"type":"element","tagName":"a","properties":{"href":"https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"Gem2 🔗"}]},{"type":"text","value":" "},{"type":"element","tagName":"a","properties":{"href":"https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"Gem3 🔗"}]},{"type":"text","value":" 中就收录了大量通用计算领域的实践，包括了视频解码、实时加解密、图片压缩、随机数生成、仿真等等。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"现代的 GPU 更是针对特定类型的计算任务设计硬件。例如 Nvidia 的 Turing 架构中就包含了专门进行张量计算的 Tensor Core 和光线追踪计算的 RT Core。\n"},{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/3608471/83622800-0b98f200-a5c3-11ea-95b4-df99f287fa53.png"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"为了降低开发者面向 GPU 编程的门槛，Nvidia 提出了 CUDA（"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"ompute "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"U"}]},{"type":"text","value":"nified "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"D"}]},{"type":"text","value":"evice "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"A"}]},{"type":"text","value":"rchitecture，统一计算架构），开发者可以使用 C、Java、Python 等语言编写自己的计算任务代码。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而作为前端开发者，我们面对的适合并行的数据密集型计算任务也越来越多，是否能在 Web 端使用 GPGPU 技术呢？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{"id":"在-web-端应用","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%E5%9C%A8-web-%E7%AB%AF%E5%BA%94%E7%94%A8","ariaLabel":"在 web 端应用 permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"在 Web 端应用"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"事实上，在 Web 端已经有了很多优秀的 GPGPU 实践，例如："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/tensorflow/tfjs","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"tensorflow.js"}]},{"type":"text","value":"。用户通过 API 组合调用完成计算任务。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/gpujs/gpu.js","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"GPU.js"}]},{"type":"text","value":"。用户使用 JS 编写简单的计算任务。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://stardustjs.github.io/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"Stardust.js"}]},{"type":"text","value":"。用户使用 Mark 语言定义计算任务，实现 Sanddance 效果。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"webgl-实现","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#webgl-%E5%AE%9E%E7%8E%B0","ariaLabel":"webgl 实现 permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"WebGL 实现"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"从实现角度看，以上方案都使用 WebGL 图形 API 来模拟并不支持的 Compute Shader，具体来说都是通过常规渲染管线中可编程的 Vertex/Fragment Shader 完成。来自："},{"type":"element","tagName":"a","properties":{"href":"http://www.vizitsolutions.com/portfolio/webgl/gpgpu/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.vizitsolutions.com/portfolio/webgl/gpgpu/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/3608471/83623503-fd97a100-a5c3-11ea-83d3-bf2c11836219.png","alt":"image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这当然是出于兼容性考虑，Compute Shader 中本应具有的线程组、共享内存、同步等机制都无法通过 Vertex/Fragment Shader 模拟。另外计算管线相比常规渲染管线也要精简很多。下图中左右两侧分别是 Vulkan 的可编程渲染与计算管线，来自 "},{"type":"element","tagName":"a","properties":{"href":"https://vulkan.lunarg.com/doc/view/1.0.26.0/windows/vkspec.chunked/ch09.html","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://vulkan.lunarg.com/doc/view/1.0.26.0/windows/vkspec.chunked/ch09.html"}]},{"type":"text","value":"："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/3608471/83636874-4574f300-a5d9-11ea-81d8-af77eb46caa1.png","alt":"image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当然 WebGL 2 也考虑过原生支持 Compute Shader，毕竟这也是 OpenGL ES 3.1 中的核心特性。甚至 "},{"type":"element","tagName":"a","properties":{"href":"https://www.khronos.org/registry/webgl/specs/latest/2.0-compute/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"WebGL 2.0 Compute 草案"}]},{"type":"text","value":" 和 "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/9ballsyndrome/WebGL_Compute_shader","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"DEMO"}]},{"type":"text","value":" 也早就提出了。但由于苹果的不支持，目前 WebGL 2.0 Compute 也仅能在 Windows Chrome/Edge 下运行。同理 WebGL 2.0 的 Transform Feedback 作为另一个选择也存在兼容性问题。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下图来自 "},{"type":"element","tagName":"a","properties":{"href":"https://slideplayer.com/slide/16710114/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://slideplayer.com/slide/16710114/"}]},{"type":"text","value":"，展示了 WebGL 与 OpenGL 的对应关系：\n"},{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/3608471/83636450-959f8580-a5d8-11ea-8881-6496f16b1311.png","alt":"image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"webgpu-实现","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#webgpu-%E5%AE%9E%E7%8E%B0","ariaLabel":"webgpu 实现 permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"WebGPU 实现"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而作为 WebGL 的继任者 WebGPU，目前得到了各大浏览器厂商的"},{"type":"element","tagName":"a","properties":{"href":"https://github.com/gpuweb/gpuweb/wiki/Implementation-Status","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"支持"}]},{"type":"text","value":"，可以在以下浏览器中体验（需要开启实验特性 webgpu flag）："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Chrome Canary"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Edge Canary"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Safari Technology Preview"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下图来自："},{"type":"element","tagName":"a","properties":{"href":"https://www.chromestatus.com/feature/6213121689518080","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.chromestatus.com/feature/6213121689518080"}]},{"type":"text","value":"，作为现代化的图形 API，WebGPU 的一大特性就是支持 Compute Shader。这理所当然成为了未来我们的第一选择："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/3608471/83626014-6d5b5b00-a5c7-11ea-8ec1-410cb4e5dcfc.png","alt":"image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"除了计算，浏览器实现 WebGPU API 时封装了 Vulkan、DX12、Metal 这些现代化图形 API 而非 OpenGL，进一步降低了驱动开销，也更好地支持多线程。对于使用者而言，过去 WebGL API 中存在的种种问题也将得到解决。\n值得一提的是，虽然各个浏览器在 WebGPU API 上达成了一致，但在 Shader 语言的选择上分成了两派，这也是目前 WebGPU 的 Demo 大多都无法同时运行在所有浏览器中："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在 Chrome/Edge 中使用 GLSL 4.5，通过官方提供的第三方库将其转成二进制码（SPIR-V）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在 Safari 中使用 WSL"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当然这也成为了我们的项目尝试解决的问题之一。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最后，虽然 WebGPU 还处于完善阶段，但也有了很多优秀的实践，例如："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"tensorflow.js 正在尝试 "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/tensorflow/tfjs/tree/master/tfjs-backend-webgpu/src","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"基于 WebGPU 的 backend 实现"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Babylon.js 正在尝试实现 "},{"type":"element","tagName":"a","properties":{"href":"https://doc.babylonjs.com/extensions/webgpu","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"基于 WebGPU 渲染引擎"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{"id":"我们面对的计算场景与挑战","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%E6%88%91%E4%BB%AC%E9%9D%A2%E5%AF%B9%E7%9A%84%E8%AE%A1%E7%AE%97%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%8C%91%E6%88%98","ariaLabel":"我们面对的计算场景与挑战 permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"我们面对的计算场景与挑战"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当我们从通用计算领域聚焦到可视化场景时，会发现存在着很多适合 GPU 执行的可并行计算任务，例如："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"布局计算。G6 中的 "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/antvis/G6/blob/master/src/layout/fruchterman.ts","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"Fruchterman 布局算法"}]},{"type":"text","value":"是一个很典型的例子，在每次迭代中每个节点的位置都需要根据其他节点位置进行计算，并且需要经历很多次迭代才能达到稳定状态，因此计算量很大。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Instanced-based 可视化。Stardust.js 正是针对这个场景，例如 sanddance 效果。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"data transformation。在海量数据要求高交互的图表场景下，很多可并行的算法例如 reduce & scan 都可以在 GPU 中执行。P4 & P5（IEEE TRANSACTIONS ON VISUALIZATION AND COMPUTER GRAPHICS, VOL. 26, NO. 3, MARCH 2020） 在这方面有很多实践。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在这些场景下，我们希望提供通用的计算能力，让前端开发者可以通过面向 GPU 编程实现自己的计算任务。因此我们面临一些挑战："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"编程语言对前端开发者友好。这样在迁移已有算法时，学习成本不会太高。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"开发者写一套代码，能够在支持 WebGPU 的各个浏览器中运行，并且尽可能兼容 WebGL。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"更好的向前端开发者传递线程组、共享内存、同步、内存布局这些概念，写出更高效的并行算法。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{"id":"核心特性","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7","ariaLabel":"核心特性 permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"核心特性"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们希望 GWebGPU 最终提供可独立使用的计算和渲染能力：\n"},{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/3608471/83701621-cd401900-a63c-11ea-9dcc-ccd3ff3d87b4.png","alt":"image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前我们重点实现了一些计算特性："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Shader 语言选择 TypeScript 语法，对前端开发者友好。另外后续我们会提供 VS Code Extension，进一步提升前端开发者的开发体验。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"WebGPU 优先，兼容 WebGL。编译生成适合不同运行环境的多份 Shader 代码，优先使用更高效的 WebGPU 实现。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持预编译，减少运行时间。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"后续我们会逐步补全渲染能力。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果对我们的 Shader 语法感兴趣，可以进一步阅读"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/api/syntax"},"children":[{"type":"text","value":"语法"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"tableOfContents":"<ul>\n<li><a href=\"/zh/docs/api/gwebgpu/#%E4%BB%80%E4%B9%88%E6%98%AF-gpgpu-%EF%BC%9F\">什么是 GPGPU ？</a></li>\n<li>\n<p><a href=\"/zh/docs/api/gwebgpu/#%E5%9C%A8-web-%E7%AB%AF%E5%BA%94%E7%94%A8\">在 Web 端应用</a></p>\n<ul>\n<li><a href=\"/zh/docs/api/gwebgpu/#webgl-%E5%AE%9E%E7%8E%B0\">WebGL 实现</a></li>\n<li><a href=\"/zh/docs/api/gwebgpu/#webgpu-%E5%AE%9E%E7%8E%B0\">WebGPU 实现</a></li>\n</ul>\n</li>\n<li><a href=\"/zh/docs/api/gwebgpu/#%E6%88%91%E4%BB%AC%E9%9D%A2%E5%AF%B9%E7%9A%84%E8%AE%A1%E7%AE%97%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%8C%91%E6%88%98\">我们面对的计算场景与挑战</a></li>\n<li><a href=\"/zh/docs/api/gwebgpu/#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7\">核心特性</a></li>\n</ul>","fields":{"slug":"/zh/docs/api/gwebgpu","readingTime":{"text":"2 min read","time":90300}},"frontmatter":{"title":"简介"},"parent":{"__typename":"File","relativePath":"api/gwebgpu.zh.md"}},"allMarkdownRemark":{"edges":[{"node":{"fields":{"slug":"/zh/docs/tutorial/quickstart"},"frontmatter":{"title":"快速上手","order":0}}},{"node":{"fields":{"slug":"/en/docs/tutorial/quickstart"},"frontmatter":{"title":"快速上手","order":0}}},{"node":{"fields":{"slug":"/en/docs/api/gwebgpu"},"frontmatter":{"title":"简介","order":0}}},{"node":{"fields":{"slug":"/zh/docs/api/gwebgpu"},"frontmatter":{"title":"简介","order":0}}},{"node":{"fields":{"slug":"/zh/docs/tutorial/add2vectors"},"frontmatter":{"title":"两个向量相加","order":1}}},{"node":{"fields":{"slug":"/en/docs/tutorial/add2vectors"},"frontmatter":{"title":"两个向量相加","order":1}}},{"node":{"fields":{"slug":"/en/docs/api/syntax"},"frontmatter":{"title":"Shader 语法介绍","order":1}}},{"node":{"fields":{"slug":"/zh/docs/api/syntax"},"frontmatter":{"title":"Shader 语法介绍","order":1}}},{"node":{"fields":{"slug":"/en/docs/tutorial/fruchterman"},"frontmatter":{"title":"Fruchterman 布局算法","order":2}}},{"node":{"fields":{"slug":"/zh/docs/tutorial/fruchterman"},"frontmatter":{"title":"Fruchterman 布局算法","order":2}}},{"node":{"fields":{"slug":"/zh/docs/api/compute-pipeline"},"frontmatter":{"title":"计算管线 API","order":2}}},{"node":{"fields":{"slug":"/en/docs/api/compute-pipeline"},"frontmatter":{"title":"计算管线 API","order":2}}},{"node":{"fields":{"slug":"/zh/docs/tutorial/reduce"},"frontmatter":{"title":"Reduce 求和","order":3}}},{"node":{"fields":{"slug":"/en/docs/tutorial/reduce"},"frontmatter":{"title":"Reduce 求和","order":3}}},{"node":{"fields":{"slug":"/en/docs/api/workgroup"},"frontmatter":{"title":"线程、共享内存和同步","order":3}}},{"node":{"fields":{"slug":"/zh/docs/api/workgroup"},"frontmatter":{"title":"线程、共享内存和同步","order":3}}},{"node":{"fields":{"slug":"/en/docs/api/roadmap"},"frontmatter":{"title":"Roadmap","order":4}}},{"node":{"fields":{"slug":"/zh/docs/api/roadmap"},"frontmatter":{"title":"Roadmap","order":4}}}]}},"pageContext":{}}}