{"componentChunkName":"component---node-modules-antv-gatsby-theme-antv-site-templates-example-tsx","path":"/en/examples/tutorial/fruchterman","result":{"data":{"site":{"siteMetadata":{"title":"GWebGPU","githubUrl":"https://github.com/antvis/GWebGPUEngine","examples":[{"slug":"tutorial","icon":"gallery","title":{"zh":"示例","en":"Examples"}}],"playground":{"container":"<div style=\"min-height: 500px; justify-content: center;position: relative\" id=\"wrapper\"/>","playgroundDidMount":null,"playgroundWillUnmount":null,"dependencies":{"@antv/g-webgpu":"latest"},"htmlCodeTemplate":null}},"pathPrefix":""},"allMarkdownRemark":{"edges":[{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们的计算任务很简单，实现两个向量相加。详见"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/tutorial/add2vectors"},"children":[{"type":"text","value":"教程"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/add2vectors"},"frontmatter":{"title":"Add 2 vectors","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/add2vectors/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们的计算任务很简单，实现两个向量相加。详见"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/tutorial/add2vectors"},"children":[{"type":"text","value":"教程"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/add2vectors"},"frontmatter":{"title":"两个向量相加","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/add2vectors/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/fruchterman"},"frontmatter":{"title":"Fruchterman Layout","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/fruchterman/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/fruchterman"},"frontmatter":{"title":"Fruchterman 布局算法","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/fruchterman/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/reduce"},"frontmatter":{"title":"Reduce (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/reduce/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"只能在支持 WebGPU 的浏览器中运行，详见"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/tutorial/reduce"},"children":[{"type":"text","value":"教程"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/reduce"},"frontmatter":{"title":"Reduce (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/reduce/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/pipeline"},"frontmatter":{"title":"Pipeline","order":4,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/pipeline/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/pipeline"},"frontmatter":{"title":"Pipeline","order":4,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/pipeline/index.zh.md"}}}]}},"pageContext":{"exampleSections":{"examples":[{"relativePath":"tutorial/fruchterman/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/tutorial/fruchterman/demo/index.tsx","order":0,"filename":"index.tsx","title":"Fruchterman 布局算法","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","source":"import { Canvas } from '@antv/g-canvas';\nimport { World } from '@antv/g-webgpu';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst gCode = `\nimport { globalInvocationID } from 'g-webgpu';\n\nconst SPEED_DIVISOR = 800;\nconst MAX_EDGE_PER_VERTEX;\nconst VERTEX_COUNT;\n\n@numthreads(1, 1, 1)\nclass Fruchterman {\n  @in @out\n  u_Data: vec4[];\n\n  @in\n  u_K: float;\n\n  @in\n  u_K2: float;\n\n  @in\n  u_Gravity: float;\n\n  @in\n  u_Speed: float;\n\n  @in\n  u_MaxDisplace: float;\n\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      if (i != j) {\n        const nextNode = this.u_Data[j];\n        const xDist = currentNode[0] - nextNode[0];\n        const yDist = currentNode[1] - nextNode[1];\n        const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\n        if (dist > 0.0) {\n          const repulsiveF = this.u_K2 / dist;\n          dx += xDist / dist * repulsiveF;\n          dy += yDist / dist * repulsiveF;\n        }\n      }\n    }\n    return [dx, dy];\n  }\n\n  calcGravity(currentNode: vec4): vec2 {\n    const d = sqrt(currentNode[0] * currentNode[0] + currentNode[1] * currentNode[1]);\n    const gf = 0.01 * this.u_K * this.u_Gravity * d;\n    return [gf * currentNode[0] / d, gf * currentNode[1] / d];\n  }\n\n  calcAttractive(currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    const arr_offset = int(floor(currentNode[2] + 0.5));\n    const length = int(floor(currentNode[3] + 0.5));\n    const node_buffer: vec4;\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\n      if (p >= length) break;\n      const arr_idx = arr_offset + p;\n      // when arr_idx % 4 == 0 update currentNodedx_buffer\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\n      if (p == 0 || buf_offset == 0) {\n        node_buffer = this.u_Data[int(arr_idx / 4)];\n      }\n      const float_j = buf_offset == 0 ? node_buffer[0] :\n                      buf_offset == 1 ? node_buffer[1] :\n                      buf_offset == 2 ? node_buffer[2] :\n                                        node_buffer[3];\n      const nextNode = this.u_Data[int(float_j)];\n      const xDist = currentNode[0] - nextNode[0];\n      const yDist = currentNode[1] - nextNode[1];\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\n      const attractiveF = dist * dist / this.u_K;\n      if (dist > 0.0) {\n        dx -= xDist / dist * attractiveF;\n        dy -= yDist / dist * attractiveF;\n      }\n    }\n    return [dx, dy];\n  }\n\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const currentNode = this.u_Data[i];\n\n    let dx = 0, dy = 0;\n\n    if (i >= VERTEX_COUNT) {\n      this.u_Data[i] = currentNode;\n      return;\n    }\n\n    // repulsive\n    const repulsive = this.calcRepulsive(i, currentNode);\n    dx += repulsive[0];\n    dy += repulsive[1];\n\n    // attractive\n    const attractive = this.calcAttractive(currentNode);\n    dx += attractive[0];\n    dy += attractive[1];\n\n    // gravity\n    const gravity = this.calcGravity(currentNode);\n    dx -= gravity[0];\n    dy -= gravity[1];\n\n    // speed\n    dx *= this.u_Speed;\n    dy *= this.u_Speed;\n\n    // move\n    const distLength = sqrt(dx * dx + dy * dy);\n    if (distLength > 0.0) {\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\n\n      this.u_Data[i] = [\n        currentNode[0] + dx / distLength * limitedDist,\n        currentNode[1] + dy / distLength * limitedDist,\n        currentNode[2],\n        currentNode[3]\n      ];\n    }\n  }\n}\n`;\n\nconst MAX_ITERATION = 8000;\n\nconst App = React.memo(function Fruchterman() {\n  const [timeElapsed, setTimeElapsed] = useState(0);\n  useEffect(() => {\n    (async () => {\n      const canvas = document.getElementById(\n        'application',\n      ) as HTMLCanvasElement;\n      if (canvas) {\n        // @see https://g6.antv.vision/en/examples/net/forceDirected/#basicForceDirected\n        const data = await (\n          await fetch(\n            'https://gw.alipayobjects.com/os/basement_prod/7bacd7d1-4119-4ac1-8be3-4c4b9bcbc25f.json',\n          )\n        ).json();\n\n        const nodes = data.nodes.map((n) => ({\n          x: (Math.random() * 2 - 1) / 10,\n          y: (Math.random() * 2 - 1) / 10,\n          id: n.id,\n        }));\n        const edges = data.edges;\n        const numParticles = nodes.length;\n        const nodesEdgesArray = buildTextureData(nodes, edges);\n\n        const world = new World(canvas, {\n          engineOptions: {\n            supportCompute: true,\n          },\n        });\n\n        const timeStart = window.performance.now();\n        const compute = world.createComputePipeline({\n          shader: gCode,\n          dispatch: [numParticles, 1, 1],\n          maxIteration: MAX_ITERATION,\n          onCompleted: (finalParticleData) => {\n            setTimeElapsed(window.performance.now() - timeStart);\n            // draw with G\n            renderCircles(finalParticleData, numParticles);\n\n            // precompiled\n            // console.log(world.getPrecompiledBundle(compute));\n\n            // 计算完成后销毁相关 GPU 资源\n            world.destroy();\n          },\n        });\n\n        world.setBinding(compute, 'u_Data', nodesEdgesArray);\n        world.setBinding(\n          compute,\n          'u_K',\n          Math.sqrt((numParticles * numParticles) / (numParticles + 1) / 300),\n        );\n        world.setBinding(\n          compute,\n          'u_K2',\n          (numParticles * numParticles) / (numParticles + 1) / 300 / 300,\n        );\n        world.setBinding(compute, 'u_Gravity', 50);\n        world.setBinding(compute, 'u_Speed', 0.1);\n        world.setBinding(\n          compute,\n          'u_MaxDisplace',\n          Math.sqrt(numParticles * numParticles) / 10,\n        );\n        world.setBinding(compute, 'MAX_EDGE_PER_VERTEX', maxEdgePerVetex);\n        world.setBinding(compute, 'VERTEX_COUNT', numParticles);\n      }\n    })();\n  }, []);\n\n  return (\n    <>\n      <canvas id=\"application\" style={{ display: 'none' }} />\n      <div id=\"container\" />\n      <div>Elapsed time: {timeElapsed / 1000}s</div>\n      <div>\n        Ported from the same{' '}\n        <a href=\"https://g6.antv.vision/en/examples/net/furchtermanLayout#fruchtermanWebWorker\">\n          example\n        </a>{' '}\n        in G6\n      </div>\n    </>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n\nconst CANVAS_HEIGHT = 600;\nconst CANVAS_WIDTH = 600;\nfunction renderCircles(finalParticleData, numParticles) {\n  const canvas = new Canvas({\n    container: 'container',\n    width: CANVAS_WIDTH,\n    height: CANVAS_HEIGHT,\n  });\n\n  // draw edges\n  for (let i = 0; i < lineIndexBufferData.length; i += 2) {\n    const x1 = finalParticleData[lineIndexBufferData[i] * 4];\n    const y1 = finalParticleData[lineIndexBufferData[i] * 4 + 1];\n    const x2 = finalParticleData[lineIndexBufferData[i + 1] * 4];\n    const y2 = finalParticleData[lineIndexBufferData[i + 1] * 4 + 1];\n    const group = canvas.addGroup();\n    group.addShape('line', {\n      attrs: {\n        x1: convertWebGLCoord2Canvas(x1, CANVAS_WIDTH),\n        y1: convertWebGLCoord2Canvas(y1, CANVAS_HEIGHT),\n        x2: convertWebGLCoord2Canvas(x2, CANVAS_WIDTH),\n        y2: convertWebGLCoord2Canvas(y2, CANVAS_HEIGHT),\n        stroke: '#1890FF',\n        lineWidth: 1,\n      },\n    });\n  }\n\n  // draw nodes\n  for (let i = 0; i < numParticles * 4; i += 4) {\n    const x = finalParticleData[i];\n    const y = finalParticleData[i + 1];\n    const group = canvas.addGroup();\n    group.addShape('circle', {\n      attrs: {\n        x: convertWebGLCoord2Canvas(x, CANVAS_WIDTH),\n        y: convertWebGLCoord2Canvas(y, CANVAS_HEIGHT),\n        r: 5,\n        fill: 'red',\n        stroke: 'blue',\n        lineWidth: 2,\n      },\n    });\n  }\n}\n\nfunction convertWebGLCoord2Canvas(c: number, size: number) {\n  return ((c + 1) / 2) * size;\n}\n\nconst lineIndexBufferData = [];\nlet maxEdgePerVetex;\n// @see https://github.com/nblintao/ParaGraphL/blob/master/sigma.layout.paragraphl.js#L192-L229\nfunction buildTextureData(nodes, edges) {\n  const dataArray = [];\n  const nodeDict = [];\n  const mapIdPos = {};\n  let i = 0;\n  for (i = 0; i < nodes.length; i++) {\n    const n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n  for (i = 0; i < edges.length; i++) {\n    const e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    lineIndexBufferData.push(mapIdPos[e.source], mapIdPos[e.target]);\n  }\n\n  maxEdgePerVetex = 0;\n  for (i = 0; i < nodes.length; i++) {\n    const offset = dataArray.length;\n    const dests = nodeDict[i];\n    const len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = dests.length;\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n    for (let j = 0; j < len; ++j) {\n      const dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n  return new Float32Array(dataArray);\n}\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-canvas\", \"@antv/g-webgpu\", \"react\", \"react-dom\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-canvas\"), require(\"@antv/g-webgpu\"), require(\"react\"), require(\"react-dom\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gCanvas, global.gWebgpu, global.react, global.reactDom);\n    global.index = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gCanvas, _gWebgpu, _react, _reactDom) {\n  \"use strict\";\n\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  var gCode = \"\\nimport { globalInvocationID } from 'g-webgpu';\\n\\nconst SPEED_DIVISOR = 800;\\nconst MAX_EDGE_PER_VERTEX;\\nconst VERTEX_COUNT;\\n\\n@numthreads(1, 1, 1)\\nclass Fruchterman {\\n  @in @out\\n  u_Data: vec4[];\\n\\n  @in\\n  u_K: float;\\n\\n  @in\\n  u_K2: float;\\n\\n  @in\\n  u_Gravity: float;\\n\\n  @in\\n  u_Speed: float;\\n\\n  @in\\n  u_MaxDisplace: float;\\n\\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\\n    let dx = 0, dy = 0;\\n    for (let j = 0; j < VERTEX_COUNT; j++) {\\n      if (i != j) {\\n        const nextNode = this.u_Data[j];\\n        const xDist = currentNode[0] - nextNode[0];\\n        const yDist = currentNode[1] - nextNode[1];\\n        const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\\n        if (dist > 0.0) {\\n          const repulsiveF = this.u_K2 / dist;\\n          dx += xDist / dist * repulsiveF;\\n          dy += yDist / dist * repulsiveF;\\n        }\\n      }\\n    }\\n    return [dx, dy];\\n  }\\n\\n  calcGravity(currentNode: vec4): vec2 {\\n    const d = sqrt(currentNode[0] * currentNode[0] + currentNode[1] * currentNode[1]);\\n    const gf = 0.01 * this.u_K * this.u_Gravity * d;\\n    return [gf * currentNode[0] / d, gf * currentNode[1] / d];\\n  }\\n\\n  calcAttractive(currentNode: vec4): vec2 {\\n    let dx = 0, dy = 0;\\n    const arr_offset = int(floor(currentNode[2] + 0.5));\\n    const length = int(floor(currentNode[3] + 0.5));\\n    const node_buffer: vec4;\\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\\n      if (p >= length) break;\\n      const arr_idx = arr_offset + p;\\n      // when arr_idx % 4 == 0 update currentNodedx_buffer\\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\\n      if (p == 0 || buf_offset == 0) {\\n        node_buffer = this.u_Data[int(arr_idx / 4)];\\n      }\\n      const float_j = buf_offset == 0 ? node_buffer[0] :\\n                      buf_offset == 1 ? node_buffer[1] :\\n                      buf_offset == 2 ? node_buffer[2] :\\n                                        node_buffer[3];\\n      const nextNode = this.u_Data[int(float_j)];\\n      const xDist = currentNode[0] - nextNode[0];\\n      const yDist = currentNode[1] - nextNode[1];\\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\\n      const attractiveF = dist * dist / this.u_K;\\n      if (dist > 0.0) {\\n        dx -= xDist / dist * attractiveF;\\n        dy -= yDist / dist * attractiveF;\\n      }\\n    }\\n    return [dx, dy];\\n  }\\n\\n  @main\\n  compute() {\\n    const i = globalInvocationID.x;\\n    const currentNode = this.u_Data[i];\\n\\n    let dx = 0, dy = 0;\\n\\n    if (i >= VERTEX_COUNT) {\\n      this.u_Data[i] = currentNode;\\n      return;\\n    }\\n\\n    // repulsive\\n    const repulsive = this.calcRepulsive(i, currentNode);\\n    dx += repulsive[0];\\n    dy += repulsive[1];\\n\\n    // attractive\\n    const attractive = this.calcAttractive(currentNode);\\n    dx += attractive[0];\\n    dy += attractive[1];\\n\\n    // gravity\\n    const gravity = this.calcGravity(currentNode);\\n    dx -= gravity[0];\\n    dy -= gravity[1];\\n\\n    // speed\\n    dx *= this.u_Speed;\\n    dy *= this.u_Speed;\\n\\n    // move\\n    const distLength = sqrt(dx * dx + dy * dy);\\n    if (distLength > 0.0) {\\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\\n\\n      this.u_Data[i] = [\\n        currentNode[0] + dx / distLength * limitedDist,\\n        currentNode[1] + dy / distLength * limitedDist,\\n        currentNode[2],\\n        currentNode[3]\\n      ];\\n    }\\n  }\\n}\\n\";\n  var MAX_ITERATION = 8000;\n\n  var App = /*#__PURE__*/_react.default.memo(function Fruchterman() {\n    var _useState = (0, _react.useState)(0),\n        _useState2 = _slicedToArray(_useState, 2),\n        timeElapsed = _useState2[0],\n        setTimeElapsed = _useState2[1];\n\n    (0, _react.useEffect)(function () {\n      (async function () {\n        var canvas = document.getElementById('application');\n\n        if (canvas) {\n          // @see https://g6.antv.vision/en/examples/net/forceDirected/#basicForceDirected\n          var data = await (await fetch('https://gw.alipayobjects.com/os/basement_prod/7bacd7d1-4119-4ac1-8be3-4c4b9bcbc25f.json')).json();\n          var nodes = data.nodes.map(function (n) {\n            return {\n              x: (Math.random() * 2 - 1) / 10,\n              y: (Math.random() * 2 - 1) / 10,\n              id: n.id\n            };\n          });\n          var edges = data.edges;\n          var numParticles = nodes.length;\n          var nodesEdgesArray = buildTextureData(nodes, edges);\n          var world = new _gWebgpu.World(canvas, {\n            engineOptions: {\n              supportCompute: true\n            }\n          });\n          var timeStart = window.performance.now();\n          var compute = world.createComputePipeline({\n            shader: gCode,\n            dispatch: [numParticles, 1, 1],\n            maxIteration: MAX_ITERATION,\n            onCompleted: function onCompleted(finalParticleData) {\n              setTimeElapsed(window.performance.now() - timeStart); // draw with G\n\n              renderCircles(finalParticleData, numParticles); // precompiled\n              // console.log(world.getPrecompiledBundle(compute));\n              // 计算完成后销毁相关 GPU 资源\n\n              world.destroy();\n            }\n          });\n          world.setBinding(compute, 'u_Data', nodesEdgesArray);\n          world.setBinding(compute, 'u_K', Math.sqrt(numParticles * numParticles / (numParticles + 1) / 300));\n          world.setBinding(compute, 'u_K2', numParticles * numParticles / (numParticles + 1) / 300 / 300);\n          world.setBinding(compute, 'u_Gravity', 50);\n          world.setBinding(compute, 'u_Speed', 0.1);\n          world.setBinding(compute, 'u_MaxDisplace', Math.sqrt(numParticles * numParticles) / 10);\n          world.setBinding(compute, 'MAX_EDGE_PER_VERTEX', maxEdgePerVetex);\n          world.setBinding(compute, 'VERTEX_COUNT', numParticles);\n        }\n      })();\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"canvas\", {\n      id: \"application\",\n      style: {\n        display: 'none'\n      }\n    }), /*#__PURE__*/_react.default.createElement(\"div\", {\n      id: \"container\"\n    }), /*#__PURE__*/_react.default.createElement(\"div\", null, \"Elapsed time: \", timeElapsed / 1000, \"s\"), /*#__PURE__*/_react.default.createElement(\"div\", null, \"Ported from the same\", ' ', /*#__PURE__*/_react.default.createElement(\"a\", {\n      href: \"https://g6.antv.vision/en/examples/net/furchtermanLayout#fruchtermanWebWorker\"\n    }, \"example\"), ' ', \"in G6\"));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n\n  var CANVAS_HEIGHT = 600;\n  var CANVAS_WIDTH = 600;\n\n  function renderCircles(finalParticleData, numParticles) {\n    var canvas = new _gCanvas.Canvas({\n      container: 'container',\n      width: CANVAS_WIDTH,\n      height: CANVAS_HEIGHT\n    }); // draw edges\n\n    for (var i = 0; i < lineIndexBufferData.length; i += 2) {\n      var x1 = finalParticleData[lineIndexBufferData[i] * 4];\n      var y1 = finalParticleData[lineIndexBufferData[i] * 4 + 1];\n      var x2 = finalParticleData[lineIndexBufferData[i + 1] * 4];\n      var y2 = finalParticleData[lineIndexBufferData[i + 1] * 4 + 1];\n      var group = canvas.addGroup();\n      group.addShape('line', {\n        attrs: {\n          x1: convertWebGLCoord2Canvas(x1, CANVAS_WIDTH),\n          y1: convertWebGLCoord2Canvas(y1, CANVAS_HEIGHT),\n          x2: convertWebGLCoord2Canvas(x2, CANVAS_WIDTH),\n          y2: convertWebGLCoord2Canvas(y2, CANVAS_HEIGHT),\n          stroke: '#1890FF',\n          lineWidth: 1\n        }\n      });\n    } // draw nodes\n\n\n    for (var _i2 = 0; _i2 < numParticles * 4; _i2 += 4) {\n      var x = finalParticleData[_i2];\n      var y = finalParticleData[_i2 + 1];\n\n      var _group = canvas.addGroup();\n\n      _group.addShape('circle', {\n        attrs: {\n          x: convertWebGLCoord2Canvas(x, CANVAS_WIDTH),\n          y: convertWebGLCoord2Canvas(y, CANVAS_HEIGHT),\n          r: 5,\n          fill: 'red',\n          stroke: 'blue',\n          lineWidth: 2\n        }\n      });\n    }\n  }\n\n  function convertWebGLCoord2Canvas(c, size) {\n    return (c + 1) / 2 * size;\n  }\n\n  var lineIndexBufferData = [];\n  var maxEdgePerVetex; // @see https://github.com/nblintao/ParaGraphL/blob/master/sigma.layout.paragraphl.js#L192-L229\n\n  function buildTextureData(nodes, edges) {\n    var dataArray = [];\n    var nodeDict = [];\n    var mapIdPos = {};\n    var i = 0;\n\n    for (i = 0; i < nodes.length; i++) {\n      var n = nodes[i];\n      mapIdPos[n.id] = i;\n      dataArray.push(n.x);\n      dataArray.push(n.y);\n      dataArray.push(0);\n      dataArray.push(0);\n      nodeDict.push([]);\n    }\n\n    for (i = 0; i < edges.length; i++) {\n      var e = edges[i];\n      nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n      nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n      lineIndexBufferData.push(mapIdPos[e.source], mapIdPos[e.target]);\n    }\n\n    maxEdgePerVetex = 0;\n\n    for (i = 0; i < nodes.length; i++) {\n      var offset = dataArray.length;\n      var dests = nodeDict[i];\n      var len = dests.length;\n      dataArray[i * 4 + 2] = offset;\n      dataArray[i * 4 + 3] = dests.length;\n      maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n\n      for (var j = 0; j < len; ++j) {\n        var dest = dests[j];\n        dataArray.push(+dest);\n      }\n    }\n\n    while (dataArray.length % 4 !== 0) {\n      dataArray.push(0);\n    }\n\n    return new Float32Array(dataArray);\n  }\n});"},{"relativePath":"tutorial/fruchterman/demo/precompiled.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/tutorial/fruchterman/demo/precompiled.tsx","order":1,"filename":"precompiled.tsx","title":"Fruchterman 布局算法(预编译)","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","source":"import { Canvas } from '@antv/g-canvas';\nimport { World } from '@antv/g-webgpu';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst MAX_ITERATION = 8000;\n\nconst App = React.memo(function Fruchterman() {\n  const [timeElapsed, setTimeElapsed] = useState(0);\n  useEffect(() => {\n    (async () => {\n      const canvas = document.getElementById(\n        'application',\n      ) as HTMLCanvasElement;\n      if (canvas) {\n        // @see https://g6.antv.vision/en/examples/net/forceDirected/#basicForceDirected\n        const data = await (\n          await fetch(\n            'https://gw.alipayobjects.com/os/basement_prod/7bacd7d1-4119-4ac1-8be3-4c4b9bcbc25f.json',\n          )\n        ).json();\n\n        const nodes = data.nodes.map((n) => ({\n          x: (Math.random() * 2 - 1) / 10,\n          y: (Math.random() * 2 - 1) / 10,\n          id: n.id,\n        }));\n        const edges = data.edges;\n        const numParticles = nodes.length;\n        const nodesEdgesArray = buildTextureData(nodes, edges);\n\n        const world = new World(canvas, {\n          engineOptions: {\n            supportCompute: true,\n          },\n        });\n\n        const timeStart = window.performance.now();\n        const compute = world.createComputePipeline({\n          precompiled: true,\n          shader: '{\"shaders\":{\"WebGPU\":\"\\\\nlayout (\\\\n  local_size_x = 1,\\\\n  local_size_y = 1,\\\\n  local_size_z = 1\\\\n) in;\\\\n\\\\n#define SPEED_DIVISOR 800\\\\nlayout(std140, set = 0, binding = 0) uniform GWebGPUParams {\\\\n  float u_K;\\\\n  float u_K2;\\\\n  float u_Gravity;\\\\n  float u_Speed;\\\\n  float u_MaxDisplace;\\\\n} gWebGPUUniformParams;\\\\nlayout(std430, set = 0, binding = 1) buffer   GWebGPUBuffer0 {\\\\n  vec4 u_Data[];\\\\n} gWebGPUBuffer0;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\\\nivec3 workGroupSize = ivec3(gl_WorkGroupSize);\\\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\\\n\\\\n\\\\nvec2 calcRepulsive(int i,vec4 currentNode) {\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfor (int j = 0; (j < int(VERTEX_COUNT)); j++) {if ((i != int((j + int(1))))) {vec4 nextNode = gWebGPUBuffer0.u_Data[j];\\\\nfloat xDist = (currentNode[0] - float(nextNode[0]));\\\\nfloat yDist = (currentNode[1] - float(nextNode[1]));\\\\nfloat dist = (sqrt(((xDist * float(xDist)) + float((yDist * float(yDist))))) + float(0.01));\\\\nif ((dist > float(0.0))) {float repulsiveF = (gWebGPUUniformParams.u_K2 / float(dist));\\\\ndx += float(((xDist / float(dist)) * float(repulsiveF)));\\\\ndy += float(((yDist / float(dist)) * float(repulsiveF)));}}}\\\\nreturn vec2(dx,dy);}\\\\nvec2 calcGravity(vec4 currentNode) {\\\\nfloat d = sqrt(((currentNode[0] * float(currentNode[0])) + float((currentNode[1] * float(currentNode[1])))));\\\\nfloat gf = (((0.01 * float(gWebGPUUniformParams.u_K)) * float(gWebGPUUniformParams.u_Gravity)) * float(d));\\\\nreturn vec2(((gf * float(currentNode[0])) / float(d)),((gf * float(currentNode[1])) / float(d)));}\\\\nvec2 calcAttractive(vec4 currentNode) {\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nint arr_offset = int(floor((currentNode[2] + float(0.5))));\\\\nint length = int(floor((currentNode[3] + float(0.5))));\\\\nvec4 node_buffer;\\\\nfor (int p = 0; (p < int(MAX_EDGE_PER_VERTEX)); p++) {if ((p >= int(length))) {break;}\\\\nint arr_idx = (arr_offset + int(p));\\\\nint buf_offset = (arr_idx - int(((arr_idx / int(4)) * int(4))));\\\\nif ((p == int(0)) || (buf_offset == int(0))) {node_buffer = vec4(gWebGPUBuffer0.u_Data[int((arr_idx / 4))]);}\\\\nfloat float_j = ((buf_offset == int(0))) ? (node_buffer[0]) : (((buf_offset == int(1))) ? (node_buffer[1]) : (((buf_offset == int(2))) ? (node_buffer[2]) : (node_buffer[3])));\\\\nvec4 nextNode = gWebGPUBuffer0.u_Data[int(float_j)];\\\\nfloat xDist = (currentNode[0] - float(nextNode[0]));\\\\nfloat yDist = (currentNode[1] - float(nextNode[1]));\\\\nfloat dist = (sqrt(((xDist * float(xDist)) + float((yDist * float(yDist))))) + float(0.01));\\\\nfloat attractiveF = ((dist * float(dist)) / float(gWebGPUUniformParams.u_K));\\\\nif ((dist > float(0.0))) {dx -= float(((xDist / float(dist)) * float(attractiveF)));\\\\ndy -= float(((yDist / float(dist)) * float(attractiveF)));}}\\\\nreturn vec2(dx,dy);}\\\\nvoid main() {\\\\nint i = globalInvocationID.x;\\\\nvec4 currentNode = gWebGPUBuffer0.u_Data[i];\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nif ((i >= int(VERTEX_COUNT))) {gWebGPUBuffer0.u_Data[i] = vec4(currentNode);\\\\nreturn ;}\\\\nvec2 repulsive = calcRepulsive(i,currentNode);\\\\ndx += float(repulsive[0]);\\\\ndy += float(repulsive[1]);\\\\nvec2 attractive = calcAttractive(currentNode);\\\\ndx += float(attractive[0]);\\\\ndy += float(attractive[1]);\\\\nvec2 gravity = calcGravity(currentNode);\\\\ndx -= float(gravity[0]);\\\\ndy -= float(gravity[1]);\\\\ndx *= float(gWebGPUUniformParams.u_Speed);\\\\ndy *= float(gWebGPUUniformParams.u_Speed);\\\\nfloat distLength = sqrt(((dx * float(dx)) + float((dy * float(dy)))));\\\\nif ((distLength > float(0.0))) {float limitedDist = min((gWebGPUUniformParams.u_MaxDisplace * float(gWebGPUUniformParams.u_Speed)),distLength);\\\\ngWebGPUBuffer0.u_Data[i] = vec4(vec4((currentNode[0] + float(((dx / float(distLength)) * float(limitedDist)))),(currentNode[1] + float(((dy / float(distLength)) * float(limitedDist)))),currentNode[2],currentNode[3]));}}\\\\n\",\"WebGL\":\"\\\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\\\n  precision highp float;\\\\n#else\\\\n  precision mediump float;\\\\n#endif\\\\n#define SPEED_DIVISOR 800\\\\nuniform sampler2D u_Data;\\\\nuniform float u_K;\\\\nuniform float u_K2;\\\\nuniform float u_Gravity;\\\\nuniform float u_Speed;\\\\nuniform float u_MaxDisplace;\\\\n\\\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\\\n  vec2 normAddr2D = float(address1D) * conv_const;\\\\n  return vec2(fract(normAddr2D.x), normAddr2D.y);\\\\n}\\\\n\\\\nvoid barrier() {}\\\\n  \\\\n\\\\nuniform vec2 u_DataSize;\\\\nvec4 getDatau_Data(vec2 address2D) {\\\\n  return vec4(texture2D(u_Data, address2D).rgba);\\\\n}\\\\nvec4 getDatau_Data(float address1D) {\\\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\\\n}\\\\nvec4 getDatau_Data(int address1D) {\\\\n  return getDatau_Data(float(address1D));\\\\n}\\\\n\\\\nuniform vec2 u_OutputTextureSize;\\\\nuniform int u_OutputTexelCount;\\\\nvarying vec2 v_TexCoord;\\\\n\\\\nvec2 calcRepulsive(int i,vec4 currentNode) {\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfor (int j = 0; (j < int(VERTEX_COUNT)); j++) {if ((i != int((j + int(1))))) {vec4 nextNode = getDatau_Data(j);\\\\nfloat xDist = (currentNode[0] - float(nextNode[0]));\\\\nfloat yDist = (currentNode[1] - float(nextNode[1]));\\\\nfloat dist = (sqrt(((xDist * float(xDist)) + float((yDist * float(yDist))))) + float(0.01));\\\\nif ((dist > float(0.0))) {float repulsiveF = (u_K2 / float(dist));\\\\ndx += float(((xDist / float(dist)) * float(repulsiveF)));\\\\ndy += float(((yDist / float(dist)) * float(repulsiveF)));}}}\\\\nreturn vec2(dx,dy);}\\\\nvec2 calcGravity(vec4 currentNode) {\\\\nfloat d = sqrt(((currentNode[0] * float(currentNode[0])) + float((currentNode[1] * float(currentNode[1])))));\\\\nfloat gf = (((0.01 * float(u_K)) * float(u_Gravity)) * float(d));\\\\nreturn vec2(((gf * float(currentNode[0])) / float(d)),((gf * float(currentNode[1])) / float(d)));}\\\\nvec2 calcAttractive(vec4 currentNode) {\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nint arr_offset = int(floor((currentNode[2] + float(0.5))));\\\\nint length = int(floor((currentNode[3] + float(0.5))));\\\\nvec4 node_buffer;\\\\nfor (int p = 0; (p < int(MAX_EDGE_PER_VERTEX)); p++) {if ((p >= int(length))) {break;}\\\\nint arr_idx = (arr_offset + int(p));\\\\nint buf_offset = (arr_idx - int(((arr_idx / int(4)) * int(4))));\\\\nif ((p == int(0)) || (buf_offset == int(0))) {node_buffer = vec4(getDatau_Data(int((arr_idx / int(4)))));}\\\\nfloat float_j = ((buf_offset == int(0))) ? (node_buffer[0]) : (((buf_offset == int(1))) ? (node_buffer[1]) : (((buf_offset == int(2))) ? (node_buffer[2]) : (node_buffer[3])));\\\\nvec4 nextNode = getDatau_Data(int(float_j));\\\\nfloat xDist = (currentNode[0] - float(nextNode[0]));\\\\nfloat yDist = (currentNode[1] - float(nextNode[1]));\\\\nfloat dist = (sqrt(((xDist * float(xDist)) + float((yDist * float(yDist))))) + float(0.01));\\\\nfloat attractiveF = ((dist * float(dist)) / float(u_K));\\\\nif ((dist > float(0.0))) {dx -= float(((xDist / float(dist)) * float(attractiveF)));\\\\ndy -= float(((yDist / float(dist)) * float(attractiveF)));}}\\\\nreturn vec2(dx,dy);}\\\\nvoid main() {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(218, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\n\\\\nint i = globalInvocationID.x;\\\\nvec4 currentNode = getDatau_Data(i);\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nif ((i >= int(VERTEX_COUNT))) {gl_FragColor = vec4(currentNode);\\\\nreturn ;}\\\\nvec2 repulsive = calcRepulsive(i,currentNode);\\\\ndx += float(repulsive[0]);\\\\ndy += float(repulsive[1]);\\\\nvec2 attractive = calcAttractive(currentNode);\\\\ndx += float(attractive[0]);\\\\ndy += float(attractive[1]);\\\\nvec2 gravity = calcGravity(currentNode);\\\\ndx -= float(gravity[0]);\\\\ndy -= float(gravity[1]);\\\\ndx *= float(u_Speed);\\\\ndy *= float(u_Speed);\\\\nfloat distLength = sqrt(((dx * float(dx)) + float((dy * float(dy)))));\\\\nif ((distLength > float(0.0))) {float limitedDist = min((u_MaxDisplace * float(u_Speed)),distLength);\\\\ngl_FragColor = vec4(vec4((currentNode[0] + float(((dx / float(distLength)) * float(limitedDist)))),(currentNode[1] + float(((dy / float(distLength)) * float(limitedDist)))),currentNode[2],currentNode[3]));}}\\\\n    \"},\"context\":{\"name\":\"Fruchterman\",\"dispatch\":[218,1,1],\"threadGroupSize\":[1,1,1],\"maxIteration\":8000,\"defines\":[{\"name\":\"SPEED_DIVISOR\",\"value\":800,\"runtime\":false},{\"name\":\"MAX_EDGE_PER_VERTEX\",\"value\":50,\"runtime\":true},{\"name\":\"VERTEX_COUNT\",\"value\":218,\"runtime\":true}],\"uniforms\":[{\"name\":\"u_Data\",\"type\":\"sampler2D\",\"format\":\"vec4[]\",\"readonly\":false,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_K\",\"type\":\"float\",\"format\":\"float\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_K2\",\"type\":\"float\",\"format\":\"float\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_Gravity\",\"type\":\"float\",\"format\":\"float\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_Speed\",\"type\":\"float\",\"format\":\"float\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_MaxDisplace\",\"type\":\"float\",\"format\":\"float\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]}],\"globalDeclarations\":[],\"output\":{\"name\":\"u_Data\",\"size\":[1,1],\"length\":3840,\"outputElementsPerTexel\":4}}}',\n          dispatch: [numParticles, 1, 1],\n          maxIteration: MAX_ITERATION,\n          onCompleted: (finalParticleData) => {\n            setTimeElapsed(window.performance.now() - timeStart);\n            // draw with G\n            renderCircles(finalParticleData, numParticles);\n\n            // precompiled\n            // console.log(world.getPrecompiledBundle(compute));\n\n            // 计算完成后销毁相关 GPU 资源\n            world.destroy();\n          },\n        });\n\n        world.setBinding(compute, 'u_Data', nodesEdgesArray);\n        world.setBinding(\n          compute,\n          'u_K',\n          Math.sqrt((numParticles * numParticles) / (numParticles + 1) / 300),\n        );\n        world.setBinding(\n          compute,\n          'u_K2',\n          (numParticles * numParticles) / (numParticles + 1) / 300 / 300,\n        );\n        world.setBinding(compute, 'u_Gravity', 50);\n        world.setBinding(compute, 'u_Speed', 0.1);\n        world.setBinding(\n          compute,\n          'u_MaxDisplace',\n          Math.sqrt(numParticles * numParticles) / 10,\n        );\n        world.setBinding(compute, 'MAX_EDGE_PER_VERTEX', maxEdgePerVetex);\n        world.setBinding(compute, 'VERTEX_COUNT', numParticles);\n      }\n    })();\n  }, []);\n\n  return (\n    <>\n      <canvas id=\"application\" style={{ display: 'none' }} />\n      <div id=\"container\" />\n      <div>Elapsed time: {timeElapsed / 1000}s</div>\n      <div>\n        Ported from the same{' '}\n        <a href=\"https://g6.antv.vision/en/examples/net/furchtermanLayout#fruchtermanWebWorker\">\n          example\n        </a>{' '}\n        in G6\n      </div>\n    </>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n\nconst CANVAS_HEIGHT = 600;\nconst CANVAS_WIDTH = 600;\nfunction renderCircles(finalParticleData, numParticles) {\n  const canvas = new Canvas({\n    container: 'container',\n    width: CANVAS_WIDTH,\n    height: CANVAS_HEIGHT,\n  });\n\n  // draw edges\n  for (let i = 0; i < lineIndexBufferData.length; i += 2) {\n    const x1 = finalParticleData[lineIndexBufferData[i] * 4];\n    const y1 = finalParticleData[lineIndexBufferData[i] * 4 + 1];\n    const x2 = finalParticleData[lineIndexBufferData[i + 1] * 4];\n    const y2 = finalParticleData[lineIndexBufferData[i + 1] * 4 + 1];\n    const group = canvas.addGroup();\n    group.addShape('line', {\n      attrs: {\n        x1: convertWebGLCoord2Canvas(x1, CANVAS_WIDTH),\n        y1: convertWebGLCoord2Canvas(y1, CANVAS_HEIGHT),\n        x2: convertWebGLCoord2Canvas(x2, CANVAS_WIDTH),\n        y2: convertWebGLCoord2Canvas(y2, CANVAS_HEIGHT),\n        stroke: '#1890FF',\n        lineWidth: 1,\n      },\n    });\n  }\n\n  // draw nodes\n  for (let i = 0; i < numParticles * 4; i += 4) {\n    const x = finalParticleData[i];\n    const y = finalParticleData[i + 1];\n    const group = canvas.addGroup();\n    group.addShape('circle', {\n      attrs: {\n        x: convertWebGLCoord2Canvas(x, CANVAS_WIDTH),\n        y: convertWebGLCoord2Canvas(y, CANVAS_HEIGHT),\n        r: 5,\n        fill: 'red',\n        stroke: 'blue',\n        lineWidth: 2,\n      },\n    });\n  }\n}\n\nfunction convertWebGLCoord2Canvas(c: number, size: number) {\n  return ((c + 1) / 2) * size;\n}\n\nconst lineIndexBufferData = [];\nlet maxEdgePerVetex;\n// @see https://github.com/nblintao/ParaGraphL/blob/master/sigma.layout.paragraphl.js#L192-L229\nfunction buildTextureData(nodes, edges) {\n  const dataArray = [];\n  const nodeDict = [];\n  const mapIdPos = {};\n  let i = 0;\n  for (i = 0; i < nodes.length; i++) {\n    const n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n  for (i = 0; i < edges.length; i++) {\n    const e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    lineIndexBufferData.push(mapIdPos[e.source], mapIdPos[e.target]);\n  }\n\n  maxEdgePerVetex = 0;\n  for (i = 0; i < nodes.length; i++) {\n    const offset = dataArray.length;\n    const dests = nodeDict[i];\n    const len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = dests.length;\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n    for (let j = 0; j < len; ++j) {\n      const dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n  return new Float32Array(dataArray);\n}\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-canvas\", \"@antv/g-webgpu\", \"react\", \"react-dom\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-canvas\"), require(\"@antv/g-webgpu\"), require(\"react\"), require(\"react-dom\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gCanvas, global.gWebgpu, global.react, global.reactDom);\n    global.precompiled = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gCanvas, _gWebgpu, _react, _reactDom) {\n  \"use strict\";\n\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  var MAX_ITERATION = 8000;\n\n  var App = /*#__PURE__*/_react.default.memo(function Fruchterman() {\n    var _useState = (0, _react.useState)(0),\n        _useState2 = _slicedToArray(_useState, 2),\n        timeElapsed = _useState2[0],\n        setTimeElapsed = _useState2[1];\n\n    (0, _react.useEffect)(function () {\n      (async function () {\n        var canvas = document.getElementById('application');\n\n        if (canvas) {\n          // @see https://g6.antv.vision/en/examples/net/forceDirected/#basicForceDirected\n          var data = await (await fetch('https://gw.alipayobjects.com/os/basement_prod/7bacd7d1-4119-4ac1-8be3-4c4b9bcbc25f.json')).json();\n          var nodes = data.nodes.map(function (n) {\n            return {\n              x: (Math.random() * 2 - 1) / 10,\n              y: (Math.random() * 2 - 1) / 10,\n              id: n.id\n            };\n          });\n          var edges = data.edges;\n          var numParticles = nodes.length;\n          var nodesEdgesArray = buildTextureData(nodes, edges);\n          var world = new _gWebgpu.World(canvas, {\n            engineOptions: {\n              supportCompute: true\n            }\n          });\n          var timeStart = window.performance.now();\n          var compute = world.createComputePipeline({\n            precompiled: true,\n            shader: '{\"shaders\":{\"WebGPU\":\"\\\\nlayout (\\\\n  local_size_x = 1,\\\\n  local_size_y = 1,\\\\n  local_size_z = 1\\\\n) in;\\\\n\\\\n#define SPEED_DIVISOR 800\\\\nlayout(std140, set = 0, binding = 0) uniform GWebGPUParams {\\\\n  float u_K;\\\\n  float u_K2;\\\\n  float u_Gravity;\\\\n  float u_Speed;\\\\n  float u_MaxDisplace;\\\\n} gWebGPUUniformParams;\\\\nlayout(std430, set = 0, binding = 1) buffer   GWebGPUBuffer0 {\\\\n  vec4 u_Data[];\\\\n} gWebGPUBuffer0;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\\\nivec3 workGroupSize = ivec3(gl_WorkGroupSize);\\\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\\\n\\\\n\\\\nvec2 calcRepulsive(int i,vec4 currentNode) {\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfor (int j = 0; (j < int(VERTEX_COUNT)); j++) {if ((i != int((j + int(1))))) {vec4 nextNode = gWebGPUBuffer0.u_Data[j];\\\\nfloat xDist = (currentNode[0] - float(nextNode[0]));\\\\nfloat yDist = (currentNode[1] - float(nextNode[1]));\\\\nfloat dist = (sqrt(((xDist * float(xDist)) + float((yDist * float(yDist))))) + float(0.01));\\\\nif ((dist > float(0.0))) {float repulsiveF = (gWebGPUUniformParams.u_K2 / float(dist));\\\\ndx += float(((xDist / float(dist)) * float(repulsiveF)));\\\\ndy += float(((yDist / float(dist)) * float(repulsiveF)));}}}\\\\nreturn vec2(dx,dy);}\\\\nvec2 calcGravity(vec4 currentNode) {\\\\nfloat d = sqrt(((currentNode[0] * float(currentNode[0])) + float((currentNode[1] * float(currentNode[1])))));\\\\nfloat gf = (((0.01 * float(gWebGPUUniformParams.u_K)) * float(gWebGPUUniformParams.u_Gravity)) * float(d));\\\\nreturn vec2(((gf * float(currentNode[0])) / float(d)),((gf * float(currentNode[1])) / float(d)));}\\\\nvec2 calcAttractive(vec4 currentNode) {\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nint arr_offset = int(floor((currentNode[2] + float(0.5))));\\\\nint length = int(floor((currentNode[3] + float(0.5))));\\\\nvec4 node_buffer;\\\\nfor (int p = 0; (p < int(MAX_EDGE_PER_VERTEX)); p++) {if ((p >= int(length))) {break;}\\\\nint arr_idx = (arr_offset + int(p));\\\\nint buf_offset = (arr_idx - int(((arr_idx / int(4)) * int(4))));\\\\nif ((p == int(0)) || (buf_offset == int(0))) {node_buffer = vec4(gWebGPUBuffer0.u_Data[int((arr_idx / 4))]);}\\\\nfloat float_j = ((buf_offset == int(0))) ? (node_buffer[0]) : (((buf_offset == int(1))) ? (node_buffer[1]) : (((buf_offset == int(2))) ? (node_buffer[2]) : (node_buffer[3])));\\\\nvec4 nextNode = gWebGPUBuffer0.u_Data[int(float_j)];\\\\nfloat xDist = (currentNode[0] - float(nextNode[0]));\\\\nfloat yDist = (currentNode[1] - float(nextNode[1]));\\\\nfloat dist = (sqrt(((xDist * float(xDist)) + float((yDist * float(yDist))))) + float(0.01));\\\\nfloat attractiveF = ((dist * float(dist)) / float(gWebGPUUniformParams.u_K));\\\\nif ((dist > float(0.0))) {dx -= float(((xDist / float(dist)) * float(attractiveF)));\\\\ndy -= float(((yDist / float(dist)) * float(attractiveF)));}}\\\\nreturn vec2(dx,dy);}\\\\nvoid main() {\\\\nint i = globalInvocationID.x;\\\\nvec4 currentNode = gWebGPUBuffer0.u_Data[i];\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nif ((i >= int(VERTEX_COUNT))) {gWebGPUBuffer0.u_Data[i] = vec4(currentNode);\\\\nreturn ;}\\\\nvec2 repulsive = calcRepulsive(i,currentNode);\\\\ndx += float(repulsive[0]);\\\\ndy += float(repulsive[1]);\\\\nvec2 attractive = calcAttractive(currentNode);\\\\ndx += float(attractive[0]);\\\\ndy += float(attractive[1]);\\\\nvec2 gravity = calcGravity(currentNode);\\\\ndx -= float(gravity[0]);\\\\ndy -= float(gravity[1]);\\\\ndx *= float(gWebGPUUniformParams.u_Speed);\\\\ndy *= float(gWebGPUUniformParams.u_Speed);\\\\nfloat distLength = sqrt(((dx * float(dx)) + float((dy * float(dy)))));\\\\nif ((distLength > float(0.0))) {float limitedDist = min((gWebGPUUniformParams.u_MaxDisplace * float(gWebGPUUniformParams.u_Speed)),distLength);\\\\ngWebGPUBuffer0.u_Data[i] = vec4(vec4((currentNode[0] + float(((dx / float(distLength)) * float(limitedDist)))),(currentNode[1] + float(((dy / float(distLength)) * float(limitedDist)))),currentNode[2],currentNode[3]));}}\\\\n\",\"WebGL\":\"\\\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\\\n  precision highp float;\\\\n#else\\\\n  precision mediump float;\\\\n#endif\\\\n#define SPEED_DIVISOR 800\\\\nuniform sampler2D u_Data;\\\\nuniform float u_K;\\\\nuniform float u_K2;\\\\nuniform float u_Gravity;\\\\nuniform float u_Speed;\\\\nuniform float u_MaxDisplace;\\\\n\\\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\\\n  vec2 normAddr2D = float(address1D) * conv_const;\\\\n  return vec2(fract(normAddr2D.x), normAddr2D.y);\\\\n}\\\\n\\\\nvoid barrier() {}\\\\n  \\\\n\\\\nuniform vec2 u_DataSize;\\\\nvec4 getDatau_Data(vec2 address2D) {\\\\n  return vec4(texture2D(u_Data, address2D).rgba);\\\\n}\\\\nvec4 getDatau_Data(float address1D) {\\\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\\\n}\\\\nvec4 getDatau_Data(int address1D) {\\\\n  return getDatau_Data(float(address1D));\\\\n}\\\\n\\\\nuniform vec2 u_OutputTextureSize;\\\\nuniform int u_OutputTexelCount;\\\\nvarying vec2 v_TexCoord;\\\\n\\\\nvec2 calcRepulsive(int i,vec4 currentNode) {\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfor (int j = 0; (j < int(VERTEX_COUNT)); j++) {if ((i != int((j + int(1))))) {vec4 nextNode = getDatau_Data(j);\\\\nfloat xDist = (currentNode[0] - float(nextNode[0]));\\\\nfloat yDist = (currentNode[1] - float(nextNode[1]));\\\\nfloat dist = (sqrt(((xDist * float(xDist)) + float((yDist * float(yDist))))) + float(0.01));\\\\nif ((dist > float(0.0))) {float repulsiveF = (u_K2 / float(dist));\\\\ndx += float(((xDist / float(dist)) * float(repulsiveF)));\\\\ndy += float(((yDist / float(dist)) * float(repulsiveF)));}}}\\\\nreturn vec2(dx,dy);}\\\\nvec2 calcGravity(vec4 currentNode) {\\\\nfloat d = sqrt(((currentNode[0] * float(currentNode[0])) + float((currentNode[1] * float(currentNode[1])))));\\\\nfloat gf = (((0.01 * float(u_K)) * float(u_Gravity)) * float(d));\\\\nreturn vec2(((gf * float(currentNode[0])) / float(d)),((gf * float(currentNode[1])) / float(d)));}\\\\nvec2 calcAttractive(vec4 currentNode) {\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nint arr_offset = int(floor((currentNode[2] + float(0.5))));\\\\nint length = int(floor((currentNode[3] + float(0.5))));\\\\nvec4 node_buffer;\\\\nfor (int p = 0; (p < int(MAX_EDGE_PER_VERTEX)); p++) {if ((p >= int(length))) {break;}\\\\nint arr_idx = (arr_offset + int(p));\\\\nint buf_offset = (arr_idx - int(((arr_idx / int(4)) * int(4))));\\\\nif ((p == int(0)) || (buf_offset == int(0))) {node_buffer = vec4(getDatau_Data(int((arr_idx / int(4)))));}\\\\nfloat float_j = ((buf_offset == int(0))) ? (node_buffer[0]) : (((buf_offset == int(1))) ? (node_buffer[1]) : (((buf_offset == int(2))) ? (node_buffer[2]) : (node_buffer[3])));\\\\nvec4 nextNode = getDatau_Data(int(float_j));\\\\nfloat xDist = (currentNode[0] - float(nextNode[0]));\\\\nfloat yDist = (currentNode[1] - float(nextNode[1]));\\\\nfloat dist = (sqrt(((xDist * float(xDist)) + float((yDist * float(yDist))))) + float(0.01));\\\\nfloat attractiveF = ((dist * float(dist)) / float(u_K));\\\\nif ((dist > float(0.0))) {dx -= float(((xDist / float(dist)) * float(attractiveF)));\\\\ndy -= float(((yDist / float(dist)) * float(attractiveF)));}}\\\\nreturn vec2(dx,dy);}\\\\nvoid main() {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(218, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\n\\\\nint i = globalInvocationID.x;\\\\nvec4 currentNode = getDatau_Data(i);\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nif ((i >= int(VERTEX_COUNT))) {gl_FragColor = vec4(currentNode);\\\\nreturn ;}\\\\nvec2 repulsive = calcRepulsive(i,currentNode);\\\\ndx += float(repulsive[0]);\\\\ndy += float(repulsive[1]);\\\\nvec2 attractive = calcAttractive(currentNode);\\\\ndx += float(attractive[0]);\\\\ndy += float(attractive[1]);\\\\nvec2 gravity = calcGravity(currentNode);\\\\ndx -= float(gravity[0]);\\\\ndy -= float(gravity[1]);\\\\ndx *= float(u_Speed);\\\\ndy *= float(u_Speed);\\\\nfloat distLength = sqrt(((dx * float(dx)) + float((dy * float(dy)))));\\\\nif ((distLength > float(0.0))) {float limitedDist = min((u_MaxDisplace * float(u_Speed)),distLength);\\\\ngl_FragColor = vec4(vec4((currentNode[0] + float(((dx / float(distLength)) * float(limitedDist)))),(currentNode[1] + float(((dy / float(distLength)) * float(limitedDist)))),currentNode[2],currentNode[3]));}}\\\\n    \"},\"context\":{\"name\":\"Fruchterman\",\"dispatch\":[218,1,1],\"threadGroupSize\":[1,1,1],\"maxIteration\":8000,\"defines\":[{\"name\":\"SPEED_DIVISOR\",\"value\":800,\"runtime\":false},{\"name\":\"MAX_EDGE_PER_VERTEX\",\"value\":50,\"runtime\":true},{\"name\":\"VERTEX_COUNT\",\"value\":218,\"runtime\":true}],\"uniforms\":[{\"name\":\"u_Data\",\"type\":\"sampler2D\",\"format\":\"vec4[]\",\"readonly\":false,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_K\",\"type\":\"float\",\"format\":\"float\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_K2\",\"type\":\"float\",\"format\":\"float\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_Gravity\",\"type\":\"float\",\"format\":\"float\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_Speed\",\"type\":\"float\",\"format\":\"float\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]},{\"name\":\"u_MaxDisplace\",\"type\":\"float\",\"format\":\"float\",\"readonly\":true,\"writeonly\":false,\"size\":[1,1]}],\"globalDeclarations\":[],\"output\":{\"name\":\"u_Data\",\"size\":[1,1],\"length\":3840,\"outputElementsPerTexel\":4}}}',\n            dispatch: [numParticles, 1, 1],\n            maxIteration: MAX_ITERATION,\n            onCompleted: function onCompleted(finalParticleData) {\n              setTimeElapsed(window.performance.now() - timeStart); // draw with G\n\n              renderCircles(finalParticleData, numParticles); // precompiled\n              // console.log(world.getPrecompiledBundle(compute));\n              // 计算完成后销毁相关 GPU 资源\n\n              world.destroy();\n            }\n          });\n          world.setBinding(compute, 'u_Data', nodesEdgesArray);\n          world.setBinding(compute, 'u_K', Math.sqrt(numParticles * numParticles / (numParticles + 1) / 300));\n          world.setBinding(compute, 'u_K2', numParticles * numParticles / (numParticles + 1) / 300 / 300);\n          world.setBinding(compute, 'u_Gravity', 50);\n          world.setBinding(compute, 'u_Speed', 0.1);\n          world.setBinding(compute, 'u_MaxDisplace', Math.sqrt(numParticles * numParticles) / 10);\n          world.setBinding(compute, 'MAX_EDGE_PER_VERTEX', maxEdgePerVetex);\n          world.setBinding(compute, 'VERTEX_COUNT', numParticles);\n        }\n      })();\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"canvas\", {\n      id: \"application\",\n      style: {\n        display: 'none'\n      }\n    }), /*#__PURE__*/_react.default.createElement(\"div\", {\n      id: \"container\"\n    }), /*#__PURE__*/_react.default.createElement(\"div\", null, \"Elapsed time: \", timeElapsed / 1000, \"s\"), /*#__PURE__*/_react.default.createElement(\"div\", null, \"Ported from the same\", ' ', /*#__PURE__*/_react.default.createElement(\"a\", {\n      href: \"https://g6.antv.vision/en/examples/net/furchtermanLayout#fruchtermanWebWorker\"\n    }, \"example\"), ' ', \"in G6\"));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n\n  var CANVAS_HEIGHT = 600;\n  var CANVAS_WIDTH = 600;\n\n  function renderCircles(finalParticleData, numParticles) {\n    var canvas = new _gCanvas.Canvas({\n      container: 'container',\n      width: CANVAS_WIDTH,\n      height: CANVAS_HEIGHT\n    }); // draw edges\n\n    for (var i = 0; i < lineIndexBufferData.length; i += 2) {\n      var x1 = finalParticleData[lineIndexBufferData[i] * 4];\n      var y1 = finalParticleData[lineIndexBufferData[i] * 4 + 1];\n      var x2 = finalParticleData[lineIndexBufferData[i + 1] * 4];\n      var y2 = finalParticleData[lineIndexBufferData[i + 1] * 4 + 1];\n      var group = canvas.addGroup();\n      group.addShape('line', {\n        attrs: {\n          x1: convertWebGLCoord2Canvas(x1, CANVAS_WIDTH),\n          y1: convertWebGLCoord2Canvas(y1, CANVAS_HEIGHT),\n          x2: convertWebGLCoord2Canvas(x2, CANVAS_WIDTH),\n          y2: convertWebGLCoord2Canvas(y2, CANVAS_HEIGHT),\n          stroke: '#1890FF',\n          lineWidth: 1\n        }\n      });\n    } // draw nodes\n\n\n    for (var _i2 = 0; _i2 < numParticles * 4; _i2 += 4) {\n      var x = finalParticleData[_i2];\n      var y = finalParticleData[_i2 + 1];\n\n      var _group = canvas.addGroup();\n\n      _group.addShape('circle', {\n        attrs: {\n          x: convertWebGLCoord2Canvas(x, CANVAS_WIDTH),\n          y: convertWebGLCoord2Canvas(y, CANVAS_HEIGHT),\n          r: 5,\n          fill: 'red',\n          stroke: 'blue',\n          lineWidth: 2\n        }\n      });\n    }\n  }\n\n  function convertWebGLCoord2Canvas(c, size) {\n    return (c + 1) / 2 * size;\n  }\n\n  var lineIndexBufferData = [];\n  var maxEdgePerVetex; // @see https://github.com/nblintao/ParaGraphL/blob/master/sigma.layout.paragraphl.js#L192-L229\n\n  function buildTextureData(nodes, edges) {\n    var dataArray = [];\n    var nodeDict = [];\n    var mapIdPos = {};\n    var i = 0;\n\n    for (i = 0; i < nodes.length; i++) {\n      var n = nodes[i];\n      mapIdPos[n.id] = i;\n      dataArray.push(n.x);\n      dataArray.push(n.y);\n      dataArray.push(0);\n      dataArray.push(0);\n      nodeDict.push([]);\n    }\n\n    for (i = 0; i < edges.length; i++) {\n      var e = edges[i];\n      nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n      nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n      lineIndexBufferData.push(mapIdPos[e.source], mapIdPos[e.target]);\n    }\n\n    maxEdgePerVetex = 0;\n\n    for (i = 0; i < nodes.length; i++) {\n      var offset = dataArray.length;\n      var dests = nodeDict[i];\n      var len = dests.length;\n      dataArray[i * 4 + 2] = offset;\n      dataArray[i * 4 + 3] = dests.length;\n      maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n\n      for (var j = 0; j < len; ++j) {\n        var dest = dests[j];\n        dataArray.push(+dest);\n      }\n    }\n\n    while (dataArray.length % 4 !== 0) {\n      dataArray.push(0);\n    }\n\n    return new Float32Array(dataArray);\n  }\n});"}]}}}}