{"componentChunkName":"component---node-modules-antv-gatsby-theme-antv-site-templates-example-tsx","path":"/en/examples/tutorial/rendering","result":{"data":{"site":{"siteMetadata":{"title":"GWebGPU","githubUrl":"https://github.com/antvis/GWebGPUEngine","examples":[{"slug":"tutorial","icon":"gallery","title":{"zh":"示例","en":"Examples"}}],"playground":{"container":"<div style=\"min-height: 500px; justify-content: center;position: relative\" id=\"wrapper\"/>","playgroundDidMount":null,"playgroundWillUnmount":null,"dependencies":{"@antv/g-webgpu":"latest"},"htmlCodeTemplate":null}},"pathPrefix":""},"allMarkdownRemark":{"edges":[{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们的计算任务很简单，实现两个向量相加。详见"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/tutorial/add2vectors"},"children":[{"type":"text","value":"教程"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/add2vectors"},"frontmatter":{"title":"Add 2 vectors","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/add2vectors/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们的计算任务很简单，实现两个向量相加。详见"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/tutorial/add2vectors"},"children":[{"type":"text","value":"教程"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/add2vectors"},"frontmatter":{"title":"两个向量相加","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/add2vectors/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/fruchterman"},"frontmatter":{"title":"Fruchterman Layout","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/fruchterman/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/fruchterman"},"frontmatter":{"title":"Fruchterman 布局算法","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/fruchterman/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/reduce"},"frontmatter":{"title":"Reduce (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/reduce/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"只能在支持 WebGPU 的浏览器中运行，详见"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/tutorial/reduce"},"children":[{"type":"text","value":"教程"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/reduce"},"frontmatter":{"title":"Reduce (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/reduce/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/pipeline"},"frontmatter":{"title":"Pipeline","order":4,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/pipeline/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/pipeline"},"frontmatter":{"title":"Pipeline","order":4,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/pipeline/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/rendering"},"frontmatter":{"title":"渲染","order":5,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/rendering/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/rendering"},"frontmatter":{"title":"渲染","order":5,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/rendering/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"布局语法来自 ATOM: A grammar for unit visualizations"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"ATOM 语法："},{"type":"element","tagName":"a","properties":{"href":"https://intuinno.github.io/unit/#/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://intuinno.github.io/unit/#/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"中文翻译："},{"type":"element","tagName":"a","properties":{"href":"http://vis.pku.edu.cn/blog/atom_grammar/#more-9377","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"http://vis.pku.edu.cn/blog/atom_grammar/#more-9377"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"原论文中给出了布局的描述语法，但并未涉及布局间切换的动画，我们使用了 GWebGPU 的渲染能力："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"使用 instanced array 完成所有 mark 的高性能渲染"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"布局切换时在 Shader 中完成每个 mark 位置和大小的插值，目前为线性插值"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持拾取，基于 PixelPicking"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"后续可完善的方向包括："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持更多可配置的插值函数、mark 类型"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"更多布局，扩展至 3D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"渲染图例和坐标轴"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持分面，例如 "},{"type":"element","tagName":"a","properties":{"href":"https://sanddance.js.org/app/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://sanddance.js.org/app/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"配合滚动，实现 scrollytelling "},{"type":"element","tagName":"a","properties":{"href":"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"本例数据是泰坦尼克号生还者和遇难者数据，每一条形如 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Class: First, Age: Adult, Sex: Male, Survived: Yes"}]},{"type":"text","value":"。\n黄色代表生还，蓝色代表遇难。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/unitchart"},"frontmatter":{"title":"Unitchart","order":6,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/unitchart/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"布局语法来自 ATOM: A grammar for unit visualizations"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"ATOM 语法："},{"type":"element","tagName":"a","properties":{"href":"https://intuinno.github.io/unit/#/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://intuinno.github.io/unit/#/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"中文翻译："},{"type":"element","tagName":"a","properties":{"href":"http://vis.pku.edu.cn/blog/atom_grammar/#more-9377","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"http://vis.pku.edu.cn/blog/atom_grammar/#more-9377"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"原论文中给出了布局的描述语法，但并未涉及布局间切换的动画，我们使用了 GWebGPU 的渲染能力："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"使用 instanced array 完成所有 mark 的高性能渲染"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"布局切换时在 Shader 中完成每个 mark 位置和大小的插值，目前为线性插值"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持拾取，基于 PixelPicking"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"后续可完善的方向包括："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持更多可配置的插值函数、mark 类型"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"更多布局，扩展至 3D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"渲染图例和坐标轴"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持分面，例如 "},{"type":"element","tagName":"a","properties":{"href":"https://sanddance.js.org/app/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://sanddance.js.org/app/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"配合滚动，实现 scrollytelling "},{"type":"element","tagName":"a","properties":{"href":"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"本例数据是泰坦尼克号生还者和遇难者数据，每一条形如 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Class: First, Age: Adult, Sex: Male, Survived: Yes"}]},{"type":"text","value":"。\n黄色代表生还，蓝色代表遇难。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/unitchart"},"frontmatter":{"title":"Unitchart","order":6,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/unitchart/index.zh.md"}}}]}},"pageContext":{"exampleSections":{"examples":[{"relativePath":"tutorial/rendering/demo/instanced.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/tutorial/rendering/demo/instanced.tsx","order":-1,"filename":"instanced.tsx","source":"import { World } from '@antv/g-webgpu';\nimport * as dat from 'dat.gui';\nimport { quat, vec3, vec4 } from 'gl-matrix';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport Stats from 'stats.js';\n\nconst vertexShaderGLSL = `\nattribute vec3 position;\nattribute vec3 offset;\nattribute vec4 color;\nattribute vec4 orientationStart;\nattribute vec4 orientationEnd;\n\nvarying vec3 v_Position;\nvarying vec4 v_Color;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float sineTime;\nuniform float time;\n\nvoid main() {\n  v_Position = offset * max( abs( sineTime * 2.0 + 1.0 ), 0.5 ) + position;\n  vec4 orientation = normalize( mix( orientationStart, orientationEnd, sineTime ) );\n  vec3 vcV = cross( orientation.xyz, v_Position );\n  v_Position = vcV * ( 2.0 * orientation.w ) + ( cross( orientation.xyz, vcV ) * 2.0 + v_Position );\n\n  v_Color = color;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( v_Position, 1.0 );\n}\n`;\n\nconst fragmentShaderGLSL = `\nvarying vec3 v_Position;\nvarying vec4 v_Color;\n\nuniform float sineTime;\nuniform float time;\n\nvoid main() {\n  vec4 color = v_Color;\n\tcolor.r += sin(v_Position.x * 10.0 + time) * 0.5;\n  gl_FragColor = color;\n}\n`;\n\n/**\n * ported from\n * @see https://github.com/mrdoob/three.js/blob/master/examples/webgl_buffergeometry_instancing.html\n */\nconst App = React.memo(function Instanced() {\n  useEffect(() => {\n    // @ts-ignore\n    const stats = new Stats();\n    stats.showPanel(0);\n    const $stats = stats.dom;\n    $stats.style.position = 'absolute';\n    $stats.style.left = '0px';\n    $stats.style.top = '0px';\n    const $wrapper = document.getElementById('wrapper');\n    $wrapper.appendChild($stats);\n\n    const canvas = document.getElementById('application') as HTMLCanvasElement;\n    const instances = 50000;\n\n    const vector = vec4.create();\n    const positions = [];\n    const offsets = [];\n    const colors = [];\n    const orientationsStart = [];\n    const orientationsEnd = [];\n\n    positions.push(0.025, -0.025, 0);\n    positions.push(-0.025, 0.025, 0);\n    positions.push(0, 0, 0.025);\n\n    // instanced attributes\n\n    for (let i = 0; i < instances; i++) {\n      // offsets\n      offsets.push(\n        Math.random() - 0.5,\n        Math.random() - 0.5,\n        Math.random() - 0.5,\n      );\n\n      // colors\n      colors.push(Math.random(), Math.random(), Math.random(), Math.random());\n\n      // orientation start\n      vec4.set(\n        vector,\n        Math.random() * 2 - 1,\n        Math.random() * 2 - 1,\n        Math.random() * 2 - 1,\n        Math.random() * 2 - 1,\n      );\n      vec4.normalize(vector, vector);\n      orientationsStart.push(vector[0], vector[1], vector[2], vector[3]);\n\n      // orientation end\n      vec4.set(\n        vector,\n        Math.random() * 2 - 1,\n        Math.random() * 2 - 1,\n        Math.random() * 2 - 1,\n        Math.random() * 2 - 1,\n      );\n      vec4.normalize(vector, vector);\n      orientationsEnd.push(vector[0], vector[1], vector[2], vector[3]);\n    }\n\n    // create a world\n    const world = new World({\n      canvas,\n      onUpdate: () => {\n        const time = performance.now();\n\n        world.setUniform(material, 'sineTime', Math.sin(time * 0.0005));\n        world.setUniform(material, 'time', time * 0.0005);\n\n        if (stats) {\n          stats.update();\n        }\n      },\n    });\n\n    // create a camera\n    const camera = world.createCamera({\n      aspect: Math.abs(canvas.width / canvas.height),\n      angle: 50,\n      far: 10,\n      near: 1,\n    });\n    world.getCamera(camera).setPosition(0, 0, 5);\n\n    // create a scene\n    const scene = world.createScene({ camera });\n\n    // create geometry, material and attach them to mesh\n    const geometry = world.createInstancedBufferGeometry({\n      maxInstancedCount: instances,\n      vertexCount: 3,\n    });\n\n    world.setAttribute(geometry, 'position', Float32Array.from(positions), {\n      arrayStride: 4 * 3,\n      stepMode: 'vertex',\n      attributes: [\n        {\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float3',\n        },\n      ],\n    });\n\n    world.setAttribute(geometry, 'offset', Float32Array.from(offsets), {\n      arrayStride: 4 * 3,\n      stepMode: 'instance',\n      attributes: [\n        {\n          shaderLocation: 1,\n          offset: 0,\n          format: 'float3',\n        },\n      ],\n    });\n\n    world.setAttribute(geometry, 'color', Float32Array.from(colors), {\n      arrayStride: 4 * 4,\n      stepMode: 'instance',\n      attributes: [\n        {\n          shaderLocation: 2,\n          offset: 0,\n          format: 'float4',\n        },\n      ],\n    });\n\n    world.setAttribute(\n      geometry,\n      'orientationStart',\n      Float32Array.from(orientationsStart),\n      {\n        arrayStride: 4 * 4,\n        stepMode: 'instance',\n        attributes: [\n          {\n            shaderLocation: 3,\n            offset: 0,\n            format: 'float4',\n          },\n        ],\n      },\n    );\n\n    world.setAttribute(\n      geometry,\n      'orientationEnd',\n      Float32Array.from(orientationsEnd),\n      {\n        arrayStride: 4 * 4,\n        stepMode: 'instance',\n        attributes: [\n          {\n            shaderLocation: 4,\n            offset: 0,\n            format: 'float4',\n          },\n        ],\n      },\n    );\n\n    const material = world.createShaderMaterial({\n      vertexShader: vertexShaderGLSL,\n      fragmentShader: fragmentShaderGLSL,\n    });\n\n    world.setUniform(material, 'time', 0);\n    world.setUniform(material, 'sineTime', 0);\n\n    const mesh = world.createMesh({\n      geometry,\n      material,\n    });\n\n    // add meshes to current scene\n    world.add(scene, mesh);\n\n    return () => {\n      world.destroy();\n    };\n  }, []);\n\n  return (\n    <>\n      <canvas id=\"application\" width=\"600\" height=\"600\" />\n    </>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-webgpu\", \"gl-matrix\", \"react\", \"react-dom\", \"stats.js\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-webgpu\"), require(\"gl-matrix\"), require(\"react\"), require(\"react-dom\"), require(\"stats.js\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gWebgpu, global.glMatrix, global.react, global.reactDom, global.stats);\n    global.instanced = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gWebgpu, _glMatrix, _react, _reactDom, _stats) {\n  \"use strict\";\n\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n  _stats = _interopRequireDefault(_stats);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  var vertexShaderGLSL = \"\\nattribute vec3 position;\\nattribute vec3 offset;\\nattribute vec4 color;\\nattribute vec4 orientationStart;\\nattribute vec4 orientationEnd;\\n\\nvarying vec3 v_Position;\\nvarying vec4 v_Color;\\n\\nuniform mat4 projectionMatrix;\\nuniform mat4 modelViewMatrix;\\nuniform float sineTime;\\nuniform float time;\\n\\nvoid main() {\\n  v_Position = offset * max( abs( sineTime * 2.0 + 1.0 ), 0.5 ) + position;\\n  vec4 orientation = normalize( mix( orientationStart, orientationEnd, sineTime ) );\\n  vec3 vcV = cross( orientation.xyz, v_Position );\\n  v_Position = vcV * ( 2.0 * orientation.w ) + ( cross( orientation.xyz, vcV ) * 2.0 + v_Position );\\n\\n  v_Color = color;\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( v_Position, 1.0 );\\n}\\n\";\n  var fragmentShaderGLSL = \"\\nvarying vec3 v_Position;\\nvarying vec4 v_Color;\\n\\nuniform float sineTime;\\nuniform float time;\\n\\nvoid main() {\\n  vec4 color = v_Color;\\n\\tcolor.r += sin(v_Position.x * 10.0 + time) * 0.5;\\n  gl_FragColor = color;\\n}\\n\";\n  /**\n   * ported from\n   * @see https://github.com/mrdoob/three.js/blob/master/examples/webgl_buffergeometry_instancing.html\n   */\n\n  var App = /*#__PURE__*/_react.default.memo(function Instanced() {\n    (0, _react.useEffect)(function () {\n      // @ts-ignore\n      var stats = new _stats.default();\n      stats.showPanel(0);\n      var $stats = stats.dom;\n      $stats.style.position = 'absolute';\n      $stats.style.left = '0px';\n      $stats.style.top = '0px';\n      var $wrapper = document.getElementById('wrapper');\n      $wrapper.appendChild($stats);\n      var canvas = document.getElementById('application');\n      var instances = 50000;\n\n      var vector = _glMatrix.vec4.create();\n\n      var positions = [];\n      var offsets = [];\n      var colors = [];\n      var orientationsStart = [];\n      var orientationsEnd = [];\n      positions.push(0.025, -0.025, 0);\n      positions.push(-0.025, 0.025, 0);\n      positions.push(0, 0, 0.025); // instanced attributes\n\n      for (var i = 0; i < instances; i++) {\n        // offsets\n        offsets.push(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5); // colors\n\n        colors.push(Math.random(), Math.random(), Math.random(), Math.random()); // orientation start\n\n        _glMatrix.vec4.set(vector, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n\n        _glMatrix.vec4.normalize(vector, vector);\n\n        orientationsStart.push(vector[0], vector[1], vector[2], vector[3]); // orientation end\n\n        _glMatrix.vec4.set(vector, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n\n        _glMatrix.vec4.normalize(vector, vector);\n\n        orientationsEnd.push(vector[0], vector[1], vector[2], vector[3]);\n      } // create a world\n\n\n      var world = new _gWebgpu.World({\n        canvas: canvas,\n        onUpdate: function onUpdate() {\n          var time = performance.now();\n          world.setUniform(material, 'sineTime', Math.sin(time * 0.0005));\n          world.setUniform(material, 'time', time * 0.0005);\n\n          if (stats) {\n            stats.update();\n          }\n        }\n      }); // create a camera\n\n      var camera = world.createCamera({\n        aspect: Math.abs(canvas.width / canvas.height),\n        angle: 50,\n        far: 10,\n        near: 1\n      });\n      world.getCamera(camera).setPosition(0, 0, 5); // create a scene\n\n      var scene = world.createScene({\n        camera: camera\n      }); // create geometry, material and attach them to mesh\n\n      var geometry = world.createInstancedBufferGeometry({\n        maxInstancedCount: instances,\n        vertexCount: 3\n      });\n      world.setAttribute(geometry, 'position', Float32Array.from(positions), {\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float3'\n        }]\n      });\n      world.setAttribute(geometry, 'offset', Float32Array.from(offsets), {\n        arrayStride: 4 * 3,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 1,\n          offset: 0,\n          format: 'float3'\n        }]\n      });\n      world.setAttribute(geometry, 'color', Float32Array.from(colors), {\n        arrayStride: 4 * 4,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 2,\n          offset: 0,\n          format: 'float4'\n        }]\n      });\n      world.setAttribute(geometry, 'orientationStart', Float32Array.from(orientationsStart), {\n        arrayStride: 4 * 4,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 3,\n          offset: 0,\n          format: 'float4'\n        }]\n      });\n      world.setAttribute(geometry, 'orientationEnd', Float32Array.from(orientationsEnd), {\n        arrayStride: 4 * 4,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 4,\n          offset: 0,\n          format: 'float4'\n        }]\n      });\n      var material = world.createShaderMaterial({\n        vertexShader: vertexShaderGLSL,\n        fragmentShader: fragmentShaderGLSL\n      });\n      world.setUniform(material, 'time', 0);\n      world.setUniform(material, 'sineTime', 0);\n      var mesh = world.createMesh({\n        geometry: geometry,\n        material: material\n      }); // add meshes to current scene\n\n      world.add(scene, mesh);\n      return function () {\n        world.destroy();\n      };\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"canvas\", {\n      id: \"application\",\n      width: \"600\",\n      height: \"600\"\n    }));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n});"},{"relativePath":"tutorial/rendering/demo/cube.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/tutorial/rendering/demo/cube.tsx","order":0,"filename":"cube.tsx","title":"A Rotating Cube","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","source":"import { World } from '@antv/g-webgpu';\nimport * as dat from 'dat.gui';\nimport { quat, vec3, vec4 } from 'gl-matrix';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport Stats from 'stats.js';\n\nconst App = React.memo(function RotatingCube() {\n  useEffect(() => {\n    // @ts-ignore\n    const stats = new Stats();\n    stats.showPanel(0);\n    const $stats = stats.dom;\n    $stats.style.position = 'absolute';\n    $stats.style.left = '0px';\n    $stats.style.top = '0px';\n    const $wrapper = document.getElementById('wrapper');\n    $wrapper.appendChild($stats);\n\n    let meshTransform;\n\n    const canvas = document.getElementById('application') as HTMLCanvasElement;\n    const world = new World({\n      canvas,\n      onUpdate: () => {\n        meshTransform.rotate(quat.fromEuler(quat.create(), 0, 1, 0));\n\n        if (stats) {\n          stats.update();\n        }\n      },\n    });\n\n    // create a camera\n    const camera = world.createCamera({\n      aspect: Math.abs(canvas.width / canvas.height),\n      angle: 72,\n      far: 100,\n      near: 1,\n    });\n    world.getCamera(camera).setPosition(0, 5, 5);\n\n    // create a scene\n    const scene = world.createScene({ camera });\n\n    // create geometry, material and attach them to mesh\n    const boxGeometry = world.createBoxGeometry({\n      halfExtents: vec3.fromValues(1, 1, 1),\n    });\n    const material = world.createBasicMaterial();\n    world.setUniform(material, 'color', vec4.fromValues(1, 0, 0, 1));\n\n    const mesh = world.createMesh({\n      geometry: boxGeometry,\n      material,\n    });\n    meshTransform = world.getTransform(mesh);\n    meshTransform.translate(vec3.fromValues(-2.5, 0, 0));\n\n    const material2 = world.createBasicMaterial();\n    world.setUniform(material2, 'color', vec4.fromValues(0, 0, 0, 0));\n\n    const mesh2 = world.createMesh({\n      geometry: boxGeometry,\n      material: material2,\n    });\n    const mesh2Transform = world.getTransform(mesh2);\n    mesh2Transform.translate(vec3.fromValues(2.5, 0, 0));\n\n    // add meshes to current scene\n    world.add(scene, mesh);\n    world.add(scene, mesh2);\n\n    // GUI\n    const gui = new dat.GUI({ autoPlace: false });\n    $wrapper.appendChild(gui.domElement);\n    const cubeFolder = gui.addFolder('cube');\n\n    const cube = {\n      scale: 1,\n      color: [255, 255, 255],\n    };\n    cubeFolder.add(cube, 'scale', 0.1, 5.0).onChange((size) => {\n      meshTransform.localScale = vec3.fromValues(1, 1, 1);\n      meshTransform.scale(vec3.fromValues(size, size, size));\n    });\n    cubeFolder.addColor(cube, 'color').onChange((color) => {\n      world.setUniform(\n        material,\n        'color',\n        vec4.fromValues(color[0] / 255, color[1] / 255, color[2] / 255, 1),\n      );\n    });\n\n    return () => {\n      world.destroy();\n    };\n  }, []);\n\n  return (\n    <>\n      <canvas id=\"application\" width=\"600\" height=\"600\" />\n    </>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-webgpu\", \"dat.gui\", \"gl-matrix\", \"react\", \"react-dom\", \"stats.js\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-webgpu\"), require(\"dat.gui\"), require(\"gl-matrix\"), require(\"react\"), require(\"react-dom\"), require(\"stats.js\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gWebgpu, global.dat, global.glMatrix, global.react, global.reactDom, global.stats);\n    global.cube = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gWebgpu, dat, _glMatrix, _react, _reactDom, _stats) {\n  \"use strict\";\n\n  dat = _interopRequireWildcard(dat);\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n  _stats = _interopRequireDefault(_stats);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  var App = /*#__PURE__*/_react.default.memo(function RotatingCube() {\n    (0, _react.useEffect)(function () {\n      // @ts-ignore\n      var stats = new _stats.default();\n      stats.showPanel(0);\n      var $stats = stats.dom;\n      $stats.style.position = 'absolute';\n      $stats.style.left = '0px';\n      $stats.style.top = '0px';\n      var $wrapper = document.getElementById('wrapper');\n      $wrapper.appendChild($stats);\n      var meshTransform;\n      var canvas = document.getElementById('application');\n      var world = new _gWebgpu.World({\n        canvas: canvas,\n        onUpdate: function onUpdate() {\n          meshTransform.rotate(_glMatrix.quat.fromEuler(_glMatrix.quat.create(), 0, 1, 0));\n\n          if (stats) {\n            stats.update();\n          }\n        }\n      }); // create a camera\n\n      var camera = world.createCamera({\n        aspect: Math.abs(canvas.width / canvas.height),\n        angle: 72,\n        far: 100,\n        near: 1\n      });\n      world.getCamera(camera).setPosition(0, 5, 5); // create a scene\n\n      var scene = world.createScene({\n        camera: camera\n      }); // create geometry, material and attach them to mesh\n\n      var boxGeometry = world.createBoxGeometry({\n        halfExtents: _glMatrix.vec3.fromValues(1, 1, 1)\n      });\n      var material = world.createBasicMaterial();\n      world.setUniform(material, 'color', _glMatrix.vec4.fromValues(1, 0, 0, 1));\n      var mesh = world.createMesh({\n        geometry: boxGeometry,\n        material: material\n      });\n      meshTransform = world.getTransform(mesh);\n      meshTransform.translate(_glMatrix.vec3.fromValues(-2.5, 0, 0));\n      var material2 = world.createBasicMaterial();\n      world.setUniform(material2, 'color', _glMatrix.vec4.fromValues(0, 0, 0, 0));\n      var mesh2 = world.createMesh({\n        geometry: boxGeometry,\n        material: material2\n      });\n      var mesh2Transform = world.getTransform(mesh2);\n      mesh2Transform.translate(_glMatrix.vec3.fromValues(2.5, 0, 0)); // add meshes to current scene\n\n      world.add(scene, mesh);\n      world.add(scene, mesh2); // GUI\n\n      var gui = new dat.GUI({\n        autoPlace: false\n      });\n      $wrapper.appendChild(gui.domElement);\n      var cubeFolder = gui.addFolder('cube');\n      var cube = {\n        scale: 1,\n        color: [255, 255, 255]\n      };\n      cubeFolder.add(cube, 'scale', 0.1, 5.0).onChange(function (size) {\n        meshTransform.localScale = _glMatrix.vec3.fromValues(1, 1, 1);\n        meshTransform.scale(_glMatrix.vec3.fromValues(size, size, size));\n      });\n      cubeFolder.addColor(cube, 'color').onChange(function (color) {\n        world.setUniform(material, 'color', _glMatrix.vec4.fromValues(color[0] / 255, color[1] / 255, color[2] / 255, 1));\n      });\n      return function () {\n        world.destroy();\n      };\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"canvas\", {\n      id: \"application\",\n      width: \"600\",\n      height: \"600\"\n    }));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n});"}]}}}}