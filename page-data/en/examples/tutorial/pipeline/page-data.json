{"componentChunkName":"component---node-modules-antv-gatsby-theme-antv-site-templates-example-tsx","path":"/en/examples/tutorial/pipeline","result":{"data":{"site":{"siteMetadata":{"title":"GWebGPU","githubUrl":"https://github.com/antvis/GWebGPUEngine","examples":[{"slug":"tutorial","icon":"gallery","title":{"zh":"示例","en":"Examples"}}],"playground":{"container":"<div style=\"min-height: 500px; justify-content: center;position: relative\" id=\"wrapper\"/>","playgroundDidMount":null,"playgroundWillUnmount":null,"dependencies":{"@antv/g-webgpu":"latest"},"htmlCodeTemplate":null}},"pathPrefix":""},"allMarkdownRemark":{"edges":[{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们的计算任务很简单，实现两个向量相加。详见"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/tutorial/add2vectors"},"children":[{"type":"text","value":"教程"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/add2vectors"},"frontmatter":{"title":"Add 2 vectors","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/add2vectors/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们的计算任务很简单，实现两个向量相加。详见"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/tutorial/add2vectors"},"children":[{"type":"text","value":"教程"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/add2vectors"},"frontmatter":{"title":"两个向量相加","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/add2vectors/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/fruchterman"},"frontmatter":{"title":"Fruchterman Layout","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/fruchterman/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/fruchterman"},"frontmatter":{"title":"Fruchterman 布局算法","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/fruchterman/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/reduce"},"frontmatter":{"title":"Reduce (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/reduce/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"只能在支持 WebGPU 的浏览器中运行，详见"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/tutorial/reduce"},"children":[{"type":"text","value":"教程"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/reduce"},"frontmatter":{"title":"Reduce (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/reduce/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/pipeline"},"frontmatter":{"title":"Pipeline","order":4,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/pipeline/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/pipeline"},"frontmatter":{"title":"Pipeline","order":4,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/pipeline/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/rendering"},"frontmatter":{"title":"渲染","order":5,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/rendering/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/rendering"},"frontmatter":{"title":"渲染","order":5,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/rendering/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"布局语法来自 ATOM: A grammar for unit visualizations"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"ATOM 语法："},{"type":"element","tagName":"a","properties":{"href":"https://intuinno.github.io/unit/#/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://intuinno.github.io/unit/#/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"中文翻译："},{"type":"element","tagName":"a","properties":{"href":"http://vis.pku.edu.cn/blog/atom_grammar/#more-9377","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"http://vis.pku.edu.cn/blog/atom_grammar/#more-9377"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"原论文中给出了布局的描述语法，但并未涉及布局间切换的动画，我们使用了 GWebGPU 的渲染能力："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"使用 instanced array 完成所有 mark 的高性能渲染"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"布局切换时在 Shader 中完成每个 mark 位置和大小的插值，目前为线性插值"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持拾取，基于 PixelPicking"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"后续可完善的方向包括："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持更多可配置的插值函数、mark 类型"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"更多布局，扩展至 3D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"渲染图例和坐标轴"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持分面，例如 "},{"type":"element","tagName":"a","properties":{"href":"https://sanddance.js.org/app/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://sanddance.js.org/app/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"配合滚动，实现 scrollytelling "},{"type":"element","tagName":"a","properties":{"href":"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"本例数据是泰坦尼克号生还者和遇难者数据，每一条形如 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Class: First, Age: Adult, Sex: Male, Survived: Yes"}]},{"type":"text","value":"。\n黄色代表生还，蓝色代表遇难。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/tutorial/unitchart"},"frontmatter":{"title":"Unitchart","order":6,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/unitchart/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"布局语法来自 ATOM: A grammar for unit visualizations"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"ATOM 语法："},{"type":"element","tagName":"a","properties":{"href":"https://intuinno.github.io/unit/#/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://intuinno.github.io/unit/#/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"中文翻译："},{"type":"element","tagName":"a","properties":{"href":"http://vis.pku.edu.cn/blog/atom_grammar/#more-9377","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"http://vis.pku.edu.cn/blog/atom_grammar/#more-9377"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"原论文中给出了布局的描述语法，但并未涉及布局间切换的动画，我们使用了 GWebGPU 的渲染能力："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"使用 instanced array 完成所有 mark 的高性能渲染"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"布局切换时在 Shader 中完成每个 mark 位置和大小的插值，目前为线性插值"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持拾取，基于 PixelPicking"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"后续可完善的方向包括："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持更多可配置的插值函数、mark 类型"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"更多布局，扩展至 3D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"渲染图例和坐标轴"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持分面，例如 "},{"type":"element","tagName":"a","properties":{"href":"https://sanddance.js.org/app/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://sanddance.js.org/app/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"配合滚动，实现 scrollytelling "},{"type":"element","tagName":"a","properties":{"href":"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"本例数据是泰坦尼克号生还者和遇难者数据，每一条形如 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Class: First, Age: Adult, Sex: Male, Survived: Yes"}]},{"type":"text","value":"。\n黄色代表生还，蓝色代表遇难。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/tutorial/unitchart"},"frontmatter":{"title":"Unitchart","order":6,"icon":null},"parent":{"__typename":"File","relativePath":"tutorial/unitchart/index.zh.md"}}}]}},"pageContext":{"exampleSections":{"examples":[{"relativePath":"tutorial/pipeline/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/tutorial/pipeline/demo/index.tsx","order":0,"filename":"index.tsx","title":"Fruchterman 布局算法","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","source":"import { Canvas } from '@antv/g-canvas';\nimport { World } from '@antv/g-webgpu';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst gCode = `\nimport { globalInvocationID } from 'g-webgpu';\n\nconst MAX_EDGE_PER_VERTEX;\nconst VERTEX_COUNT;\n\n@numthreads(1, 1, 1)\nclass Fruchterman {\n  @in @out\n  u_Data: vec4[];\n\n  @in\n  u_K: float;\n\n  @in\n  u_K2: float;\n\n  @in\n  u_Gravity: float;\n\n  @in\n  u_Speed: float;\n\n  @in\n  u_MaxDisplace: float;\n\n  @in\n  u_Center: vec2[];\n\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      if (i != j) {\n        const nextNode = this.u_Data[j];\n        const xDist = currentNode[0] - nextNode[0];\n        const yDist = currentNode[1] - nextNode[1];\n        const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\n        if (dist > 0.0) {\n          const repulsiveF = this.u_K2 / dist;\n          dx += xDist / dist * repulsiveF;\n          dy += yDist / dist * repulsiveF;\n        }\n      }\n    }\n    return [dx, dy];\n  }\n\n  calcGravity(currentNode: vec4): vec2 {\n    const d = sqrt(currentNode[0] * currentNode[0] + currentNode[1] * currentNode[1]);\n    const gf = 0.01 * this.u_K * this.u_Gravity * d;\n    return [gf * currentNode[0] / d, gf * currentNode[1] / d];\n  }\n\n  calcAttractive(currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    const arr_offset = int(floor(currentNode[2] + 0.5));\n    const length = int(floor(currentNode[3] + 0.5));\n    const node_buffer: vec4;\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\n      if (p >= length) break;\n      const arr_idx = arr_offset + p;\n      // when arr_idx % 4 == 0 update currentNodedx_buffer\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\n      if (p == 0 || buf_offset == 0) {\n        node_buffer = this.u_Data[int(arr_idx / 4)];\n      }\n      const float_j = buf_offset == 0 ? node_buffer[0] :\n                      buf_offset == 1 ? node_buffer[1] :\n                      buf_offset == 2 ? node_buffer[2] :\n                                        node_buffer[3];\n      const nextNode = this.u_Data[int(float_j)];\n      const xDist = currentNode[0] - nextNode[0];\n      const yDist = currentNode[1] - nextNode[1];\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\n      const attractiveF = dist * dist / this.u_K;\n      if (dist > 0.0) {\n        dx -= xDist / dist * attractiveF;\n        dy -= yDist / dist * attractiveF;\n      }\n    }\n    return [dx, dy];\n  }\n\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const currentNode = this.u_Data[i];\n\n    let dx = 0, dy = 0;\n\n    if (i >= VERTEX_COUNT) {\n      this.u_Data[i] = currentNode;\n      return;\n    }\n\n    // repulsive\n    const repulsive = this.calcRepulsive(i, currentNode);\n    dx += repulsive[0];\n    dy += repulsive[1];\n\n    // attractive\n    const attractive = this.calcAttractive(currentNode);\n    dx += attractive[0];\n    dy += attractive[1];\n\n    // gravity\n    const gravity = this.calcGravity(currentNode);\n    dx -= gravity[0];\n    dy -= gravity[1];\n\n    // speed\n    dx *= this.u_Speed;\n    dy *= this.u_Speed;\n\n    // move\n    const distLength = sqrt(dx * dx + dy * dy);\n    if (distLength > 0.0) {\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\n\n      this.u_Data[i] = [\n        currentNode[0] + dx / distLength * limitedDist,\n        currentNode[1] + dy / distLength * limitedDist,\n        currentNode[2],\n        currentNode[3]\n      ];\n    }\n  }\n}\n`;\n\nconst gCode2 = `\nimport { globalInvocationID } from 'g-webgpu';\n\nconst VERTEX_COUNT;\n\n@numthreads(1, 1, 1)\nclass CalcCenter {\n  @in\n  u_Data: vec4[];\n\n  @out\n  u_Center: vec2[];\n\n  @main\n  compute() {\n    let sumX = 0, sumY = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      sumX += this.u_Data[j].x;\n      sumY += this.u_Data[j].y;\n    }\n\n    this.u_Center[0] = [sumX / VERTEX_COUNT, sumY/ VERTEX_COUNT];\n  }\n}\n`;\n\nconst MAX_ITERATION = 8000;\n\nconst App = React.memo(function Fruchterman() {\n  const [timeElapsed, setTimeElapsed] = useState(0);\n  useEffect(() => {\n    (async () => {\n      // @see https://g6.antv.vision/en/examples/net/forceDirected/#basicForceDirected\n      const data = await (\n        await fetch(\n          'https://gw.alipayobjects.com/os/basement_prod/7bacd7d1-4119-4ac1-8be3-4c4b9bcbc25f.json',\n        )\n      ).json();\n\n      const nodes = data.nodes.map((n) => ({\n        x: (Math.random() * 2 - 1) / 10,\n        y: (Math.random() * 2 - 1) / 10,\n        id: n.id,\n      }));\n      const edges = data.edges;\n      const numParticles = nodes.length;\n      const nodesEdgesArray = buildTextureData(nodes, edges);\n\n      const world = new World({\n        engineOptions: {\n          supportCompute: true,\n        },\n      });\n\n      const timeStart = window.performance.now();\n      const compute = world.createComputePipeline({\n        shader: gCode,\n        dispatch: [numParticles, 1, 1],\n        maxIteration: MAX_ITERATION,\n        onIterationCompleted: async () => {\n          world.setBinding(compute2, 'u_Data', {\n            entity: compute,\n          });\n        },\n        onCompleted: (finalParticleData) => {\n          setTimeElapsed(window.performance.now() - timeStart);\n          // draw with G\n          renderCircles(finalParticleData, numParticles);\n        },\n      });\n\n      world.setBinding(compute, 'u_Data', nodesEdgesArray);\n      world.setBinding(\n        compute,\n        'u_K',\n        Math.sqrt((numParticles * numParticles) / (numParticles + 1) / 300),\n      );\n      world.setBinding(\n        compute,\n        'u_K2',\n        (numParticles * numParticles) / (numParticles + 1) / 300 / 300,\n      );\n      world.setBinding(compute, 'u_Gravity', 50);\n      world.setBinding(compute, 'u_Speed', 0.1);\n      world.setBinding(\n        compute,\n        'u_MaxDisplace',\n        Math.sqrt(numParticles * numParticles) / 10,\n      );\n      world.setBinding(compute, 'MAX_EDGE_PER_VERTEX', maxEdgePerVetex);\n      world.setBinding(compute, 'VERTEX_COUNT', numParticles);\n      world.setBinding(compute, 'u_Center', [0, 0]);\n\n      const compute2 = world.createComputePipeline({\n        shader: gCode2,\n        dispatch: [1, 1, 1],\n        maxIteration: MAX_ITERATION,\n        onIterationCompleted: async () => {\n          world.setBinding(compute, 'u_Center', {\n            entity: compute2,\n          });\n        },\n        onCompleted: (finalParticleData) => {\n          console.log('center: ', finalParticleData);\n          world.destroy();\n        },\n      });\n      world.setBinding(compute2, 'u_Data', nodesEdgesArray);\n      world.setBinding(compute2, 'VERTEX_COUNT', numParticles);\n    })();\n  }, []);\n\n  return (\n    <>\n      <canvas id=\"application\" style={{ display: 'none' }} />\n      <div id=\"container\" />\n      <div>Elapsed time: {timeElapsed / 1000}s</div>\n      <div>\n        Ported from the same{' '}\n        <a href=\"https://g6.antv.vision/en/examples/net/furchtermanLayout#fruchtermanWebWorker\">\n          example\n        </a>{' '}\n        in G6\n      </div>\n    </>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n\nconst CANVAS_HEIGHT = 600;\nconst CANVAS_WIDTH = 600;\nfunction renderCircles(finalParticleData, numParticles) {\n  const canvas = new Canvas({\n    container: 'container',\n    width: CANVAS_WIDTH,\n    height: CANVAS_HEIGHT,\n  });\n\n  // draw edges\n  for (let i = 0; i < lineIndexBufferData.length; i += 2) {\n    const x1 = finalParticleData[lineIndexBufferData[i] * 4];\n    const y1 = finalParticleData[lineIndexBufferData[i] * 4 + 1];\n    const x2 = finalParticleData[lineIndexBufferData[i + 1] * 4];\n    const y2 = finalParticleData[lineIndexBufferData[i + 1] * 4 + 1];\n    const group = canvas.addGroup();\n    group.addShape('line', {\n      attrs: {\n        x1: convertWebGLCoord2Canvas(x1, CANVAS_WIDTH),\n        y1: convertWebGLCoord2Canvas(y1, CANVAS_HEIGHT),\n        x2: convertWebGLCoord2Canvas(x2, CANVAS_WIDTH),\n        y2: convertWebGLCoord2Canvas(y2, CANVAS_HEIGHT),\n        stroke: '#1890FF',\n        lineWidth: 1,\n      },\n    });\n  }\n\n  let sumx = 0;\n  let sumy = 0;\n  // draw nodes\n  for (let i = 0; i < numParticles * 4; i += 4) {\n    const x = finalParticleData[i];\n    const y = finalParticleData[i + 1];\n\n    sumx += x;\n    sumy += y;\n    const group = canvas.addGroup();\n    group.addShape('circle', {\n      attrs: {\n        x: convertWebGLCoord2Canvas(x, CANVAS_WIDTH),\n        y: convertWebGLCoord2Canvas(y, CANVAS_HEIGHT),\n        r: 5,\n        fill: 'red',\n        stroke: 'blue',\n        lineWidth: 2,\n      },\n    });\n  }\n}\n\nfunction convertWebGLCoord2Canvas(c: number, size: number) {\n  return ((c + 1) / 2) * size;\n}\n\nconst lineIndexBufferData = [];\nlet maxEdgePerVetex;\n// @see https://github.com/nblintao/ParaGraphL/blob/master/sigma.layout.paragraphl.js#L192-L229\nfunction buildTextureData(nodes, edges) {\n  const dataArray = [];\n  const nodeDict = [];\n  const mapIdPos = {};\n  let i = 0;\n  for (i = 0; i < nodes.length; i++) {\n    const n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n  for (i = 0; i < edges.length; i++) {\n    const e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    lineIndexBufferData.push(mapIdPos[e.source], mapIdPos[e.target]);\n  }\n\n  maxEdgePerVetex = 0;\n  for (i = 0; i < nodes.length; i++) {\n    const offset = dataArray.length;\n    const dests = nodeDict[i];\n    const len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = dests.length;\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n    for (let j = 0; j < len; ++j) {\n      const dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n  return new Float32Array(dataArray);\n}\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-canvas\", \"@antv/g-webgpu\", \"react\", \"react-dom\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-canvas\"), require(\"@antv/g-webgpu\"), require(\"react\"), require(\"react-dom\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gCanvas, global.gWebgpu, global.react, global.reactDom);\n    global.index = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gCanvas, _gWebgpu, _react, _reactDom) {\n  \"use strict\";\n\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  var gCode = \"\\nimport { globalInvocationID } from 'g-webgpu';\\n\\nconst MAX_EDGE_PER_VERTEX;\\nconst VERTEX_COUNT;\\n\\n@numthreads(1, 1, 1)\\nclass Fruchterman {\\n  @in @out\\n  u_Data: vec4[];\\n\\n  @in\\n  u_K: float;\\n\\n  @in\\n  u_K2: float;\\n\\n  @in\\n  u_Gravity: float;\\n\\n  @in\\n  u_Speed: float;\\n\\n  @in\\n  u_MaxDisplace: float;\\n\\n  @in\\n  u_Center: vec2[];\\n\\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\\n    let dx = 0, dy = 0;\\n    for (let j = 0; j < VERTEX_COUNT; j++) {\\n      if (i != j) {\\n        const nextNode = this.u_Data[j];\\n        const xDist = currentNode[0] - nextNode[0];\\n        const yDist = currentNode[1] - nextNode[1];\\n        const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\\n        if (dist > 0.0) {\\n          const repulsiveF = this.u_K2 / dist;\\n          dx += xDist / dist * repulsiveF;\\n          dy += yDist / dist * repulsiveF;\\n        }\\n      }\\n    }\\n    return [dx, dy];\\n  }\\n\\n  calcGravity(currentNode: vec4): vec2 {\\n    const d = sqrt(currentNode[0] * currentNode[0] + currentNode[1] * currentNode[1]);\\n    const gf = 0.01 * this.u_K * this.u_Gravity * d;\\n    return [gf * currentNode[0] / d, gf * currentNode[1] / d];\\n  }\\n\\n  calcAttractive(currentNode: vec4): vec2 {\\n    let dx = 0, dy = 0;\\n    const arr_offset = int(floor(currentNode[2] + 0.5));\\n    const length = int(floor(currentNode[3] + 0.5));\\n    const node_buffer: vec4;\\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\\n      if (p >= length) break;\\n      const arr_idx = arr_offset + p;\\n      // when arr_idx % 4 == 0 update currentNodedx_buffer\\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\\n      if (p == 0 || buf_offset == 0) {\\n        node_buffer = this.u_Data[int(arr_idx / 4)];\\n      }\\n      const float_j = buf_offset == 0 ? node_buffer[0] :\\n                      buf_offset == 1 ? node_buffer[1] :\\n                      buf_offset == 2 ? node_buffer[2] :\\n                                        node_buffer[3];\\n      const nextNode = this.u_Data[int(float_j)];\\n      const xDist = currentNode[0] - nextNode[0];\\n      const yDist = currentNode[1] - nextNode[1];\\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\\n      const attractiveF = dist * dist / this.u_K;\\n      if (dist > 0.0) {\\n        dx -= xDist / dist * attractiveF;\\n        dy -= yDist / dist * attractiveF;\\n      }\\n    }\\n    return [dx, dy];\\n  }\\n\\n  @main\\n  compute() {\\n    const i = globalInvocationID.x;\\n    const currentNode = this.u_Data[i];\\n\\n    let dx = 0, dy = 0;\\n\\n    if (i >= VERTEX_COUNT) {\\n      this.u_Data[i] = currentNode;\\n      return;\\n    }\\n\\n    // repulsive\\n    const repulsive = this.calcRepulsive(i, currentNode);\\n    dx += repulsive[0];\\n    dy += repulsive[1];\\n\\n    // attractive\\n    const attractive = this.calcAttractive(currentNode);\\n    dx += attractive[0];\\n    dy += attractive[1];\\n\\n    // gravity\\n    const gravity = this.calcGravity(currentNode);\\n    dx -= gravity[0];\\n    dy -= gravity[1];\\n\\n    // speed\\n    dx *= this.u_Speed;\\n    dy *= this.u_Speed;\\n\\n    // move\\n    const distLength = sqrt(dx * dx + dy * dy);\\n    if (distLength > 0.0) {\\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\\n\\n      this.u_Data[i] = [\\n        currentNode[0] + dx / distLength * limitedDist,\\n        currentNode[1] + dy / distLength * limitedDist,\\n        currentNode[2],\\n        currentNode[3]\\n      ];\\n    }\\n  }\\n}\\n\";\n  var gCode2 = \"\\nimport { globalInvocationID } from 'g-webgpu';\\n\\nconst VERTEX_COUNT;\\n\\n@numthreads(1, 1, 1)\\nclass CalcCenter {\\n  @in\\n  u_Data: vec4[];\\n\\n  @out\\n  u_Center: vec2[];\\n\\n  @main\\n  compute() {\\n    let sumX = 0, sumY = 0;\\n    for (let j = 0; j < VERTEX_COUNT; j++) {\\n      sumX += this.u_Data[j].x;\\n      sumY += this.u_Data[j].y;\\n    }\\n\\n    this.u_Center[0] = [sumX / VERTEX_COUNT, sumY/ VERTEX_COUNT];\\n  }\\n}\\n\";\n  var MAX_ITERATION = 8000;\n\n  var App = /*#__PURE__*/_react.default.memo(function Fruchterman() {\n    var _useState = (0, _react.useState)(0),\n        _useState2 = _slicedToArray(_useState, 2),\n        timeElapsed = _useState2[0],\n        setTimeElapsed = _useState2[1];\n\n    (0, _react.useEffect)(function () {\n      (async function () {\n        // @see https://g6.antv.vision/en/examples/net/forceDirected/#basicForceDirected\n        var data = await (await fetch('https://gw.alipayobjects.com/os/basement_prod/7bacd7d1-4119-4ac1-8be3-4c4b9bcbc25f.json')).json();\n        var nodes = data.nodes.map(function (n) {\n          return {\n            x: (Math.random() * 2 - 1) / 10,\n            y: (Math.random() * 2 - 1) / 10,\n            id: n.id\n          };\n        });\n        var edges = data.edges;\n        var numParticles = nodes.length;\n        var nodesEdgesArray = buildTextureData(nodes, edges);\n        var world = new _gWebgpu.World({\n          engineOptions: {\n            supportCompute: true\n          }\n        });\n        var timeStart = window.performance.now();\n        var compute = world.createComputePipeline({\n          shader: gCode,\n          dispatch: [numParticles, 1, 1],\n          maxIteration: MAX_ITERATION,\n          onIterationCompleted: async function onIterationCompleted() {\n            world.setBinding(compute2, 'u_Data', {\n              entity: compute\n            });\n          },\n          onCompleted: function onCompleted(finalParticleData) {\n            setTimeElapsed(window.performance.now() - timeStart); // draw with G\n\n            renderCircles(finalParticleData, numParticles);\n          }\n        });\n        world.setBinding(compute, 'u_Data', nodesEdgesArray);\n        world.setBinding(compute, 'u_K', Math.sqrt(numParticles * numParticles / (numParticles + 1) / 300));\n        world.setBinding(compute, 'u_K2', numParticles * numParticles / (numParticles + 1) / 300 / 300);\n        world.setBinding(compute, 'u_Gravity', 50);\n        world.setBinding(compute, 'u_Speed', 0.1);\n        world.setBinding(compute, 'u_MaxDisplace', Math.sqrt(numParticles * numParticles) / 10);\n        world.setBinding(compute, 'MAX_EDGE_PER_VERTEX', maxEdgePerVetex);\n        world.setBinding(compute, 'VERTEX_COUNT', numParticles);\n        world.setBinding(compute, 'u_Center', [0, 0]);\n        var compute2 = world.createComputePipeline({\n          shader: gCode2,\n          dispatch: [1, 1, 1],\n          maxIteration: MAX_ITERATION,\n          onIterationCompleted: async function onIterationCompleted() {\n            world.setBinding(compute, 'u_Center', {\n              entity: compute2\n            });\n          },\n          onCompleted: function onCompleted(finalParticleData) {\n            console.log('center: ', finalParticleData);\n            world.destroy();\n          }\n        });\n        world.setBinding(compute2, 'u_Data', nodesEdgesArray);\n        world.setBinding(compute2, 'VERTEX_COUNT', numParticles);\n      })();\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"canvas\", {\n      id: \"application\",\n      style: {\n        display: 'none'\n      }\n    }), /*#__PURE__*/_react.default.createElement(\"div\", {\n      id: \"container\"\n    }), /*#__PURE__*/_react.default.createElement(\"div\", null, \"Elapsed time: \", timeElapsed / 1000, \"s\"), /*#__PURE__*/_react.default.createElement(\"div\", null, \"Ported from the same\", ' ', /*#__PURE__*/_react.default.createElement(\"a\", {\n      href: \"https://g6.antv.vision/en/examples/net/furchtermanLayout#fruchtermanWebWorker\"\n    }, \"example\"), ' ', \"in G6\"));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n\n  var CANVAS_HEIGHT = 600;\n  var CANVAS_WIDTH = 600;\n\n  function renderCircles(finalParticleData, numParticles) {\n    var canvas = new _gCanvas.Canvas({\n      container: 'container',\n      width: CANVAS_WIDTH,\n      height: CANVAS_HEIGHT\n    }); // draw edges\n\n    for (var i = 0; i < lineIndexBufferData.length; i += 2) {\n      var x1 = finalParticleData[lineIndexBufferData[i] * 4];\n      var y1 = finalParticleData[lineIndexBufferData[i] * 4 + 1];\n      var x2 = finalParticleData[lineIndexBufferData[i + 1] * 4];\n      var y2 = finalParticleData[lineIndexBufferData[i + 1] * 4 + 1];\n      var group = canvas.addGroup();\n      group.addShape('line', {\n        attrs: {\n          x1: convertWebGLCoord2Canvas(x1, CANVAS_WIDTH),\n          y1: convertWebGLCoord2Canvas(y1, CANVAS_HEIGHT),\n          x2: convertWebGLCoord2Canvas(x2, CANVAS_WIDTH),\n          y2: convertWebGLCoord2Canvas(y2, CANVAS_HEIGHT),\n          stroke: '#1890FF',\n          lineWidth: 1\n        }\n      });\n    }\n\n    var sumx = 0;\n    var sumy = 0; // draw nodes\n\n    for (var _i2 = 0; _i2 < numParticles * 4; _i2 += 4) {\n      var x = finalParticleData[_i2];\n      var y = finalParticleData[_i2 + 1];\n      sumx += x;\n      sumy += y;\n\n      var _group = canvas.addGroup();\n\n      _group.addShape('circle', {\n        attrs: {\n          x: convertWebGLCoord2Canvas(x, CANVAS_WIDTH),\n          y: convertWebGLCoord2Canvas(y, CANVAS_HEIGHT),\n          r: 5,\n          fill: 'red',\n          stroke: 'blue',\n          lineWidth: 2\n        }\n      });\n    }\n  }\n\n  function convertWebGLCoord2Canvas(c, size) {\n    return (c + 1) / 2 * size;\n  }\n\n  var lineIndexBufferData = [];\n  var maxEdgePerVetex; // @see https://github.com/nblintao/ParaGraphL/blob/master/sigma.layout.paragraphl.js#L192-L229\n\n  function buildTextureData(nodes, edges) {\n    var dataArray = [];\n    var nodeDict = [];\n    var mapIdPos = {};\n    var i = 0;\n\n    for (i = 0; i < nodes.length; i++) {\n      var n = nodes[i];\n      mapIdPos[n.id] = i;\n      dataArray.push(n.x);\n      dataArray.push(n.y);\n      dataArray.push(0);\n      dataArray.push(0);\n      nodeDict.push([]);\n    }\n\n    for (i = 0; i < edges.length; i++) {\n      var e = edges[i];\n      nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n      nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n      lineIndexBufferData.push(mapIdPos[e.source], mapIdPos[e.target]);\n    }\n\n    maxEdgePerVetex = 0;\n\n    for (i = 0; i < nodes.length; i++) {\n      var offset = dataArray.length;\n      var dests = nodeDict[i];\n      var len = dests.length;\n      dataArray[i * 4 + 2] = offset;\n      dataArray[i * 4 + 3] = dests.length;\n      maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n\n      for (var j = 0; j < len; ++j) {\n        var dest = dests[j];\n        dataArray.push(+dest);\n      }\n    }\n\n    while (dataArray.length % 4 !== 0) {\n      dataArray.push(0);\n    }\n\n    return new Float32Array(dataArray);\n  }\n});"}]}}}}