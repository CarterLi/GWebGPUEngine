{"componentChunkName":"component---node-modules-antv-gatsby-theme-antv-site-templates-example-tsx","path":"/en/examples/gpgpu/basic/mergeSort","result":{"data":{"site":{"siteMetadata":{"title":"GWebGPU","githubUrl":"https://github.com/antvis/GWebGPUEngine","examples":[{"slug":"gpgpu","icon":null,"title":{"zh":"GPGPU","en":"GPGPU"}},{"slug":"gpgpu/basic","icon":null,"title":{"zh":"基础算法","en":"Basic Algorithms"}},{"slug":"gpgpu/graph","icon":null,"title":{"zh":"图算法","en":"Graph"}},{"slug":"rendering","icon":null,"title":{"zh":"渲染","en":"Rendering"}}],"playground":{"container":"<div style=\"min-height: 500px; justify-content: center;position: relative\" id=\"wrapper\"/>","playgroundDidMount":null,"playgroundWillUnmount":null,"dependencies":{"@antv/g-webgpu":"latest"},"htmlCodeTemplate":null}},"pathPrefix":""},"allMarkdownRemark":{"edges":[{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们的计算任务很简单，实现两个向量相加。详见"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/tutorial/gpgpu/add2vectors"},"children":[{"type":"text","value":"教程"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/gpgpu/basic/add2vectors"},"frontmatter":{"title":"Add 2 vectors","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/add2vectors/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们的计算任务很简单，实现两个向量相加。详见"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/tutorial/gpgpu/add2vectors"},"children":[{"type":"text","value":"教程"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/gpgpu/basic/add2vectors"},"frontmatter":{"title":"两个向量相加","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/add2vectors/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/gpgpu/graph/fruchterman"},"frontmatter":{"title":"Fruchterman 布局算法","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/graph/fruchterman/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/gpgpu/graph/fruchterman"},"frontmatter":{"title":"Fruchterman Layout","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/graph/fruchterman/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/gpgpu/basic/bitonicSort"},"frontmatter":{"title":"奇偶排序 (WebGPU Only)","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/bitonicSort/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/gpgpu/basic/mergeSort"},"frontmatter":{"title":"Merge Sort","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/mergeSort/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/gpgpu/basic/mergeSort"},"frontmatter":{"title":"归并排序","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/mergeSort/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/gpgpu/basic/bitonicSort"},"frontmatter":{"title":"Bitonic Sort (WebGPU Only)","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/bitonicSort/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/gpgpu/graph/sssp"},"frontmatter":{"title":"SSSP(Single source shortest path) (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/graph/sssp/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/gpgpu/graph/sssp"},"frontmatter":{"title":"单源最短路径算法 (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/graph/sssp/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/gpgpu/basic/reduce"},"frontmatter":{"title":"Reduce (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/reduce/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"只能在支持 WebGPU 的浏览器中运行，详见"},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/tutorial/gpgpu/reduce"},"children":[{"type":"text","value":"教程"}]},{"type":"text","value":"。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/gpgpu/basic/reduce"},"frontmatter":{"title":"Reduce (WebGPU Only)","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"gpgpu/basic/reduce/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"布局语法来自 ATOM: A grammar for unit visualizations"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"ATOM 语法："},{"type":"element","tagName":"a","properties":{"href":"https://intuinno.github.io/unit/#/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://intuinno.github.io/unit/#/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"中文翻译："},{"type":"element","tagName":"a","properties":{"href":"http://vis.pku.edu.cn/blog/atom_grammar/#more-9377","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"http://vis.pku.edu.cn/blog/atom_grammar/#more-9377"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"原论文中给出了布局的描述语法，但并未涉及布局间切换的动画，我们使用了 GWebGPU 的渲染能力："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"使用 instanced array 完成所有 mark 的高性能渲染"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"布局切换时在 Shader 中完成每个 mark 位置和大小的插值，目前为线性插值"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持拾取，基于 PixelPicking"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"后续可完善的方向包括："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持更多可配置的插值函数、mark 类型"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"更多布局，扩展至 3D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"渲染图例和坐标轴"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持分面，例如 "},{"type":"element","tagName":"a","properties":{"href":"https://sanddance.js.org/app/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://sanddance.js.org/app/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"配合滚动，实现 scrollytelling "},{"type":"element","tagName":"a","properties":{"href":"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"本例数据是泰坦尼克号生还者和遇难者数据，每一条形如 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Class: First, Age: Adult, Sex: Male, Survived: Yes"}]},{"type":"text","value":"。\n黄色代表生还，蓝色代表遇难。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/rendering/unitchart"},"frontmatter":{"title":"Unitchart","order":6,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/unitchart/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"布局语法来自 ATOM: A grammar for unit visualizations"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"ATOM 语法："},{"type":"element","tagName":"a","properties":{"href":"https://intuinno.github.io/unit/#/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://intuinno.github.io/unit/#/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"中文翻译："},{"type":"element","tagName":"a","properties":{"href":"http://vis.pku.edu.cn/blog/atom_grammar/#more-9377","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"http://vis.pku.edu.cn/blog/atom_grammar/#more-9377"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"原论文中给出了布局的描述语法，但并未涉及布局间切换的动画，我们使用了 GWebGPU 的渲染能力："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"使用 instanced array 完成所有 mark 的高性能渲染"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"布局切换时在 Shader 中完成每个 mark 位置和大小的插值，目前为线性插值"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持拾取，基于 PixelPicking"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"后续可完善的方向包括："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持更多可配置的插值函数、mark 类型"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"更多布局，扩展至 3D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"渲染图例和坐标轴"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"支持分面，例如 "},{"type":"element","tagName":"a","properties":{"href":"https://sanddance.js.org/app/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://sanddance.js.org/app/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"配合滚动，实现 scrollytelling "},{"type":"element","tagName":"a","properties":{"href":"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"本例数据是泰坦尼克号生还者和遇难者数据，每一条形如 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Class: First, Age: Adult, Sex: Male, Survived: Yes"}]},{"type":"text","value":"。\n黄色代表生还，蓝色代表遇难。"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/rendering/unitchart"},"frontmatter":{"title":"Unitchart","order":6,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/unitchart/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/rendering/meshes"},"frontmatter":{"title":"Mesh","order":6,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/meshes/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/rendering/meshes"},"frontmatter":{"title":"Mesh","order":6,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/meshes/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在 Compute Shader 中进行光线追踪，详见："},{"type":"element","tagName":"a","properties":{"href":"https://zhuanlan.zhihu.com/p/212162113%E3%80%82","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/212162113。"}]}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/rendering/raytracer"},"frontmatter":{"title":"RayTracer","order":7,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/raytracer/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/rendering/raytracer"},"frontmatter":{"title":"RayTracer","order":7,"icon":null},"parent":{"__typename":"File","relativePath":"rendering/raytracer/index.en.md"}}}]}},"pageContext":{"exampleSections":{"examples":[{"relativePath":"gpgpu/basic/mergeSort/demo/index.tsx","absolutePath":"/Users/pyq/workspace/webgpu/GWebGPUEngine/examples/gpgpu/basic/mergeSort/demo/index.tsx","order":0,"filename":"index.tsx","title":"归并排序","screenshot":"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/screenshot-placeholder-b8e70.png","source":"import { World } from '@antv/g-webgpu';\nimport { Compiler } from '@antv/g-webgpu-compiler';\nimport React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n// ported from https://bl.ocks.org/zz85/cafa1b8b3098b5a40e918487422d47f6\nconst gCode = `\nimport { localInvocationID, globalInvocationID } from 'g-webgpu';\n\n@numthreads(1024, 1, 1)\nclass MergeSort {\n  @in @out\n  gData: float[];\n\n  @in\n  uPass: float;\n\n  @in\n  uStage2: float;\n\n  @in\n  uPassModStage: float;\n\n  @in\n  uStage2PmS1: float;\n\n  @main\n  compute() {\n    const gid = globalInvocationID.x;\n    const j = floor(mod(float(gid), this.uStage2));\n\n    const compare =\n\t\t\t(j < this.uPassModStage || j > this.uStage2PmS1) ? 0 :\n\t\t\t\tmod((j + this.uPassModStage) / this.uPass, 2) < 1 ? 1:\n\t\t\t\t -1;\n\n    const offset = int(compare * this.uPass);\n    \n    const current = this.gData[gid];\n    const reference = this.gData[gid + offset];\n\n\t\tthis.gData[gid] = (current * compare < reference * compare) ? current : reference;\n  }\n}\n`;\n\nconst resetData = (arr: Float32Array, sortLength: number) => {\n  for (let i = 0; i < sortLength; i++) {\n    arr[i] = Math.fround(Math.random() * 10);\n  }\n};\n\nconst validateSorted = (arr: Float32Array) => {\n  const length = arr.length;\n  for (let i = 0; i < length; i++) {\n    if (i !== length - 1 && arr[i] > arr[i + 1]) {\n      console.log('validation error:', i, arr[i], arr[i + 1]);\n      return false;\n    }\n  }\n  return true;\n};\n\nconst MAX_THREAD_NUM = 1024;\nconst ELEMENTS_NUM = 2048000;\nconst data = new Float32Array(ELEMENTS_NUM);\nresetData(data, ELEMENTS_NUM);\nconst threadgroupsPerGrid = Math.max(1, ELEMENTS_NUM / MAX_THREAD_NUM);\n\nlet stage = 0; // stage iterations\nlet pass = 0;\n\nconst App = React.memo(function MergeSort() {\n  const [cpuElapsedTime, setCpuElapsedTime] = useState(0);\n  const [gpuElapsedTime, setGpuElapsedTime] = useState(0);\n\n  const computeCPU = () => {\n    const now = performance.now();\n    data.sort((a, b) => a - b);\n\n    setCpuElapsedTime(Math.round(performance.now() - now));\n    console.log(`CPU sort result validation: ${validateSorted(data) ? 'success' : 'failure'}`);\n  };\n\n  const computeGPU = async () => {\n    // compile our kernel code\n    const compiler = new Compiler();\n    const precompiledBundle1 = compiler.compileBundle(gCode);\n\n    // create world\n    const world = World.create({\n      engineOptions: {\n        supportCompute: true,\n      },\n    });\n\n    const kernel = world\n      .createKernel(precompiledBundle1)\n      .setDispatch([threadgroupsPerGrid, 1, 1])\n      .setBinding('gData', data);\n\n    const now = performance.now();\n    while (true) {\n      if (stage > Math.log2(ELEMENTS_NUM) + 1) {\n        break;\n      }\n\n      const tPass = 1 << pass;\n      const tStage = 1 << stage;\n      const uStage2 = tStage + tStage;\n      const uPassModStage = tPass % tStage;\n      const uStage2PmS1 = uStage2 - uPassModStage - 1;\n\n      kernel.setBinding({\n        uStage2,\n        uPassModStage,\n        uStage2PmS1,\n        uPass: tPass,\n      });\n\n      await kernel.execute();\n\n      pass--;\n      if (pass < 0) {\n        stage++;\n        pass = stage;\n      }\n    }\n\n    const output = await kernel.getOutput();\n\n    setGpuElapsedTime(Math.round(performance.now() - now));\n    console.log(`GPU sort result validation: ${validateSorted(output) ? 'success' : 'failure'}`);\n  };\n\n  useEffect(() => {\n    computeGPU();\n    computeCPU();\n  }, []);\n\n  return (\n    <ul>\n      <li>number of elements: {ELEMENTS_NUM}</li>\n      <li>CPU sort time: {cpuElapsedTime} ms</li>\n      <li>GPU sort time: {gpuElapsedTime} ms</li>\n    </ul>\n  );\n});\n\nReactDOM.render(<App />, document.getElementById('wrapper'));\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@antv/g-webgpu\", \"@antv/g-webgpu-compiler\", \"react\", \"react-dom\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@antv/g-webgpu\"), require(\"@antv/g-webgpu-compiler\"), require(\"react\"), require(\"react-dom\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.gWebgpu, global.gWebgpuCompiler, global.react, global.reactDom);\n    global.index = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_gWebgpu, _gWebgpuCompiler, _react, _reactDom) {\n  \"use strict\";\n\n  _react = _interopRequireWildcard(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  // ported from https://bl.ocks.org/zz85/cafa1b8b3098b5a40e918487422d47f6\n  var gCode = \"\\nimport { localInvocationID, globalInvocationID } from 'g-webgpu';\\n\\n@numthreads(1024, 1, 1)\\nclass MergeSort {\\n  @in @out\\n  gData: float[];\\n\\n  @in\\n  uPass: float;\\n\\n  @in\\n  uStage2: float;\\n\\n  @in\\n  uPassModStage: float;\\n\\n  @in\\n  uStage2PmS1: float;\\n\\n  @main\\n  compute() {\\n    const gid = globalInvocationID.x;\\n    const j = floor(mod(float(gid), this.uStage2));\\n\\n    const compare =\\n\\t\\t\\t(j < this.uPassModStage || j > this.uStage2PmS1) ? 0 :\\n\\t\\t\\t\\tmod((j + this.uPassModStage) / this.uPass, 2) < 1 ? 1:\\n\\t\\t\\t\\t -1;\\n\\n    const offset = int(compare * this.uPass);\\n    \\n    const current = this.gData[gid];\\n    const reference = this.gData[gid + offset];\\n\\n\\t\\tthis.gData[gid] = (current * compare < reference * compare) ? current : reference;\\n  }\\n}\\n\";\n\n  var resetData = function resetData(arr, sortLength) {\n    for (var i = 0; i < sortLength; i++) {\n      arr[i] = Math.fround(Math.random() * 10);\n    }\n  };\n\n  var validateSorted = function validateSorted(arr) {\n    var length = arr.length;\n\n    for (var i = 0; i < length; i++) {\n      if (i !== length - 1 && arr[i] > arr[i + 1]) {\n        console.log('validation error:', i, arr[i], arr[i + 1]);\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var MAX_THREAD_NUM = 1024;\n  var ELEMENTS_NUM = 2048000;\n  var data = new Float32Array(ELEMENTS_NUM);\n  resetData(data, ELEMENTS_NUM);\n  var threadgroupsPerGrid = Math.max(1, ELEMENTS_NUM / MAX_THREAD_NUM);\n  var stage = 0; // stage iterations\n\n  var pass = 0;\n\n  var App = /*#__PURE__*/_react.default.memo(function MergeSort() {\n    var _useState = (0, _react.useState)(0),\n        _useState2 = _slicedToArray(_useState, 2),\n        cpuElapsedTime = _useState2[0],\n        setCpuElapsedTime = _useState2[1];\n\n    var _useState3 = (0, _react.useState)(0),\n        _useState4 = _slicedToArray(_useState3, 2),\n        gpuElapsedTime = _useState4[0],\n        setGpuElapsedTime = _useState4[1];\n\n    var computeCPU = function computeCPU() {\n      var now = performance.now();\n      data.sort(function (a, b) {\n        return a - b;\n      });\n      setCpuElapsedTime(Math.round(performance.now() - now));\n      console.log(\"CPU sort result validation: \".concat(validateSorted(data) ? 'success' : 'failure'));\n    };\n\n    var computeGPU = async function computeGPU() {\n      // compile our kernel code\n      var compiler = new _gWebgpuCompiler.Compiler();\n      var precompiledBundle1 = compiler.compileBundle(gCode); // create world\n\n      var world = _gWebgpu.World.create({\n        engineOptions: {\n          supportCompute: true\n        }\n      });\n\n      var kernel = world.createKernel(precompiledBundle1).setDispatch([threadgroupsPerGrid, 1, 1]).setBinding('gData', data);\n      var now = performance.now();\n\n      while (true) {\n        if (stage > Math.log2(ELEMENTS_NUM) + 1) {\n          break;\n        }\n\n        var tPass = 1 << pass;\n        var tStage = 1 << stage;\n        var uStage2 = tStage + tStage;\n        var uPassModStage = tPass % tStage;\n        var uStage2PmS1 = uStage2 - uPassModStage - 1;\n        kernel.setBinding({\n          uStage2: uStage2,\n          uPassModStage: uPassModStage,\n          uStage2PmS1: uStage2PmS1,\n          uPass: tPass\n        });\n        await kernel.execute();\n        pass--;\n\n        if (pass < 0) {\n          stage++;\n          pass = stage;\n        }\n      }\n\n      var output = await kernel.getOutput();\n      setGpuElapsedTime(Math.round(performance.now() - now));\n      console.log(\"GPU sort result validation: \".concat(validateSorted(output) ? 'success' : 'failure'));\n    };\n\n    (0, _react.useEffect)(function () {\n      computeGPU();\n      computeCPU();\n    }, []);\n    return /*#__PURE__*/_react.default.createElement(\"ul\", null, /*#__PURE__*/_react.default.createElement(\"li\", null, \"number of elements: \", ELEMENTS_NUM), /*#__PURE__*/_react.default.createElement(\"li\", null, \"CPU sort time: \", cpuElapsedTime, \" ms\"), /*#__PURE__*/_react.default.createElement(\"li\", null, \"GPU sort time: \", gpuElapsedTime, \" ms\"));\n  });\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('wrapper'));\n});"}]}}},"staticQueryHashes":["3000541721","3000541721","653731124"]}