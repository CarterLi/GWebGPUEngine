{"componentChunkName":"component---node-modules-antv-gatsby-theme-antv-site-templates-document-tsx","path":"/en/docs/api/gpgpu/implements","result":{"data":{"site":{"siteMetadata":{"title":"GWebGPU","githubUrl":"https://github.com/antvis/GWebGPUEngine","docs":[{"slug":"api/gpgpu","title":{"zh":"GPGPU","en":"GPGPU"},"order":0},{"slug":"api/rendering","title":{"zh":"渲染","en":"Rendering"},"order":0},{"slug":"tutorial/gpgpu","title":{"zh":"GPGPU","en":"GPGPU"},"order":0},{"slug":"tutorial/rendering","title":{"zh":"渲染","en":"Rendering"},"order":0}]},"pathPrefix":""},"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"使用图形渲染 API 实现的经典 GPGPU 的原理可以简单总结为：用纹理映射实现的科学计算 (compulation by texturing)。\n考虑到兼容性，我们在 WebGL 中也使用了这个方式。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下图来自：「GPGPU 编程技术 - 从 GLSL、CUDA 到 OpenCL」\n"},{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/3608471/84491693-83f46700-acd7-11ea-8d5a-15edb3285e75.png","alt":"image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{"id":"渲染到纹理","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%E6%B8%B2%E6%9F%93%E5%88%B0%E7%BA%B9%E7%90%86","ariaLabel":"渲染到纹理 permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"渲染到纹理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通常来说图形渲染 API 最终的输出目标就是屏幕，显示渲染结果。但是在 GPGPU 场景中我们只是希望在 CPU 侧读取最终的计算结果。因此会使用到渲染 API 提供的离屏渲染功能 --- 渲染到纹理，其中的关键技术就是使用帧缓存对象（Framebuffer Object - FBO）作为渲染对象。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是这种方式存在一个明显的限制，对于所有线程，纹理缓存要么是只读的，要么就是只写的，没法实现一个线程在读纹理，另一个在写纹理。\n本质上是由 GPU 的硬件设计决定的，如果想要实现多个线程同时对同一个纹理进行读/写操作，需要设计复杂的同步机制避免读写冲突，势必会影响到线程并行执行的效率。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此在经典 GPGPU 的实现中，通常我们会准备两个纹理，一个用来保存输入数据，一个用来保存输出数据。这也是为何我们只允许使用一个 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"@out"}]},{"type":"text","value":" 声明来输出变量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们的数据存储在显存中，使用 RGBA 的纹理格式，每一个图元包含 4 个通道，因此在 GWebGPU 中使用 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"vec4[]"}]},{"type":"text","value":" 是最省内存的数据格式。如果使用 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"float[]"}]},{"type":"text","value":"，每个图元中 GBA 三个通道就被浪费了。当然数据类型的决定权在开发者，可以根据实际程序中访问方便程度决定。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{"id":"调用绘制命令","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%E8%B0%83%E7%94%A8%E7%BB%98%E5%88%B6%E5%91%BD%E4%BB%A4","ariaLabel":"调用绘制命令 permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"调用绘制命令"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们的计算逻辑写在片元着色器（Fragment Shader）中，在渲染管线的光栅化阶段，每个像素被分配给一个线程进行着色，达到并行效果。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果映射到 CPU 中的计算概念，纹理可以看作是数组，而片元着色器执行的程序就是循环语句。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{"id":"什么是纹理映射","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84","ariaLabel":"什么是纹理映射 permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"什么是纹理映射"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一个 3D 模型由很多个三角面组成，理论上每个三角面都可以继续无限细分，但给每个三角面着色是很消耗性能的。更快的做法是贴图，把一张二维位图（纹理）贴在模型的表面，这个过程就是纹理映射。我们不需要为模型每一个顶点定义纹理坐标，只需要定义四个角的坐标，剩余的交给渲染管线做插值即可。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{"id":"乒乓技术","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%E4%B9%92%E4%B9%93%E6%8A%80%E6%9C%AF","ariaLabel":"乒乓技术 permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"乒乓技术"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"很多算法需要连续运行多次，例如 G6 中使用的布局算法需要迭代多次达到稳定状态。上一次迭代中输出的计算结果，需要作为下一次迭代的输入。\n在实际实现中，我们会分配两张纹理缓存，每次迭代后对输入和输出纹理进行 swap。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{"id":"参考资料","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99","ariaLabel":"参考资料 permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"参考资料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"「GPGPU 编程技术 - 从 GLSL、CUDA 到 OpenCL」"},{"type":"element","tagName":"a","properties":{"href":"https://book.douban.com/subject/6538230/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"🔗"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.vizitsolutions.com/portfolio/webgl/gpgpu/","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.vizitsolutions.com/portfolio/webgl/gpgpu/"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"tableOfContents":"<ul>\n<li><a href=\"/en/docs/api/gpgpu/implements/#%E6%B8%B2%E6%9F%93%E5%88%B0%E7%BA%B9%E7%90%86\">渲染到纹理</a></li>\n<li><a href=\"/en/docs/api/gpgpu/implements/#%E8%B0%83%E7%94%A8%E7%BB%98%E5%88%B6%E5%91%BD%E4%BB%A4\">调用绘制命令</a></li>\n<li><a href=\"/en/docs/api/gpgpu/implements/#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84\">什么是纹理映射</a></li>\n<li><a href=\"/en/docs/api/gpgpu/implements/#%E4%B9%92%E4%B9%93%E6%8A%80%E6%9C%AF\">乒乓技术</a></li>\n<li><a href=\"/en/docs/api/gpgpu/implements/#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\">参考资料</a></li>\n</ul>","fields":{"slug":"/en/docs/api/gpgpu/implements","readingTime":{"text":"1 min read","time":26100}},"frontmatter":{"title":"经典 GPGPU 的实现原理"},"parent":{"__typename":"File","relativePath":"api/gpgpu/implements.en.md"}},"allMarkdownRemark":{"edges":[{"node":{"fields":{"slug":"/en/docs/tutorial/gpgpu/quickstart"},"frontmatter":{"title":"Quick Start","order":0}}},{"node":{"fields":{"slug":"/zh/docs/tutorial/gpgpu/quickstart"},"frontmatter":{"title":"快速上手","order":0}}},{"node":{"fields":{"slug":"/en/docs/api/gpgpu/gwebgpu"},"frontmatter":{"title":"简介","order":0}}},{"node":{"fields":{"slug":"/zh/docs/api/gpgpu/gwebgpu"},"frontmatter":{"title":"简介","order":0}}},{"node":{"fields":{"slug":"/en/docs/tutorial/gpgpu/add2vectors"},"frontmatter":{"title":"两个向量相加","order":1}}},{"node":{"fields":{"slug":"/zh/docs/tutorial/gpgpu/add2vectors"},"frontmatter":{"title":"两个向量相加","order":1}}},{"node":{"fields":{"slug":"/zh/docs/api/gpgpu/syntax"},"frontmatter":{"title":"Shader 语法介绍","order":1}}},{"node":{"fields":{"slug":"/en/docs/api/gpgpu/syntax"},"frontmatter":{"title":"Shader 语法介绍","order":1}}},{"node":{"fields":{"slug":"/en/docs/tutorial/gpgpu/fruchterman"},"frontmatter":{"title":"Fruchterman 布局算法","order":2}}},{"node":{"fields":{"slug":"/en/docs/tutorial/gpgpu/bellman-ford"},"frontmatter":{"title":"Bellman-Ford 最短路径算法","order":2}}},{"node":{"fields":{"slug":"/zh/docs/tutorial/gpgpu/bellman-ford"},"frontmatter":{"title":"Bellman-Ford 最短路径算法","order":2}}},{"node":{"fields":{"slug":"/zh/docs/tutorial/gpgpu/fruchterman"},"frontmatter":{"title":"Fruchterman 布局算法","order":2}}},{"node":{"fields":{"slug":"/en/docs/api/gpgpu/compute-pipeline"},"frontmatter":{"title":"Compiler & Kernel API","order":2}}},{"node":{"fields":{"slug":"/zh/docs/api/gpgpu/compute-pipeline"},"frontmatter":{"title":"Compiler & Kernel API","order":2}}},{"node":{"fields":{"slug":"/zh/docs/tutorial/gpgpu/reduce"},"frontmatter":{"title":"Reduce 求和","order":3}}},{"node":{"fields":{"slug":"/en/docs/tutorial/gpgpu/reduce"},"frontmatter":{"title":"Reduce 求和","order":3}}},{"node":{"fields":{"slug":"/en/docs/api/gpgpu/workgroup"},"frontmatter":{"title":"线程、共享内存和同步","order":3}}},{"node":{"fields":{"slug":"/zh/docs/api/gpgpu/workgroup"},"frontmatter":{"title":"线程、共享内存和同步","order":3}}},{"node":{"fields":{"slug":"/zh/docs/api/gpgpu/debug"},"frontmatter":{"title":"Debug Shader","order":4}}},{"node":{"fields":{"slug":"/en/docs/api/gpgpu/debug"},"frontmatter":{"title":"Debug Shader","order":4}}},{"node":{"fields":{"slug":"/en/docs/api/gpgpu/vscode-extension"},"frontmatter":{"title":"VS Code Extension","order":5}}},{"node":{"fields":{"slug":"/zh/docs/api/gpgpu/vscode-extension"},"frontmatter":{"title":"VS Code 扩展","order":5}}},{"node":{"fields":{"slug":"/en/docs/api/gpgpu/implements"},"frontmatter":{"title":"经典 GPGPU 的实现原理","order":6}}},{"node":{"fields":{"slug":"/zh/docs/api/gpgpu/implements"},"frontmatter":{"title":"经典 GPGPU 的实现原理","order":6}}},{"node":{"fields":{"slug":"/zh/docs/api/gpgpu/faq"},"frontmatter":{"title":"FAQ","order":10}}},{"node":{"fields":{"slug":"/en/docs/api/gpgpu/faq"},"frontmatter":{"title":"FAQ","order":10}}},{"node":{"fields":{"slug":"/en/docs/api/gpgpu/roadmap"},"frontmatter":{"title":"Roadmap","order":10}}},{"node":{"fields":{"slug":"/zh/docs/api/gpgpu/roadmap"},"frontmatter":{"title":"Roadmap","order":10}}},{"node":{"fields":{"slug":"/zh/docs/api/gpgpu/changelog"},"frontmatter":{"title":"更新日志","order":20}}},{"node":{"fields":{"slug":"/en/docs/api/gpgpu/changelog"},"frontmatter":{"title":"更新日志","order":20}}}]}},"pageContext":{}},"staticQueryHashes":["3000541721","3000541721","653731124"]}